[{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/cache-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/decorators/cacheable.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/examples.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cache/types/cache.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/cluster.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/connection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/reset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/seed-comprehensive.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/seed-rbac.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/db/seeds/payment-gateways.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/middleware/error.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/middleware/guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/middleware/logger.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/middleware/transform.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/__tests__/affiliate.public.routes.smoke.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/__tests__/commission-calculator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/__tests__/payout-selection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/__tests__/referral-code.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/routes/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/routes/affiliate.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/routes/public.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/schema/affiliate.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/analytics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/commission.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/payout.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/profile.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/referral.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/services/tier.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/test-helpers/db-access.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/types/affiliate.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/types/context.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/utils/commission-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/utils/payout-selection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/affiliate/utils/referral-code.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/routes/agents.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/schema/agents.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/services/agent-workflows.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AgentService' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WorkflowContext' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Agent Workflows Service\n * Autonomous workflows and scheduled tasks for agents with memory\n */\n\nimport { MastraAgentService } from './mastra-agent.service';\nimport { AgentService } from './agent.service';\nimport { db } from '@/db';\nimport { eq, and } from 'drizzle-orm';\nimport logger from '@/utils/logger';\nimport { agents } from '../schema/agents.schema';\nimport type { AgentType } from '../types/agents.types';\n\n/**\n * Workflow Context\n */\ninterface WorkflowContext {\n  agentId: string;\n  tenantId: string;\n  agentType: AgentType;\n  trigger: string;\n}\n\n/**\n * Agent Workflows Service\n * Manages autonomous workflows and scheduled tasks with learning capabilities\n */\nexport class AgentWorkflowsService {\n  /**\n   * Execute Financial Monitoring Workflow\n   * Monitors financial metrics and learns from patterns\n   */\n  static async executeFinancialMonitoring(agentId: string, tenantId: string): Promise<any> {\n    try {\n      logger.info('Executing financial monitoring workflow', { agentId });\n\n      // Step 1: Analyze Revenue Trends with Memory\n      const revenueAnalysis = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze revenue trends for the last 7 days. Calculate growth rate. Search your memory for similar revenue patterns. If revenue dropped more than 10%, alert the CEO immediately and remember this incident.'\n      );\n\n      // Step 2: Check Payment Processing\n      const paymentCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Check payment processing status. Query failed payments in the last 24 hours. Recall past payment issues from memory. If failure rate is above 5%, investigate, report to CEO, and store the resolution pattern.'\n      );\n\n      // Step 3: Subscription Health Check\n      const subscriptionCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze subscription metrics: active subscriptions, churn rate, failed renewals. Retrieve similar churn patterns from memory. If churn increased by more than 20%, create action plan, report to CEO, and remember what works.'\n      );\n\n      // Step 4: Generate Financial Report with Insights\n      const report = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        `Based on previous analysis:\n        - Revenue: ${JSON.stringify(revenueAnalysis)}\n        - Payments: ${JSON.stringify(paymentCheck)}\n        - Subscriptions: ${JSON.stringify(subscriptionCheck)}\n\n        Generate executive summary with key findings and recommendations. Store important insights for future reference.`\n      );\n\n      logger.info('Financial monitoring workflow completed', { agentId });\n\n      return {\n        success: true,\n        revenue: revenueAnalysis,\n        payments: paymentCheck,\n        subscriptions: subscriptionCheck,\n        report,\n      };\n    } catch (error) {\n      logger.error('Financial monitoring workflow failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute Security Monitoring Workflow\n   * Monitors security threats and learns threat patterns\n   */\n  static async executeSecurityMonitoring(agentId: string, tenantId: string): Promise<any> {\n    try {\n      logger.info('Executing security monitoring workflow', { agentId });\n\n      // Step 1: Check Failed Login Attempts\n      const loginCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Query failed login attempts in the last hour. Search memory for similar attack patterns. If more than 5 attempts from same IP, flag as potential brute force attack, notify security team, and store attack signature.'\n      );\n\n      // Step 2: Monitor API Rate Limiting\n      const rateLimitCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Check rate limiting violations. Query blocked requests and identify patterns. Recall past coordinated attacks from memory. If coordinated attack detected, escalate to URGENT, recommend IP blocking, and remember mitigation strategy.'\n      );\n\n      // Step 3: Audit Log Analysis\n      const auditAnalysis = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze audit logs for suspicious activities: privilege escalations, unauthorized data access, configuration changes. Retrieve similar incidents from memory. Alert CEO on critical findings and store detection patterns.'\n      );\n\n      logger.info('Security monitoring workflow completed', { agentId });\n\n      return {\n        success: true,\n        loginAttempts: loginCheck,\n        rateLimiting: rateLimitCheck,\n        auditLogs: auditAnalysis,\n      };\n    } catch (error) {\n      logger.error('Security monitoring workflow failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute Trading Operations Monitoring Workflow\n   * Monitors trading system health and learns from market conditions\n   */\n  static async executeTradingOpsMonitoring(agentId: string, tenantId: string): Promise<any> {\n    try {\n      logger.info('Executing trading ops monitoring workflow', { agentId });\n\n      // Step 1: Check Exchange Connectivity\n      const exchangeCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Check connectivity status of all exchange connections. Search memory for past connectivity issues. If any exchange is down or experiencing high latency (>1000ms), alert immediately, recommend switching to backup, and remember downtime patterns.'\n      );\n\n      // Step 2: Monitor Order Execution\n      const orderCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze order execution performance. Check failed orders, execution time, slippage. Recall similar market conditions from memory. If success rate drops below 95%, investigate root cause, report with recommendations, and store optimization strategies.'\n      );\n\n      // Step 3: Risk Assessment\n      const riskCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Assess current risk exposure: open positions, leverage ratios, stop-loss coverage. Retrieve past high-risk situations from memory. If any position exceeds risk limits, recommend immediate action to risk management and remember successful mitigations.'\n      );\n\n      // Step 4: Bot Performance Analysis\n      const botAnalysis = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze trading bot performance: PnL, win rate, trade frequency. Search memory for similar bot performance patterns. If any bot is underperforming (negative PnL > 5%), recommend pause or strategy adjustment and store what works.'\n      );\n\n      logger.info('Trading ops monitoring workflow completed', { agentId });\n\n      return {\n        success: true,\n        exchanges: exchangeCheck,\n        orders: orderCheck,\n        risk: riskCheck,\n        bots: botAnalysis,\n      };\n    } catch (error) {\n      logger.error('Trading ops monitoring workflow failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute Support Monitoring Workflow\n   * Monitors customer support metrics and learns from resolutions\n   */\n  static async executeSupportMonitoring(agentId: string, tenantId: string): Promise<any> {\n    try {\n      logger.info('Executing support monitoring workflow', { agentId });\n\n      // Step 1: Check SLA Compliance\n      const slaCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Check SLA compliance for all open tickets. Query tickets approaching SLA deadline. Recall past SLA breaches from memory. If any high-priority ticket is at risk, escalate, notify support manager, and remember successful interventions.'\n      );\n\n      // Step 2: Analyze Response Times\n      const responseAnalysis = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze average response times for the last 24 hours. Search memory for similar workload patterns. If response time increased by more than 50%, investigate workload, recommend staffing adjustments, and store optimization strategies.'\n      );\n\n      // Step 3: Customer Satisfaction Check\n      const satisfactionCheck = await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        'Analyze customer satisfaction scores (CSAT, NPS). Retrieve past satisfaction improvements from memory. If satisfaction dropped below 80%, identify common issues, create improvement plan, and remember what improves satisfaction.'\n      );\n\n      logger.info('Support monitoring workflow completed', { agentId });\n\n      return {\n        success: true,\n        sla: slaCheck,\n        responseTimes: responseAnalysis,\n        satisfaction: satisfactionCheck,\n      };\n    } catch (error) {\n      logger.error('Support monitoring workflow failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute Workflow for Agent\n   */\n  static async executeWorkflow(agentId: string, tenantId: string, workflowType: string): Promise<any> {\n    try {\n      logger.info('Executing agent workflow', {\n        agentId,\n        workflowType,\n      });\n\n      const [agentData] = await db\n        .select()\n        .from(agents)\n        .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n        .limit(1);\n\n      if (!agentData) {\n        throw new Error('Agent not found');\n      }\n\n      let result: any;\n\n      // Select workflow based on agent type or explicit workflow type\n      const workflow = workflowType || agentData.agentType;\n\n      switch (workflow) {\n        case 'financial':\n        case 'financial_monitoring':\n          result = await this.executeFinancialMonitoring(agentId, tenantId);\n          break;\n        case 'security':\n        case 'security_monitoring':\n          result = await this.executeSecurityMonitoring(agentId, tenantId);\n          break;\n        case 'trading_ops':\n        case 'trading_monitoring':\n          result = await this.executeTradingOpsMonitoring(agentId, tenantId);\n          break;\n        case 'support':\n        case 'support_monitoring':\n          result = await this.executeSupportMonitoring(agentId, tenantId);\n          break;\n        default:\n          throw new Error(`No workflow defined for type: ${workflow}`);\n      }\n\n      logger.info('Workflow executed successfully', {\n        agentId,\n        workflowType: workflow,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Workflow execution failed', {\n        agentId,\n        workflowType,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Schedule Periodic Monitoring for All Agents\n   * This should be called by a cron job or scheduler\n   */\n  static async schedulePeriodicMonitoring(tenantId: string): Promise<void> {\n    try {\n      logger.info('Starting scheduled monitoring for all agents', { tenantId });\n\n      // Get all active agents\n      const activeAgents = await db\n        .select()\n        .from(agents)\n        .where(and(eq(agents.tenantId, tenantId), eq(agents.isEnabled, true), eq(agents.status, 'active')))\n        .execute();\n\n      logger.info('Found active agents for monitoring', {\n        tenantId,\n        count: activeAgents.length,\n      });\n\n      // Execute monitoring for each agent in parallel\n      const monitoringPromises = activeAgents.map(async (agent) => {\n        try {\n          await MastraAgentService.runProactiveMonitoring(agent.id, tenantId);\n        } catch (error) {\n          logger.error('Agent monitoring failed', {\n            agentId: agent.id,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      });\n\n      await Promise.all(monitoringPromises);\n\n      logger.info('Scheduled monitoring completed', {\n        tenantId,\n        agentsMonitored: activeAgents.length,\n      });\n    } catch (error) {\n      logger.error('Scheduled monitoring failed', {\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  /**\n   * Execute Daily Report Workflow\n   * Generates comprehensive daily reports from all agents to CEO with learning\n   */\n  static async executeDailyReportWorkflow(tenantId: string): Promise<void> {\n    try {\n      logger.info('Executing daily report workflow with learning', { tenantId });\n\n      // Get all active agents\n      const activeAgents = await db\n        .select()\n        .from(agents)\n        .where(and(eq(agents.tenantId, tenantId), eq(agents.isEnabled, true)))\n        .execute();\n\n      // Get CEO agent\n      const [ceoAgent] = await db\n        .select()\n        .from(agents)\n        .where(and(eq(agents.tenantId, tenantId), eq(agents.agentType, 'ceo')))\n        .limit(1);\n\n      if (!ceoAgent) {\n        logger.warn('CEO agent not found, skipping daily report', { tenantId });\n        return;\n      }\n\n      // Each Level C agent generates and sends report to CEO with learnings\n      for (const agent of activeAgents) {\n        if (agent.agentType === 'ceo') continue; // Skip CEO itself\n\n        try {\n          await MastraAgentService.executeAutonomousTask(\n            agent.id,\n            tenantId,\n            `Generate a comprehensive daily report for your department. Include:\n            1. Key metrics and KPIs\n            2. Achievements and successes\n            3. Issues and challenges\n            4. Recommendations and action items\n            5. Forecast for tomorrow\n\n            Search your memory for similar past reports. Learn from what worked before.\n            Store important insights from today for future reference.\n\n            Report this to your manager (CEO) with subject \"Daily Report - ${agent.name}\".`\n          );\n\n          logger.info('Daily report sent with learning', {\n            fromAgent: agent.id,\n            agentType: agent.agentType,\n            toAgent: ceoAgent.id,\n          });\n        } catch (error) {\n          logger.error('Failed to generate daily report', {\n            agentId: agent.id,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      }\n\n      // CEO consolidates all reports with strategic insights\n      await MastraAgentService.executeAutonomousTask(\n        ceoAgent.id,\n        tenantId,\n        `Review all daily reports from your Level C agents. Generate an executive summary highlighting:\n        1. Overall company performance\n        2. Cross-departmental insights\n        3. Strategic recommendations\n        4. Action items for tomorrow\n\n        Search your memory for similar past situations and successful strategies.\n        Compare today's performance with historical patterns.\n        Store key strategic insights for future decision-making.\n\n        Create a comprehensive \"CEO Daily Executive Summary\" with learned patterns.`\n      );\n\n      logger.info('Daily report workflow completed with learning', { tenantId });\n    } catch (error) {\n      logger.error('Daily report workflow failed', {\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  /**\n   * Execute Learning Consolidation\n   * Agents review their memories and consolidate learnings\n   */\n  static async executeLearningConsolidation(agentId: string, tenantId: string): Promise<void> {\n    try {\n      logger.info('Executing learning consolidation', { agentId });\n\n      await MastraAgentService.executeAutonomousTask(\n        agentId,\n        tenantId,\n        `Review your memory storage from the past week. Identify:\n        1. Recurring patterns that were successful\n        2. Common errors and how they were resolved\n        3. Key decisions and their outcomes\n        4. Important insights for future reference\n\n        Consolidate these learnings into strategic knowledge.\n        Store high-level patterns and insights.\n        Create a summary of what you learned this week.`\n      );\n\n      logger.info('Learning consolidation completed', { agentId });\n    } catch (error) {\n      logger.error('Learning consolidation failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/services/agent.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'agentMetrics' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AgentSystemPrompts' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'agent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":180,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":180,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'agent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":205,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":205,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userMessage' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":281,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":281,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Agent Service\n * Main service for managing autonomous agents\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc } from 'drizzle-orm';\nimport logger from '@/utils/logger';\nimport { NotFoundError, BadRequestError } from '@/utils/errors';\nimport { ollamaService } from './ollama.service';\nimport {\n  agents,\n  agentConversations,\n  agentActions,\n  agentCommunications,\n  agentMetrics,\n} from '../schema/agents.schema';\nimport type {\n  AgentType,\n  AgentStatus,\n  CreateAgentRequest,\n  UpdateAgentRequest,\n  AgentQueryRequest,\n  AgentQueryResponse,\n  AgentActionRequest,\n  AgentActionResponse,\n  AgentCommunicationRequest,\n  AgentHealthCheck,\n  AgentSystemPrompts,\n  MessageRole,\n} from '../types/agents.types';\n\nexport class AgentService {\n  /**\n   * Create a new agent\n   */\n  static async createAgent(data: CreateAgentRequest) {\n    try {\n      logger.info('Creating agent', {\n        agentType: data.agentType,\n        tenantId: data.tenantId,\n      });\n\n      // Validate model exists in Ollama\n      const modelExists = await ollamaService.checkModel();\n      if (!modelExists) {\n        logger.warn('Configured model not found, attempting to pull', {\n          model: data.config.model,\n        });\n        await ollamaService.pullModel(data.config.model);\n      }\n\n      // Create agent in database\n      const [agent] = await db\n        .insert(agents)\n        .values({\n          agentType: data.agentType,\n          name: data.name,\n          description: data.description,\n          title: data.title,\n          tenantId: data.tenantId,\n          departmentId: data.departmentId,\n          managerId: data.managerId,\n          employeeNumber: data.employeeNumber,\n          config: data.config,\n          status: 'inactive',\n          isEnabled: true,\n          metrics: {\n            decisionsMade: 0,\n            actionsExecuted: 0,\n            successRate: 0,\n            responseTimeMs: 0,\n            errorRate: 0,\n          },\n        })\n        .returning();\n\n      logger.info('Agent created successfully', {\n        agentId: agent.id,\n        agentType: agent.agentType,\n      });\n\n      return agent;\n    } catch (error) {\n      logger.error('Failed to create agent', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get agent by ID\n   */\n  static async getAgentById(agentId: string, tenantId: string) {\n    const [agent] = await db\n      .select()\n      .from(agents)\n      .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n      .limit(1);\n\n    if (!agent) {\n      throw new NotFoundError('Agent not found');\n    }\n\n    return agent;\n  }\n\n  /**\n   * List agents for tenant\n   */\n  static async listAgents(tenantId: string, filters?: { agentType?: AgentType; status?: AgentStatus }) {\n    const conditions = [eq(agents.tenantId, tenantId)];\n\n    if (filters?.agentType) {\n      conditions.push(eq(agents.agentType, filters.agentType));\n    }\n\n    if (filters?.status) {\n      conditions.push(eq(agents.status, filters.status as string));\n    }\n\n    return await db.select().from(agents).where(and(...conditions)).execute();\n  }\n\n  /**\n   * Update agent\n   */\n  static async updateAgent(agentId: string, tenantId: string, data: UpdateAgentRequest) {\n    const agent = await this.getAgentById(agentId, tenantId);\n\n    const [updated] = await db\n      .update(agents)\n      .set({\n        ...(data.name && { name: data.name }),\n        ...(data.description !== undefined && { description: data.description }),\n        ...(data.title !== undefined && { title: data.title }),\n        ...(data.departmentId !== undefined && { departmentId: data.departmentId }),\n        ...(data.managerId !== undefined && { managerId: data.managerId }),\n        ...(data.employeeNumber !== undefined && { employeeNumber: data.employeeNumber }),\n        ...(data.config && { config: { ...agent.config, ...data.config } }),\n        ...(data.status && { status: data.status }),\n        ...(data.isEnabled !== undefined && { isEnabled: data.isEnabled }),\n        updatedAt: new Date(),\n      })\n      .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n      .returning();\n\n    logger.info('Agent updated', { agentId, tenantId });\n\n    return updated;\n  }\n\n  /**\n   * Delete agent\n   */\n  static async deleteAgent(agentId: string, tenantId: string) {\n    await this.getAgentById(agentId, tenantId);\n\n    await db.delete(agents).where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)));\n\n    logger.info('Agent deleted', { agentId, tenantId });\n  }\n\n  /**\n   * List agents by department\n   */\n  static async listAgentsByDepartment(departmentId: string, tenantId: string) {\n    return await db\n      .select()\n      .from(agents)\n      .where(and(eq(agents.departmentId, departmentId), eq(agents.tenantId, tenantId)))\n      .execute();\n  }\n\n  /**\n   * Assign agent to department\n   */\n  static async assignToDepartment(agentId: string, tenantId: string, departmentId: string, managerId?: string) {\n    const agent = await this.getAgentById(agentId, tenantId);\n\n    const [updated] = await db\n      .update(agents)\n      .set({\n        departmentId,\n        ...(managerId && { managerId }),\n        updatedAt: new Date(),\n      })\n      .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n      .returning();\n\n    logger.info('Agent assigned to department', {\n      agentId,\n      departmentId,\n      managerId,\n    });\n\n    return updated;\n  }\n\n  /**\n   * Remove agent from department\n   */\n  static async removeFromDepartment(agentId: string, tenantId: string) {\n    const agent = await this.getAgentById(agentId, tenantId);\n\n    const [updated] = await db\n      .update(agents)\n      .set({\n        departmentId: null,\n        managerId: null,\n        updatedAt: new Date(),\n      })\n      .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n      .returning();\n\n    logger.info('Agent removed from department', { agentId });\n\n    return updated;\n  }\n\n  /**\n   * List agents reporting to a manager\n   */\n  static async listAgentsByManager(managerId: string, tenantId: string) {\n    return await db\n      .select()\n      .from(agents)\n      .where(and(eq(agents.managerId, managerId), eq(agents.tenantId, tenantId)))\n      .execute();\n  }\n\n  /**\n   * Query agent with prompt\n   */\n  static async query(agentId: string, tenantId: string, request: AgentQueryRequest): Promise<AgentQueryResponse> {\n    const startTime = Date.now();\n\n    try {\n      const agent = await this.getAgentById(agentId, tenantId);\n\n      if (!agent.isEnabled) {\n        throw new BadRequestError('Agent is disabled');\n      }\n\n      // Get conversation history if requested\n      const messages: Array<{ role: MessageRole; content: string }> = [];\n\n      if (request.includeHistory) {\n        const historyLimit = request.maxHistoryMessages || 10;\n        const history = await db\n          .select()\n          .from(agentConversations)\n          .where(and(eq(agentConversations.agentId, agentId), eq(agentConversations.tenantId, tenantId)))\n          .orderBy(desc(agentConversations.createdAt))\n          .limit(historyLimit);\n\n        const historyMessages = history.reverse().map((msg) => ({\n          role: msg.role as MessageRole,\n          content: msg.content,\n        }));\n\n        messages.push(...historyMessages);\n      }\n\n      // Add current prompt\n      messages.push({\n        role: 'user' as MessageRole,\n        content: request.prompt,\n      });\n\n      // Get response from Ollama\n      const response = await ollamaService.chat({\n        messages,\n        systemPrompt: agent.config.systemPrompt,\n        temperature: agent.config.temperature,\n        maxTokens: agent.config.maxTokens,\n      });\n\n      // Save conversation\n      const [userMessage] = await db\n        .insert(agentConversations)\n        .values({\n          agentId,\n          tenantId,\n          role: 'user',\n          content: request.prompt,\n        })\n        .returning();\n\n      const [assistantMessage] = await db\n        .insert(agentConversations)\n        .values({\n          agentId,\n          tenantId,\n          role: 'assistant',\n          content: response.content,\n          metadata: {\n            tokens: response.tokens,\n            model: response.model,\n            temperature: agent.config.temperature,\n            responseTimeMs: response.responseTimeMs,\n          },\n        })\n        .returning();\n\n      // Update agent metrics\n      await this.updateAgentMetrics(agentId, tenantId, {\n        responseTimeMs: response.responseTimeMs,\n        success: true,\n      });\n\n      // Update last activity\n      await db\n        .update(agents)\n        .set({\n          lastActiveAt: new Date(),\n          status: 'active',\n          updatedAt: new Date(),\n        })\n        .where(eq(agents.id, agentId));\n\n      const totalTime = Date.now() - startTime;\n\n      logger.info('Agent query completed', {\n        agentId,\n        responseTimeMs: totalTime,\n        tokens: response.tokens,\n      });\n\n      return {\n        response: response.content,\n        conversationId: assistantMessage.id,\n        metadata: {\n          tokens: response.tokens,\n          model: response.model,\n          responseTimeMs: totalTime,\n        },\n      };\n    } catch (error) {\n      const totalTime = Date.now() - startTime;\n\n      logger.error('Agent query failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n        responseTimeMs: totalTime,\n      });\n\n      // Update agent metrics for failure\n      await this.updateAgentMetrics(agentId, tenantId, {\n        responseTimeMs: totalTime,\n        success: false,\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute agent action\n   */\n  static async executeAction(\n    agentId: string,\n    tenantId: string,\n    request: AgentActionRequest\n  ): Promise<AgentActionResponse> {\n    const startTime = Date.now();\n\n    try {\n      const agent = await this.getAgentById(agentId, tenantId);\n\n      if (!agent.isEnabled) {\n        throw new BadRequestError('Agent is disabled');\n      }\n\n      // Create action record\n      const [action] = await db\n        .insert(agentActions)\n        .values({\n          agentId,\n          tenantId,\n          actionType: request.actionType,\n          actionName: request.actionName,\n          description: request.description,\n          input: request.input,\n          status: 'executing',\n          startedAt: new Date(),\n        })\n        .returning();\n\n      logger.info('Agent action started', {\n        agentId,\n        actionId: action.id,\n        actionType: request.actionType,\n      });\n\n      // Simulate action execution\n      // In real implementation, this would call specific action handlers\n      const output = {\n        actionId: action.id,\n        status: 'completed' as const,\n        result: 'Action executed successfully',\n        timestamp: new Date().toISOString(),\n      };\n\n      const executionTime = Date.now() - startTime;\n\n      // Update action record\n      await db\n        .update(agentActions)\n        .set({\n          status: 'completed',\n          output,\n          executionTimeMs: executionTime,\n          completedAt: new Date(),\n        })\n        .where(eq(agentActions.id, action.id));\n\n      // Update agent metrics\n      const currentMetrics = agent.metrics as {\n        decisionsMade: number;\n        actionsExecuted: number;\n        successRate: number;\n        responseTimeMs: number;\n        errorRate: number;\n        lastActivity?: string;\n      };\n      const updatedMetrics = {\n        ...currentMetrics,\n        actionsExecuted: currentMetrics.actionsExecuted + 1,\n      };\n\n      await db\n        .update(agents)\n        .set({\n          metrics: updatedMetrics,\n          lastActiveAt: new Date(),\n          updatedAt: new Date(),\n        })\n        .where(eq(agents.id, agentId));\n\n      logger.info('Agent action completed', {\n        agentId,\n        actionId: action.id,\n        executionTimeMs: executionTime,\n      });\n\n      return {\n        actionId: action.id,\n        status: 'completed',\n        output,\n        executionTimeMs: executionTime,\n      };\n    } catch (error) {\n      logger.error('Agent action failed', {\n        agentId,\n        actionType: request.actionType,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Send communication between agents\n   */\n  static async sendCommunication(tenantId: string, request: AgentCommunicationRequest) {\n    try {\n      // Validate both agents exist\n      await this.getAgentById(request.fromAgentId, tenantId);\n      await this.getAgentById(request.toAgentId, tenantId);\n\n      const [communication] = await db\n        .insert(agentCommunications)\n        .values({\n          fromAgentId: request.fromAgentId,\n          toAgentId: request.toAgentId,\n          tenantId,\n          message: request.message,\n          priority: request.priority || 'normal',\n          status: 'sent',\n          metadata: request.metadata,\n        })\n        .returning();\n\n      logger.info('Agent communication sent', {\n        communicationId: communication.id,\n        from: request.fromAgentId,\n        to: request.toAgentId,\n        priority: request.priority,\n      });\n\n      return communication;\n    } catch (error) {\n      logger.error('Failed to send agent communication', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get agent health check\n   */\n  static async getHealthCheck(agentId: string, tenantId: string): Promise<AgentHealthCheck> {\n    const agent = await this.getAgentById(agentId, tenantId);\n\n    const uptime = agent.createdAt\n      ? `${Math.floor((Date.now() - agent.createdAt.getTime()) / 1000 / 60 / 60)}h`\n      : '0h';\n\n    return {\n      agentId: agent.id,\n      agentType: agent.agentType as AgentType,\n      status: agent.status as AgentStatus,\n      uptime,\n      lastActivity: agent.lastActiveAt?.toISOString(),\n      metrics: agent.metrics as any,\n    };\n  }\n\n  /**\n   * Update agent metrics\n   */\n  private static async updateAgentMetrics(\n    agentId: string,\n    tenantId: string,\n    data: { responseTimeMs: number; success: boolean }\n  ) {\n    const agent = await this.getAgentById(agentId, tenantId);\n    const metrics = agent.metrics as {\n      decisionsMade: number;\n      actionsExecuted: number;\n      successRate: number;\n      responseTimeMs: number;\n      errorRate: number;\n    };\n\n    const totalDecisions = metrics.decisionsMade + 1;\n    const successCount = Math.floor((metrics.successRate / 100) * metrics.decisionsMade) + (data.success ? 1 : 0);\n    const newSuccessRate = (successCount / totalDecisions) * 100;\n    const newErrorRate = 100 - newSuccessRate;\n\n    await db\n      .update(agents)\n      .set({\n        metrics: {\n          decisionsMade: totalDecisions,\n          actionsExecuted: metrics.actionsExecuted,\n          successRate: newSuccessRate,\n          responseTimeMs: Math.floor((metrics.responseTimeMs + data.responseTimeMs) / 2),\n          errorRate: newErrorRate,\n          lastActivity: new Date().toISOString(),\n        },\n        updatedAt: new Date(),\n      })\n      .where(eq(agents.id, agentId));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/services/mastra-agent.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'agentId' is defined but never used. Allowed unused args must match /^_/u.","line":31,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Mastra Agent Service\n * Autonomous and proactive agent implementation using Mastra.ai with Memory\n */\n\nimport { Agent, createTool } from '@mastra/core';\nimport { Memory } from '@mastra/memory';\nimport { createOpenAI } from '@ai-sdk/openai';\nimport { z } from 'zod';\nimport { AgentService } from './agent.service';\nimport { db } from '@/db';\nimport { eq, and, sql, desc, gte } from 'drizzle-orm';\nimport logger from '@/utils/logger';\nimport type { AgentType } from '../types/agents.types';\nimport { agents, agentActions } from '../schema/agents.schema';\n\n/**\n * Agent Tool Context\n * Context passed to all agent tools\n */\ninterface AgentToolContext {\n  agentId: string;\n  tenantId: string;\n  agentType: AgentType;\n}\n\n/**\n * Create Memory Store for Agent\n * Allows agent to remember past interactions and learn\n */\nconst createAgentMemory = (agentId: string) => {\n  return new Memory();\n};\n\n/**\n * Create Database Query Tool\n * Allows agent to query the database autonomously\n */\nconst createDatabaseQueryTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'database_query',\n    description: 'Execute SQL queries to fetch data from the database. Use this to analyze trends, metrics, and make data-driven decisions.',\n    inputSchema: z.object({\n      query: z.string().describe('SQL query to execute (SELECT only, no mutations)'),\n      purpose: z.string().describe('Why this query is needed (for logging)'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { query, purpose } = toolContext;\n\n      try {\n        // Validate query is SELECT only\n        const trimmedQuery = query.trim().toLowerCase();\n        if (!trimmedQuery.startsWith('select')) {\n          throw new Error('Only SELECT queries are allowed for safety');\n        }\n\n        logger.info('Agent executing database query', {\n          agentId: context.agentId,\n          agentType: context.agentType,\n          purpose,\n          query,\n        });\n\n        // Execute query\n        const result = await db.execute(sql.raw(query));\n\n        // Log action\n        await db.insert(agentActions).values({\n          agentId: context.agentId,\n          tenantId: context.tenantId,\n          actionType: 'database_query',\n          actionName: 'Database Query',\n          description: purpose,\n          input: { query },\n          output: { rowCount: result.rows.length },\n          status: 'completed',\n          executionTimeMs: 0,\n        });\n\n        return {\n          success: true,\n          data: result.rows,\n          rowCount: result.rows.length,\n        };\n      } catch (error) {\n        logger.error('Database query failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Query execution failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Create Send Notification Tool\n * Allows agent to send notifications autonomously\n */\nconst createSendNotificationTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'send_notification',\n    description: 'Send notifications to users, managers, or other agents. Use this to alert about important events, anomalies, or required actions.',\n    inputSchema: z.object({\n      to: z.string().describe('Recipient (user ID, agent ID, or \"ceo\")'),\n      subject: z.string().describe('Notification subject'),\n      message: z.string().describe('Notification message'),\n      priority: z.enum(['low', 'normal', 'high', 'urgent']).default('normal').describe('Notification priority'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { to, subject, message, priority } = toolContext;\n\n      try {\n        logger.info('Agent sending notification', {\n          agentId: context.agentId,\n          agentType: context.agentType,\n          to,\n          subject,\n          priority,\n        });\n\n        // Log action\n        await db.insert(agentActions).values({\n          agentId: context.agentId,\n          tenantId: context.tenantId,\n          actionType: 'notification',\n          actionName: 'Send Notification',\n          description: subject,\n          input: { to, subject, message, priority },\n          output: { sent: true },\n          status: 'completed',\n          executionTimeMs: 0,\n        });\n\n        // Integrate with actual notification system\n        const { sendNotification: sendNotificationService } = await import(\n          '../../notifications/services/notification.service'\n        );\n\n        // Determine notification type based on recipient\n        const notificationType = to === 'ceo' || to.startsWith('agent-') ? 'in_app' : 'in_app';\n\n        // Send actual notification\n        await sendNotificationService({\n          userId: to === 'ceo' ? 'system' : to,\n          tenantId: context.tenantId,\n          type: notificationType,\n          category: 'system',\n          priority: priority as any,\n          subject,\n          content: message,\n          metadata: {\n            fromAgentId: context.agentId,\n            agentType: context.agentType,\n          },\n        });\n\n        logger.info('Notification sent successfully via notification service', {\n          to,\n          subject,\n          priority,\n          type: notificationType,\n        });\n\n        return {\n          success: true,\n          message: 'Notification sent successfully',\n          to,\n          subject,\n        };\n      } catch (error) {\n        logger.error('Send notification failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Notification failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Create Execute Action Tool\n * Allows agent to trigger specific actions in the system\n */\nconst createExecuteActionTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'execute_action',\n    description: 'Execute specific actions in the system like creating tasks, updating configurations, or triggering workflows.',\n    inputSchema: z.object({\n      actionType: z.string().describe('Type of action (e.g., \"create_task\", \"update_config\", \"trigger_workflow\")'),\n      actionName: z.string().describe('Human-readable action name'),\n      parameters: z.record(z.string(), z.any()).optional().describe('Action parameters'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { actionType, actionName, parameters = {} } = toolContext;\n\n      try {\n        logger.info('Agent executing action', {\n          agentId: context.agentId,\n          agentType: context.agentType,\n          actionType,\n          actionName,\n        });\n\n        // Log action\n        const [action] = await db\n          .insert(agentActions)\n          .values({\n            agentId: context.agentId,\n            tenantId: context.tenantId,\n            actionType,\n            actionName,\n            input: parameters,\n            status: 'completed',\n            executionTimeMs: 0,\n          })\n          .returning();\n\n        // Implement actual action execution based on actionType\n        let actionResult: any = {};\n\n        switch (actionType) {\n          case 'create_task':\n            // Create a task/communication for a user\n            if (parameters.userId) {\n              const communication = await AgentService.sendCommunication(context.tenantId, {\n                fromAgentId: context.agentId,\n                toAgentId: parameters.userId,\n                message: parameters.message || 'New task created by agent',\n                priority: parameters.priority || 'normal',\n              });\n              actionResult = { communicationId: communication.id, created: true };\n            }\n            break;\n\n          case 'update_config':\n            // Update agent configuration\n            if (parameters.configKey && parameters.configValue !== undefined) {\n              const [agent] = await db\n                .select()\n                .from(agents)\n                .where(eq(agents.id, context.agentId))\n                .limit(1);\n\n              const updatedConfig = { ...agent.config, [parameters.configKey]: parameters.configValue };\n\n              await db\n                .update(agents)\n                .set({ config: updatedConfig, updatedAt: new Date() })\n                .where(eq(agents.id, context.agentId));\n\n              actionResult = { configKey: parameters.configKey, updated: true };\n            }\n            break;\n\n          case 'trigger_workflow':\n            // Trigger a workflow or automated process\n            actionResult = {\n              workflowId: parameters.workflowId,\n              triggered: true,\n              timestamp: new Date(),\n            };\n            logger.info('Workflow triggered', {\n              workflowId: parameters.workflowId,\n              agentId: context.agentId,\n            });\n            break;\n\n          case 'schedule_report':\n            // Schedule a report generation\n            actionResult = {\n              reportType: parameters.reportType,\n              scheduled: true,\n              scheduledFor: parameters.scheduledTime || new Date(),\n            };\n            logger.info('Report scheduled', {\n              reportType: parameters.reportType,\n              agentId: context.agentId,\n            });\n            break;\n\n          default:\n            logger.warn('Unknown action type', { actionType });\n            actionResult = { message: 'Action type not implemented', actionType };\n        }\n\n        // Update action with result\n        await db\n          .update(agentActions)\n          .set({ output: actionResult })\n          .where(eq(agentActions.id, action.id));\n\n        logger.info('Action executed successfully', {\n          actionId: action.id,\n          actionType,\n          result: actionResult,\n        });\n\n        return {\n          success: true,\n          actionId: action.id,\n          actionType,\n          actionName,\n        };\n      } catch (error) {\n        logger.error('Execute action failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Action execution failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Create Analyze Metrics Tool\n * Allows agent to analyze system metrics and identify trends\n */\nconst createAnalyzeMetricsTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'analyze_metrics',\n    description: 'Analyze system metrics, identify trends, anomalies, and generate insights.',\n    inputSchema: z.object({\n      metricType: z.string().describe('Type of metric to analyze (e.g., \"revenue\", \"orders\", \"users\")'),\n      timeRange: z.enum(['1h', '24h', '7d', '30d']).describe('Time range for analysis'),\n      threshold: z.number().optional().describe('Threshold for anomaly detection (optional)'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { metricType, timeRange, threshold } = toolContext;\n\n      try {\n        logger.info('Agent analyzing metrics', {\n          agentId: context.agentId,\n          agentType: context.agentType,\n          metricType,\n          timeRange,\n        });\n\n        // Log action\n        await db.insert(agentActions).values({\n          agentId: context.agentId,\n          tenantId: context.tenantId,\n          actionType: 'analysis',\n          actionName: 'Analyze Metrics',\n          description: `Analyzing ${metricType} for ${timeRange}`,\n          input: { metricType, timeRange, threshold },\n          status: 'completed',\n          executionTimeMs: 0,\n        });\n\n        // Implement actual metrics analysis\n        let analysis: any = {\n          metricType,\n          timeRange,\n          timestamp: new Date(),\n        };\n\n        // Calculate time range boundaries\n        const now = new Date();\n        const timeRangeHours: Record<string, number> = {\n          '1h': 1,\n          '24h': 24,\n          '7d': 168,\n          '30d': 720,\n        };\n        const hoursAgo = timeRangeHours[timeRange] || 24;\n        const startTime = new Date(now.getTime() - hoursAgo * 60 * 60 * 1000);\n\n        try {\n          switch (metricType) {\n            case 'system_health': {\n              // Analyze agent actions in time range\n              const recentActions = await db\n                .select()\n                .from(agentActions)\n                .where(\n                  and(\n                    eq(agentActions.tenantId, context.tenantId),\n                    gte(agentActions.createdAt, startTime)\n                  )\n                )\n                .execute();\n\n              const totalActions = recentActions.length;\n              const completedActions = recentActions.filter((a) => a.status === 'completed').length;\n              const failedActions = recentActions.filter((a) => a.status === 'failed').length;\n              const successRate = totalActions > 0 ? (completedActions / totalActions) * 100 : 100;\n\n              analysis = {\n                ...analysis,\n                totalActions,\n                completedActions,\n                failedActions,\n                successRate: successRate.toFixed(2),\n                trend: successRate > 95 ? 'healthy' : successRate > 80 ? 'warning' : 'critical',\n                anomalies: failedActions > totalActions * 0.1 ? ['High failure rate detected'] : [],\n                recommendation:\n                  successRate > 95\n                    ? 'System is healthy'\n                    : successRate > 80\n                      ? 'Monitor closely, success rate below optimal'\n                      : 'Immediate attention required - high failure rate',\n              };\n              break;\n            }\n\n            case 'agent_performance': {\n              // Analyze specific agent's performance\n              const performanceActions = await db\n                .select()\n                .from(agentActions)\n                .where(\n                  and(\n                    eq(agentActions.agentId, context.agentId),\n                    gte(agentActions.createdAt, startTime)\n                  )\n                )\n                .execute();\n\n              const avgExecutionTime =\n                performanceActions.length > 0\n                  ? performanceActions.reduce((sum: number, a) => sum + (a.executionTimeMs || 0), 0) /\n                    performanceActions.length\n                  : 0;\n\n              const actionsByType = performanceActions.reduce(\n                (acc: Record<string, number>, a) => {\n                  acc[a.actionType] = (acc[a.actionType] || 0) + 1;\n                  return acc;\n                },\n                {} as Record<string, number>\n              );\n\n              analysis = {\n                ...analysis,\n                totalActions: performanceActions.length,\n                averageExecutionTimeMs: avgExecutionTime.toFixed(2),\n                actionsByType,\n                trend:\n                  avgExecutionTime < 1000\n                    ? 'fast'\n                    : avgExecutionTime < 3000\n                      ? 'normal'\n                      : 'slow',\n                anomalies:\n                  avgExecutionTime > 5000\n                    ? ['Execution time above 5 seconds']\n                    : [],\n                recommendation:\n                  avgExecutionTime < 1000\n                    ? 'Performance is excellent'\n                    : avgExecutionTime < 3000\n                      ? 'Performance is acceptable'\n                      : 'Consider optimization - slow execution detected',\n              };\n              break;\n            }\n\n            case 'communications': {\n              // Analyze agent communications\n              const communications = await db\n                .select()\n                .from(agentActions)\n                .where(\n                  and(\n                    eq(agentActions.tenantId, context.tenantId),\n                    eq(agentActions.actionType, 'notification'),\n                    gte(agentActions.createdAt, startTime)\n                  )\n                )\n                .execute();\n\n              analysis = {\n                ...analysis,\n                totalCommunications: communications.length,\n                trend: communications.length > 10 ? 'high' : communications.length > 5 ? 'normal' : 'low',\n                anomalies: communications.length > 50 ? ['Unusually high communication volume'] : [],\n                recommendation:\n                  communications.length > 50\n                    ? 'Review communication patterns - volume is high'\n                    : 'Communication volume is normal',\n              };\n              break;\n            }\n\n            default: {\n              // Generic fallback analysis\n              analysis = {\n                ...analysis,\n                trend: 'stable',\n                anomalies: [],\n                recommendation: `Metrics analysis for '${metricType}' not yet implemented`,\n                note: 'Consider implementing specific metrics for this type',\n              };\n            }\n          }\n        } catch (error) {\n          logger.error('Metrics analysis query failed', {\n            metricType,\n            error: error instanceof Error ? error.message : String(error),\n          });\n          analysis.error = 'Failed to analyze metrics';\n          analysis.trend = 'unknown';\n          analysis.anomalies = [];\n          analysis.recommendation = 'Unable to complete analysis due to error';\n        }\n\n        return {\n          success: true,\n          analysis,\n        };\n      } catch (error) {\n        logger.error('Metrics analysis failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Analysis failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Create Report to Manager Tool\n * Allows agent to report findings/decisions to their manager (usually CEO)\n */\nconst createReportToManagerTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'report_to_manager',\n    description: 'Report important findings, decisions, or recommendations to your manager (CEO Agent). Use this for escalations and strategic updates.',\n    inputSchema: z.object({\n      subject: z.string().describe('Report subject'),\n      summary: z.string().describe('Executive summary'),\n      details: z.record(z.string(), z.any()).optional().describe('Detailed findings'),\n      requiresApproval: z.boolean().default(false).describe('Whether this requires CEO approval'),\n      urgency: z.enum(['low', 'normal', 'high', 'urgent']).default('normal').describe('Report urgency'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { subject, summary, details = {}, requiresApproval, urgency } = toolContext;\n\n      try {\n        // Get agent's manager\n        const [agent] = await db\n          .select()\n          .from(agents)\n          .where(eq(agents.id, context.agentId))\n          .limit(1);\n\n        if (!agent.managerId) {\n          throw new Error('Agent has no manager assigned');\n        }\n\n        logger.info('Agent reporting to manager', {\n          agentId: context.agentId,\n          managerId: agent.managerId,\n          subject,\n          requiresApproval,\n        });\n\n        // Send communication to manager\n        const communication = await AgentService.sendCommunication(context.tenantId, {\n          fromAgentId: context.agentId,\n          toAgentId: agent.managerId,\n          message: `**${subject}**\\n\\n${summary}\\n\\nDetails: ${JSON.stringify(details)}\\n\\nRequires Approval: ${requiresApproval ? 'Yes' : 'No'}`,\n          priority: urgency as any,\n        });\n\n        // Log action\n        await db.insert(agentActions).values({\n          agentId: context.agentId,\n          tenantId: context.tenantId,\n          actionType: 'report',\n          actionName: 'Report to Manager',\n          description: subject,\n          input: { subject, summary, details, requiresApproval, urgency },\n          output: { communicationId: communication.id },\n          status: 'completed',\n          executionTimeMs: 0,\n        });\n\n        return {\n          success: true,\n          communicationId: communication.id,\n          sentTo: agent.managerId,\n          requiresApproval,\n        };\n      } catch (error) {\n        logger.error('Report to manager failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Report failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Create Memory Retrieval Tool\n * Allows agent to search and retrieve past memories\n */\nconst createMemoryRetrievalTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'memory_retrieval',\n    description: 'Search and retrieve past memories, learnings, and experiences. Use this to recall similar situations, past decisions, and learned patterns.',\n    inputSchema: z.object({\n      query: z.string().describe('What to search for in memory'),\n      limit: z.number().default(5).describe('Maximum number of memories to retrieve'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { query, limit } = toolContext;\n\n      try {\n        logger.info('Agent retrieving memories', {\n          agentId: context.agentId,\n          query,\n          limit,\n        });\n\n        // Query from database actions table (stored memories)\n        const memories = await db\n          .select()\n          .from(agentActions)\n          .where(\n            and(\n              eq(agentActions.agentId, context.agentId),\n              eq(agentActions.tenantId, context.tenantId),\n              eq(agentActions.actionType, 'memory_storage')\n            )\n          )\n          .orderBy(desc(agentActions.createdAt))\n          .limit(limit)\n          .execute();\n\n        // Log action\n        await db.insert(agentActions).values({\n          agentId: context.agentId,\n          tenantId: context.tenantId,\n          actionType: 'memory_retrieval',\n          actionName: 'Memory Retrieval',\n          description: `Retrieving memories about: ${query}`,\n          input: { query, limit },\n          output: { memoriesFound: memories.length },\n          status: 'completed',\n          executionTimeMs: 0,\n        });\n\n        return {\n          success: true,\n          memories: memories.map((m) => m.input),\n          count: memories.length,\n        };\n      } catch (error) {\n        logger.error('Memory retrieval failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Memory retrieval failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Create Memory Storage Tool\n * Allows agent to store new learnings and experiences\n */\nconst createMemoryStorageTool = (context: AgentToolContext) => {\n  return createTool({\n    id: 'memory_storage',\n    description: 'Store new learnings, experiences, and insights into memory for future reference. Use this to remember important patterns, decisions, and outcomes.',\n    inputSchema: z.object({\n      content: z.string().describe('What to remember'),\n      category: z.enum(['decision', 'pattern', 'insight', 'outcome', 'error', 'success']).describe('Category of memory'),\n      importance: z.enum(['low', 'medium', 'high', 'critical']).default('medium').describe('Importance level'),\n      metadata: z.record(z.string(), z.any()).optional().describe('Additional context'),\n    }),\n    execute: async ({ context: toolContext }) => {\n      const { content, category, importance, metadata = {} } = toolContext;\n\n      try {\n        logger.info('Agent storing memory', {\n          agentId: context.agentId,\n          category,\n          importance,\n        });\n\n        // Store in database as action\n        await db.insert(agentActions).values({\n          agentId: context.agentId,\n          tenantId: context.tenantId,\n          actionType: 'memory_storage',\n          actionName: 'Memory Storage',\n          description: `Storing ${category} memory`,\n          input: { content, category, importance, metadata },\n          output: { stored: true },\n          status: 'completed',\n          executionTimeMs: 0,\n        });\n\n        return {\n          success: true,\n          message: 'Memory stored successfully',\n          category,\n          importance,\n        };\n      } catch (error) {\n        logger.error('Memory storage failed', {\n          agentId: context.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Memory storage failed',\n        };\n      }\n    },\n  });\n};\n\n/**\n * Mastra Agent Wrapper\n * Wraps our agents with Mastra.ai capabilities for autonomy and memory\n */\nexport class MastraAgentService {\n  /**\n   * Create Mastra Agent Instance with Memory\n   */\n  static async createMastraAgent(agentId: string, tenantId: string): Promise<Agent> {\n    // Get agent from database\n    const [agentData] = await db\n      .select()\n      .from(agents)\n      .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n      .limit(1);\n\n    if (!agentData) {\n      throw new Error('Agent not found');\n    }\n\n    const context: AgentToolContext = {\n      agentId,\n      tenantId,\n      agentType: agentData.agentType as AgentType,\n    };\n\n    // Create memory for this agent\n    const memory = createAgentMemory(agentId);\n\n    // Create Ollama provider using OpenAI-compatible API\n    const ollama = createOpenAI({\n      baseURL: 'http://localhost:11434/v1',\n      apiKey: 'ollama', // Ollama doesn't need a real API key\n    });\n\n    // Create model instance using chat format\n    const model = ollama.chat(agentData.config.model);\n\n    // Create Mastra Agent with tools and memory\n    const mastraAgent = new Agent({\n      name: agentData.name,\n      instructions: `${agentData.config.systemPrompt}\\n\\nYou have access to memory capabilities. Use memory_retrieval to recall past experiences and memory_storage to remember important learnings.`,\n      model,\n      memory,\n      tools: {\n        databaseQuery: createDatabaseQueryTool(context),\n        sendNotification: createSendNotificationTool(context),\n        executeAction: createExecuteActionTool(context),\n        analyzeMetrics: createAnalyzeMetricsTool(context),\n        reportToManager: createReportToManagerTool(context),\n        memoryRetrieval: createMemoryRetrievalTool(context),\n        memoryStorage: createMemoryStorageTool(context),\n      },\n    });\n\n    logger.info('Mastra agent created with memory', {\n      agentId,\n      agentType: agentData.agentType,\n      toolsCount: 7,\n      memoryEnabled: true,\n    });\n\n    return mastraAgent;\n  }\n\n  /**\n   * Execute Autonomous Task with Memory\n   * Agent autonomously decides which tools to use based on the task\n   */\n  static async executeAutonomousTask(agentId: string, tenantId: string, task: string): Promise<any> {\n    const startTime = Date.now();\n\n    try {\n      logger.info('Starting autonomous task execution with memory', {\n        agentId,\n        task,\n      });\n\n      // Create Mastra agent with memory\n      const mastraAgent = await this.createMastraAgent(agentId, tenantId);\n\n      // Execute task - agent will autonomously decide which tools to use\n      const result = await mastraAgent.generate(task);\n\n      const executionTime = Date.now() - startTime;\n\n      logger.info('Autonomous task completed', {\n        agentId,\n        task,\n        executionTimeMs: executionTime,\n      });\n\n      return {\n        success: true,\n        result: result.text,\n        toolCalls: result.toolCalls || [],\n        executionTimeMs: executionTime,\n      };\n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n\n      logger.error('Autonomous task failed', {\n        agentId,\n        task,\n        error: error instanceof Error ? error.message : String(error),\n        executionTimeMs: executionTime,\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Run Proactive Monitoring with Learning\n   * Agent proactively monitors metrics and learns from patterns\n   */\n  static async runProactiveMonitoring(agentId: string, tenantId: string): Promise<void> {\n    try {\n      logger.info('Starting proactive monitoring with learning', { agentId });\n\n      const [agentData] = await db\n        .select()\n        .from(agents)\n        .where(and(eq(agents.id, agentId), eq(agents.tenantId, tenantId)))\n        .limit(1);\n\n      if (!agentData || !agentData.isEnabled) {\n        return;\n      }\n\n      // Create monitoring task based on agent type\n      const monitoringTasks: Record<string, string> = {\n        financial: 'Analyze financial metrics for the last 24 hours. Check for anomalies in revenue, expenses, or payment processing. Search your memory for similar patterns. Alert if any issues are detected. Remember important findings.',\n        security: 'Monitor security logs and authentication attempts. Check for suspicious activity, failed login attempts, or potential threats. Recall past security incidents from memory. Alert immediately if critical issues are found. Store new threat patterns.',\n        trading_ops: 'Monitor trading system health: check order execution rates, exchange connectivity, position risks. Retrieve similar past situations from memory. Alert on any system degradation or high-risk situations. Learn from current market conditions.',\n        support: 'Check customer support metrics: ticket response times, SLA compliance, customer satisfaction. Remember past issues and their solutions. Alert if SLA is at risk or satisfaction drops. Store successful resolution patterns.',\n        operations: 'Monitor system performance: CPU, memory, disk usage, API response times. Recall past performance issues from memory. Alert if any resource is above 80% utilization. Learn optimization patterns.',\n        marketing: 'Analyze marketing campaign performance. Check conversion rates, engagement metrics. Retrieve past successful campaigns from memory. Recommend optimizations if performance is below target. Remember what works.',\n        sales: 'Monitor sales pipeline health: deal velocity, conversion rates, lead quality. Search memory for similar deal patterns. Alert if pipeline is below target or deals are stalling. Store successful sales strategies.',\n        ceo: 'Review overall company metrics from all departments. Recall past strategic decisions and their outcomes. Identify trends, risks, and opportunities. Generate executive summary. Remember key insights.',\n        documents: 'Check document storage capacity and access patterns. Retrieve past storage issues from memory. Alert if storage is above 80% or unusual access patterns are detected. Learn document usage patterns.',\n      };\n\n      const task = monitoringTasks[agentData.agentType] || 'Monitor assigned modules for any issues or anomalies. Use your memory to recall similar situations and learn from patterns.';\n\n      // Execute proactive monitoring with learning\n      await this.executeAutonomousTask(agentId, tenantId, task);\n\n      logger.info('Proactive monitoring with learning completed', {\n        agentId,\n        agentType: agentData.agentType,\n      });\n    } catch (error) {\n      logger.error('Proactive monitoring failed', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  /**\n   * Get Agent Memory Stats\n   * Retrieve statistics about agent's memory usage\n   */\n  static async getMemoryStats(agentId: string, tenantId: string): Promise<any> {\n    try {\n      // Query agent actions related to memory\n      const memoryActions = await db\n        .select()\n        .from(agentActions)\n        .where(\n          and(\n            eq(agentActions.agentId, agentId),\n            eq(agentActions.tenantId, tenantId),\n            sql`${agentActions.actionType} IN ('memory_storage', 'memory_retrieval')`\n          )\n        )\n        .orderBy(desc(agentActions.createdAt))\n        .limit(100);\n\n      const storageCount = memoryActions.filter((a) => a.actionType === 'memory_storage').length;\n      const retrievalCount = memoryActions.filter((a) => a.actionType === 'memory_retrieval').length;\n\n      return {\n        totalMemoryActions: memoryActions.length,\n        memoriesStored: storageCount,\n        memoriesRetrieved: retrievalCount,\n        lastMemoryAction: memoryActions[0]?.createdAt || null,\n        memoryCategories: memoryActions\n          .filter((a) => a.actionType === 'memory_storage')\n          .map((a) => (a.input as any)?.category)\n          .filter(Boolean),\n      };\n    } catch (error) {\n      logger.error('Failed to get memory stats', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      return {\n        totalMemoryActions: 0,\n        memoriesStored: 0,\n        memoriesRetrieved: 0,\n        error: error instanceof Error ? error.message : 'Failed to get memory stats',\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/services/ollama.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/agents/types/agents.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/middleware/audit.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/routes/audit.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/schema/audit.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/services/audit-logger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/services/compliance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/types/audit.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/utils/__tests__/sanitize.util.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/utils/intent.util.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/audit/utils/sanitize.util.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/middleware/guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/middleware/session.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/routes/auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/routes/dev.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/schema/auth.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/services/__tests__/two-factor.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'n' is defined but never used. Allowed unused args must match /^_/u.","line":8,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, test, expect, mock } from 'bun:test';\n\nlet enabled = true;\n\n// Mock '@/db' to control responses\nmock.module('@/db', () => {\n  const chain = {\n    limit: (n: number) => Promise.resolve(enabled ? [{ id: 'tf1' }] : []),\n  } as any;\n  const db = {\n    select: () => ({ from: () => ({ where: () => chain }) }),\n  } as any;\n  return { db };\n});\n\ndescribe('Auth two-factor service', () => {\n  test('isTwoFactorEnabled returns true when record exists', async () => {\n    enabled = true;\n    const { isTwoFactorEnabled } = await import('../two-factor.service');\n    const res = await isTwoFactorEnabled('user-1');\n    expect(res).toBe(true);\n  });\n\n  test('isTwoFactorEnabled returns false when no record', async () => {\n    enabled = false;\n    const { isTwoFactorEnabled } = await import('../two-factor.service');\n    const res = await isTwoFactorEnabled('user-1');\n    expect(res).toBe(false);\n  });\n});\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/services/auth.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/services/email.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/services/session.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/services/two-factor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/auth/types/auth.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/engine/backtest-engine.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BacktestState' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Backtest Engine Tests\n * Comprehensive test suite for backtesting engine\n */\n\nimport { describe, test, expect, beforeEach, mock } from 'bun:test';\nimport { BacktestEngine } from './backtest-engine';\nimport type { BacktestConfig, BacktestState } from './backtest-engine.types';\nimport type { TradingStrategy } from '../../strategies/types/strategies.types';\nimport type { MarketDataPoint } from '../../strategies/engine/strategy-runner.types';\n\n// Test data generators\nconst generateTrendingData = (\n  count: number,\n  trend: 'up' | 'down' | 'sideways' = 'up'\n): MarketDataPoint[] => {\n  const data: MarketDataPoint[] = [];\n  let price = 50000;\n\n  for (let i = 0; i < count; i++) {\n    let change = 0;\n    if (trend === 'up') {\n      change = Math.random() * 200 - 50; // Slight uptrend\n    } else if (trend === 'down') {\n      change = Math.random() * 200 - 150; // Slight downtrend\n    } else {\n      change = Math.random() * 100 - 50; // Sideways\n    }\n\n    price += change;\n\n    data.push({\n      timestamp: new Date(Date.now() - (count - i) * 3600000),\n      open: price - Math.random() * 50,\n      high: price + Math.random() * 100,\n      low: price - Math.random() * 100,\n      close: price,\n      volume: Math.random() * 1000000,\n    });\n  }\n\n  return data;\n};\n\nconst createTestStrategy = (overrides?: Partial<TradingStrategy>): TradingStrategy => ({\n  id: 'strategy-1',\n  userId: 'user-1',\n  tenantId: 'tenant-1',\n  name: 'Test Strategy',\n  description: 'Backtest strategy',\n  version: '1.0.0',\n  exchangeId: 'binance',\n  symbol: 'BTC/USDT',\n  timeframe: '1h',\n  type: 'trend_following',\n  indicators: [\n    {\n      type: 'rsi',\n      parameters: { period: 14 },\n      enabled: true,\n    },\n    {\n      type: 'sma',\n      parameters: { period: 20 },\n      enabled: true,\n    },\n  ],\n  conditions: [\n    {\n      type: 'entry',\n      logic: 'AND',\n      rules: [\n        { indicator: 'rsi', operator: '<', value: 40 },\n        { indicator: 'sma', operator: '>', value: 49000 },\n      ],\n    },\n  ],\n  stopLossPercent: 2,\n  takeProfitPercent: 5,\n  status: 'active',\n  isPublic: false,\n  totalTrades: 0,\n  winningTrades: 0,\n  losingTrades: 0,\n  totalPnl: 0,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  ...overrides,\n});\n\nconst createTestConfig = (overrides?: Partial<BacktestConfig>): BacktestConfig => ({\n  strategy: createTestStrategy(),\n  symbol: 'BTC/USDT',\n  timeframe: '1h',\n  startDate: new Date(Date.now() - 30 * 24 * 3600000), // 30 days ago\n  endDate: new Date(),\n  initialCapital: 10000,\n  positionSizePercent: 10,\n  commission: 0.1,\n  slippage: 0.05,\n  ...overrides,\n});\n\ndescribe('BacktestEngine - Basic Functionality', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n  let marketData: MarketDataPoint[];\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig();\n    marketData = generateTrendingData(200, 'up');\n  });\n\n  test('should initialize correctly', () => {\n    expect(engine).toBeDefined();\n    expect(engine).toBeInstanceOf(BacktestEngine);\n  });\n\n  test('should run backtest with provided data', async () => {\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result).toBeDefined();\n    expect(result.config).toEqual(config);\n    expect(result.metrics).toBeDefined();\n    expect(result.trades).toBeDefined();\n    expect(result.equityCurve).toBeDefined();\n  });\n\n  test('should process all data points', async () => {\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.dataPointsProcessed).toBe(marketData.length);\n  });\n\n  test('should initialize equity curve', async () => {\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.equityCurve.length).toBeGreaterThan(0);\n    expect(result.equityCurve[0].equity).toBe(config.initialCapital);\n  });\n});\n\ndescribe('BacktestEngine - Position Management', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig();\n  });\n\n  test('should open position when signal generated', async () => {\n    const marketData = generateTrendingData(150, 'down'); // Create oversold conditions\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.trades.length).toBeGreaterThanOrEqual(0);\n  });\n\n  test('should apply commission to trades', async () => {\n    const marketData = generateTrendingData(150, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.trades.length > 0) {\n      const trade = result.trades[0];\n      expect(trade.commission).toBeGreaterThan(0);\n    }\n  });\n\n  test('should apply slippage to entry price', async () => {\n    const marketData = generateTrendingData(150, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.trades.length > 0) {\n      const trade = result.trades[0];\n      expect(trade.entryPrice).toBeDefined();\n      expect(trade.entryPrice).toBeGreaterThan(0);\n    }\n  });\n\n  test('should calculate position size correctly', async () => {\n    const marketData = generateTrendingData(150, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.trades.length > 0) {\n      const trade = result.trades[0];\n      const positionValue = trade.entryPrice * trade.quantity;\n      const maxPositionSize = config.initialCapital * (config.positionSizePercent / 100);\n\n      expect(positionValue).toBeLessThanOrEqual(maxPositionSize * 1.1); // Allow for slippage\n    }\n  });\n\n  test('should not open position with insufficient capital', async () => {\n    const lowCapitalConfig = createTestConfig({ initialCapital: 100 });\n    const marketData = generateTrendingData(150);\n\n    const result = await engine.runWithData(lowCapitalConfig, marketData);\n\n    // Should have 0 or very few trades due to low capital\n    expect(result.trades.length).toBeLessThan(5);\n  });\n});\n\ndescribe('BacktestEngine - Stop Loss & Take Profit', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig({\n      strategy: createTestStrategy({\n        stopLossPercent: 5,\n        takeProfitPercent: 10,\n      }),\n    });\n  });\n\n  test('should set stop loss on position', async () => {\n    const marketData = generateTrendingData(150);\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.trades.length > 0) {\n      const trade = result.trades[0];\n      expect(trade.stopLoss).toBeDefined();\n      if (trade.stopLoss) {\n        expect(trade.stopLoss).toBeLessThan(trade.entryPrice);\n      }\n    }\n  });\n\n  test('should set take profit on position', async () => {\n    const marketData = generateTrendingData(150);\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.trades.length > 0) {\n      const trade = result.trades[0];\n      expect(trade.takeProfit).toBeDefined();\n      if (trade.takeProfit) {\n        expect(trade.takeProfit).toBeGreaterThan(trade.entryPrice);\n      }\n    }\n  });\n\n  test('should close position on stop loss hit', async () => {\n    // Create data that drops significantly\n    const marketData = generateTrendingData(150, 'down');\n    const result = await engine.runWithData(config, marketData);\n\n    const stopLossExits = result.trades.filter((t) => t.exitReason === 'stop_loss');\n    expect(stopLossExits.length).toBeGreaterThanOrEqual(0);\n  });\n\n  test('should close position on take profit hit', async () => {\n    // Create data that rises significantly\n    const marketData = generateTrendingData(150, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    const takeProfitExits = result.trades.filter((t) => t.exitReason === 'take_profit');\n    expect(takeProfitExits.length).toBeGreaterThanOrEqual(0);\n  });\n\n  test('should close remaining positions at end of backtest', async () => {\n    const marketData = generateTrendingData(150);\n    const result = await engine.runWithData(config, marketData);\n\n    const endOfBacktestExits = result.trades.filter((t) => t.exitReason === 'end_of_backtest');\n    expect(endOfBacktestExits.length).toBeGreaterThanOrEqual(0);\n  });\n});\n\ndescribe('BacktestEngine - Metrics Calculation', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig();\n  });\n\n  test('should calculate total trades', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.totalTrades).toBeGreaterThanOrEqual(0);\n    expect(result.metrics.totalTrades).toBe(result.trades.length);\n  });\n\n  test('should calculate win rate', async () => {\n    const marketData = generateTrendingData(200, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.winRate).toBeGreaterThanOrEqual(0);\n    expect(result.metrics.winRate).toBeLessThanOrEqual(100);\n\n    if (result.metrics.totalTrades > 0) {\n      const expectedWinRate =\n        (result.metrics.winningTrades / result.metrics.totalTrades) * 100;\n      expect(result.metrics.winRate).toBeCloseTo(expectedWinRate, 1);\n    }\n  });\n\n  test('should calculate profit factor', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.profitFactor).toBeGreaterThanOrEqual(0);\n\n    if (result.metrics.totalTrades > 0) {\n      // Profit factor = total wins / total losses\n      expect(typeof result.metrics.profitFactor).toBe('number');\n    }\n  });\n\n  test('should calculate total return', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.totalReturn).toBeDefined();\n    expect(result.metrics.totalReturnPercent).toBeDefined();\n\n    const expectedReturn = result.metrics.finalCapital - config.initialCapital;\n    expect(result.metrics.totalReturn).toBeCloseTo(expectedReturn, 2);\n  });\n\n  test('should calculate Sharpe ratio', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(typeof result.metrics.sharpeRatio).toBe('number');\n  });\n\n  test('should calculate Sortino ratio', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(typeof result.metrics.sortinoRatio).toBe('number');\n  });\n\n  test('should calculate max drawdown', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.maxDrawdown).toBeGreaterThanOrEqual(0);\n    expect(result.metrics.maxDrawdownPercent).toBeGreaterThanOrEqual(0);\n  });\n\n  test('should track consecutive wins and losses', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.maxConsecutiveWins).toBeGreaterThanOrEqual(0);\n    expect(result.metrics.maxConsecutiveLosses).toBeGreaterThanOrEqual(0);\n  });\n\n  test('should calculate average holding period', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.metrics.totalTrades > 0) {\n      expect(result.metrics.averageHoldingPeriod).toBeGreaterThan(0);\n    }\n  });\n\n  test('should calculate trades per day', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.averageTradesPerDay).toBeGreaterThanOrEqual(0);\n  });\n});\n\ndescribe('BacktestEngine - Analysis', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig();\n  });\n\n  test('should identify best trades', async () => {\n    const marketData = generateTrendingData(200, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.analysis.bestTrades).toBeDefined();\n    expect(Array.isArray(result.analysis.bestTrades)).toBe(true);\n    expect(result.analysis.bestTrades.length).toBeLessThanOrEqual(5);\n  });\n\n  test('should identify worst trades', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.analysis.worstTrades).toBeDefined();\n    expect(Array.isArray(result.analysis.worstTrades)).toBe(true);\n    expect(result.analysis.worstTrades.length).toBeLessThanOrEqual(5);\n  });\n\n  test('should generate recommendations', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.analysis.recommendations).toBeDefined();\n    expect(Array.isArray(result.analysis.recommendations)).toBe(true);\n  });\n\n  test('should generate warnings', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.analysis.warnings).toBeDefined();\n    expect(Array.isArray(result.analysis.warnings)).toBe(true);\n  });\n\n  test('should warn on low win rate', async () => {\n    const marketData = generateTrendingData(200, 'down');\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.metrics.winRate < 40) {\n      const hasWinRateWarning = result.analysis.warnings.some((w) =>\n        w.includes('Low win rate')\n      );\n      expect(hasWinRateWarning).toBe(true);\n    }\n  });\n\n  test('should warn on profit factor below 1', async () => {\n    const marketData = generateTrendingData(200, 'down');\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.metrics.profitFactor < 1) {\n      const hasProfitFactorWarning = result.analysis.warnings.some((w) =>\n        w.includes('Profit factor below 1')\n      );\n      expect(hasProfitFactorWarning).toBe(true);\n    }\n  });\n\n  test('should warn on high drawdown', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.metrics.maxDrawdownPercent > 20) {\n      const hasDrawdownWarning = result.analysis.warnings.some((w) =>\n        w.includes('High maximum drawdown')\n      );\n      expect(hasDrawdownWarning).toBe(true);\n    }\n  });\n\n  test('should recommend on good Sharpe ratio', async () => {\n    const marketData = generateTrendingData(200, 'up');\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.metrics.sharpeRatio > 1) {\n      const hasSharpeRecommendation = result.analysis.recommendations.some((r) =>\n        r.includes('Good Sharpe ratio')\n      );\n      expect(hasSharpeRecommendation).toBe(true);\n    }\n  });\n});\n\ndescribe('BacktestEngine - Equity Curve', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig();\n  });\n\n  test('should build equity curve', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.equityCurve.length).toBeGreaterThan(0);\n    expect(result.equityCurve.length).toBeLessThanOrEqual(marketData.length + 1);\n  });\n\n  test('should track drawdown in equity curve', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    result.equityCurve.forEach((point) => {\n      expect(point.drawdown).toBeGreaterThanOrEqual(0);\n      expect(point.drawdownPercent).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  test('should have final equity equal to final capital', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    const finalEquity = result.equityCurve[result.equityCurve.length - 1].equity;\n    expect(finalEquity).toBeCloseTo(result.metrics.finalCapital, 2);\n  });\n});\n\ndescribe('BacktestEngine - Edge Cases', () => {\n  let engine: BacktestEngine;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n  });\n\n  test('should handle empty market data', async () => {\n    const config = createTestConfig();\n    const emptyData: MarketDataPoint[] = [];\n\n    const result = await engine.runWithData(config, emptyData);\n\n    expect(result.metrics.totalTrades).toBe(0);\n    expect(result.metrics.finalCapital).toBe(config.initialCapital);\n  });\n\n  test('should handle strategy with no indicators', async () => {\n    const strategyNoIndicators = createTestStrategy({ indicators: [] });\n    const config = createTestConfig({ strategy: strategyNoIndicators });\n    const marketData = generateTrendingData(150);\n\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.totalTrades).toBe(0);\n  });\n\n  test('should handle strategy with no conditions', async () => {\n    const strategyNoConditions = createTestStrategy({ conditions: [] });\n    const config = createTestConfig({ strategy: strategyNoConditions });\n    const marketData = generateTrendingData(150);\n\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.totalTrades).toBe(0);\n  });\n\n  test('should handle low sample size warning', async () => {\n    const marketData = generateTrendingData(120);\n    const config = createTestConfig();\n\n    const result = await engine.runWithData(config, marketData);\n\n    if (result.metrics.totalTrades < 30) {\n      const hasLowSampleWarning = result.analysis.warnings.some((w) =>\n        w.includes('Low sample size')\n      );\n      expect(hasLowSampleWarning).toBe(true);\n    }\n  });\n});\n\ndescribe('BacktestEngine - Timeframe Parsing', () => {\n  let engine: BacktestEngine;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n  });\n\n  test('should parse minute timeframes', () => {\n    const ms = (engine as any).parseTimeframe('5m');\n    expect(ms).toBe(5 * 60 * 1000);\n  });\n\n  test('should parse hour timeframes', () => {\n    const ms = (engine as any).parseTimeframe('4h');\n    expect(ms).toBe(4 * 60 * 60 * 1000);\n  });\n\n  test('should parse day timeframes', () => {\n    const ms = (engine as any).parseTimeframe('1d');\n    expect(ms).toBe(24 * 60 * 60 * 1000);\n  });\n\n  test('should default to 1 minute for invalid timeframe', () => {\n    const ms = (engine as any).parseTimeframe('invalid');\n    expect(ms).toBe(60000);\n  });\n});\n\ndescribe('BacktestEngine - Long vs Short Positions', () => {\n  let engine: BacktestEngine;\n  let config: BacktestConfig;\n\n  beforeEach(() => {\n    engine = new BacktestEngine();\n    config = createTestConfig();\n  });\n\n  test('should track long and short trades separately', async () => {\n    const marketData = generateTrendingData(200);\n    const result = await engine.runWithData(config, marketData);\n\n    expect(result.metrics.longTrades).toBeGreaterThanOrEqual(0);\n    expect(result.metrics.shortTrades).toBeGreaterThanOrEqual(0);\n    expect(result.metrics.longTrades + result.metrics.shortTrades).toBe(\n      result.metrics.totalTrades\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/engine/backtest-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EquityCurvePoint' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DEFAULT_BACKTEST_CONFIG' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Backtest Engine\n * Simulates trading strategies against historical data\n */\n\nimport { randomUUID } from 'crypto';\nimport logger from '@/utils/logger';\nimport { strategyRunner } from '../../strategies/engine';\nimport { OHLCVService } from '../../market-data/services/ohlcv.service';\nimport type { MarketDataPoint } from '../../strategies/engine/strategy-runner.types';\nimport type {\n  IBacktestEngine,\n  BacktestConfig,\n  BacktestResult,\n  BacktestState,\n  BacktestMetrics,\n  VirtualTrade,\n  VirtualPosition,\n  ClosedPosition,\n  EquityCurvePoint,\n  TradeAnalysis,\n  DEFAULT_BACKTEST_CONFIG,\n} from './backtest-engine.types';\n\n/**\n * Backtest Engine Implementation\n */\nexport class BacktestEngine implements IBacktestEngine {\n  /**\n   * Run backtest by fetching market data\n   */\n  async run(config: BacktestConfig): Promise<BacktestResult> {\n    const startTime = Date.now();\n\n    try {\n      logger.info('Starting backtest', {\n        strategy: config.strategy.name,\n        symbol: config.symbol,\n        period: `${config.startDate.toISOString()} to ${config.endDate.toISOString()}`,\n      });\n\n      // Fetch historical market data\n      const marketData = await this.fetchMarketData(config);\n\n      if (marketData.length === 0) {\n        throw new Error('No market data available for backtest period');\n      }\n\n      // Run backtest with data\n      const result = await this.runWithData(config, marketData);\n\n      const executionTime = Date.now() - startTime;\n      logger.info('Backtest completed', {\n        strategy: config.strategy.name,\n        executionTime: `${executionTime}ms`,\n        totalTrades: result.metrics.totalTrades,\n        winRate: `${result.metrics.winRate.toFixed(2)}%`,\n        totalReturn: `${result.metrics.totalReturnPercent.toFixed(2)}%`,\n      });\n\n      return { ...result, executionTime };\n    } catch (error) {\n      logger.error('Backtest failed', {\n        strategy: config.strategy.name,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Run backtest with provided market data\n   */\n  async runWithData(config: BacktestConfig, marketData: MarketDataPoint[]): Promise<BacktestResult> {\n    // Handle empty market data\n    if (marketData.length === 0) {\n      const emptyState: BacktestState = {\n        currentCapital: config.initialCapital,\n        peakCapital: config.initialCapital,\n        positions: [],\n        closedPositions: [],\n        trades: [],\n        currentDrawdown: 0,\n        equityCurve: [],\n      };\n\n      const metrics = this.calculateMetrics(emptyState, config);\n      const analysis = this.analyzeResults({\n        config,\n        metrics,\n        trades: [],\n        equityCurve: [],\n        analysis: { bestTrades: [], worstTrades: [], recommendations: [], warnings: [] },\n        executionTime: 0,\n        dataPointsProcessed: 0,\n      });\n\n      return {\n        config,\n        metrics,\n        trades: [],\n        equityCurve: [],\n        analysis,\n        executionTime: 0,\n        dataPointsProcessed: 0,\n      };\n    }\n\n    // Initialize state\n    const state: BacktestState = {\n      currentCapital: config.initialCapital,\n      peakCapital: config.initialCapital,\n      positions: [],\n      closedPositions: [],\n      trades: [],\n      currentDrawdown: 0,\n      equityCurve: [\n        {\n          timestamp: marketData[0].timestamp,\n          equity: config.initialCapital,\n          drawdown: 0,\n          drawdownPercent: 0,\n        },\n      ],\n    };\n\n    // Process each candle\n    for (let i = 0; i < marketData.length; i++) {\n      const currentCandle = marketData[i];\n      const historicalData = marketData.slice(0, i + 1);\n\n      // Update open positions with current price\n      this.updatePositions(state, currentCandle.close);\n\n      // Check stop loss and take profit\n      this.checkExits(state, currentCandle);\n\n      // Only evaluate new signals if we have enough historical data\n      if (historicalData.length >= 100) {\n        // Evaluate strategy\n        const signal = await strategyRunner.evaluate(config.strategy, historicalData);\n\n        if (signal && signal.type !== 'HOLD') {\n          // Check if we can open a new position\n          if (state.positions.length === 0) {\n            // Open new position\n            await this.openPosition(state, config, signal, currentCandle);\n          } else if (signal.type === 'SELL' && state.positions.length > 0) {\n            // Close existing position on SELL signal\n            this.closePosition(\n              state,\n              state.positions[0],\n              currentCandle.close,\n              currentCandle.timestamp,\n              'signal'\n            );\n          }\n        }\n      }\n\n      // Update equity curve\n      this.updateEquityCurve(state, currentCandle.timestamp);\n    }\n\n    // Close any remaining positions at end of backtest\n    for (const position of [...state.positions]) {\n      this.closePosition(\n        state,\n        position,\n        marketData[marketData.length - 1].close,\n        marketData[marketData.length - 1].timestamp,\n        'end_of_backtest'\n      );\n    }\n\n    // Calculate final metrics\n    const metrics = this.calculateMetrics(state, config);\n\n    // Analyze results\n    const analysis = this.analyzeResults({\n      config,\n      metrics,\n      trades: state.closedPositions,\n      equityCurve: state.equityCurve,\n      analysis: { bestTrades: [], worstTrades: [], recommendations: [], warnings: [] },\n      executionTime: 0,\n      dataPointsProcessed: marketData.length,\n    });\n\n    return {\n      config,\n      metrics,\n      trades: state.closedPositions,\n      equityCurve: state.equityCurve,\n      analysis,\n      executionTime: 0, // Will be set by caller\n      dataPointsProcessed: marketData.length,\n    };\n  }\n\n  /**\n   * Open virtual position\n   */\n  private async openPosition(\n    state: BacktestState,\n    config: BacktestConfig,\n    signal: any,\n    candle: MarketDataPoint\n  ): Promise<void> {\n    const positionSize = state.currentCapital * (config.positionSizePercent / 100);\n    const commission = positionSize * (config.commission / 100);\n    const slippage = positionSize * (config.slippage / 100);\n    const totalCost = positionSize + commission + slippage;\n\n    if (totalCost > state.currentCapital) {\n      logger.warn('Insufficient capital for position', {\n        required: totalCost,\n        available: state.currentCapital,\n      });\n      return;\n    }\n\n    const entryPrice = candle.close * (1 + config.slippage / 100); // Apply slippage\n    const quantity = positionSize / entryPrice;\n\n    // Calculate stop loss and take profit (if configured in strategy)\n    const stopLoss = config.strategy.stopLossPercent\n      ? entryPrice * (1 - config.strategy.stopLossPercent / 100)\n      : undefined;\n\n    const takeProfit = config.strategy.takeProfitPercent\n      ? entryPrice * (1 + config.strategy.takeProfitPercent / 100)\n      : undefined;\n\n    const position: VirtualPosition = {\n      id: randomUUID(),\n      symbol: config.symbol,\n      side: signal.type === 'BUY' ? 'long' : 'short',\n      entryPrice,\n      entryTime: candle.timestamp,\n      quantity,\n      stopLoss,\n      takeProfit,\n      currentPrice: entryPrice,\n      unrealizedPnl: 0,\n      unrealizedPnlPercent: 0,\n    };\n\n    const trade: VirtualTrade = {\n      id: randomUUID(),\n      type: signal.type,\n      timestamp: candle.timestamp,\n      price: entryPrice,\n      quantity,\n      commission,\n      slippage,\n      signal: {\n        strength: signal.strength,\n        confidence: signal.confidence,\n        reasons: signal.reasons,\n      },\n    };\n\n    state.positions.push(position);\n    state.trades.push(trade);\n    state.currentCapital -= totalCost;\n\n    logger.debug('Position opened', {\n      side: position.side,\n      entryPrice,\n      quantity,\n      stopLoss,\n      takeProfit,\n    });\n  }\n\n  /**\n   * Close virtual position\n   */\n  private closePosition(\n    state: BacktestState,\n    position: VirtualPosition,\n    exitPrice: number,\n    exitTime: Date,\n    exitReason: ClosedPosition['exitReason']\n  ): void {\n    const exitPriceWithSlippage = exitPrice * 0.9995; // Small slippage on exit\n    const proceeds = position.quantity * exitPriceWithSlippage;\n    const commission = proceeds * 0.001; // 0.1% commission\n    const netProceeds = proceeds - commission;\n\n    const realizedPnl = netProceeds - position.quantity * position.entryPrice;\n    const realizedPnlPercent = (realizedPnl / (position.quantity * position.entryPrice)) * 100;\n    const holdingPeriod = exitTime.getTime() - position.entryTime.getTime();\n\n    const closedPosition: ClosedPosition = {\n      id: position.id,\n      symbol: position.symbol,\n      side: position.side,\n      entryPrice: position.entryPrice,\n      entryTime: position.entryTime,\n      quantity: position.quantity,\n      stopLoss: position.stopLoss,\n      takeProfit: position.takeProfit,\n      exitPrice: exitPriceWithSlippage,\n      exitTime,\n      exitReason,\n      realizedPnl,\n      realizedPnlPercent,\n      holdingPeriod,\n      commission,\n    };\n\n    state.closedPositions.push(closedPosition);\n    state.currentCapital += netProceeds;\n\n    // Update peak capital and drawdown\n    if (state.currentCapital > state.peakCapital) {\n      state.peakCapital = state.currentCapital;\n    }\n    state.currentDrawdown = state.peakCapital - state.currentCapital;\n\n    // Remove position from active positions\n    state.positions = state.positions.filter((p) => p.id !== position.id);\n\n    logger.debug('Position closed', {\n      exitReason,\n      exitPrice: exitPriceWithSlippage,\n      realizedPnl: realizedPnl.toFixed(2),\n      realizedPnlPercent: realizedPnlPercent.toFixed(2),\n    });\n  }\n\n  /**\n   * Update positions with current price\n   */\n  private updatePositions(state: BacktestState, currentPrice: number): void {\n    for (const position of state.positions) {\n      position.currentPrice = currentPrice;\n\n      if (position.side === 'long') {\n        position.unrealizedPnl = position.quantity * (currentPrice - position.entryPrice);\n      } else {\n        position.unrealizedPnl = position.quantity * (position.entryPrice - currentPrice);\n      }\n\n      position.unrealizedPnlPercent = (position.unrealizedPnl / (position.quantity * position.entryPrice)) * 100;\n    }\n  }\n\n  /**\n   * Check stop loss and take profit exits\n   */\n  private checkExits(state: BacktestState, candle: MarketDataPoint): void {\n    for (const position of [...state.positions]) {\n      // Check stop loss\n      if (position.stopLoss && candle.low <= position.stopLoss) {\n        this.closePosition(state, position, position.stopLoss, candle.timestamp, 'stop_loss');\n        continue;\n      }\n\n      // Check take profit\n      if (position.takeProfit && candle.high >= position.takeProfit) {\n        this.closePosition(state, position, position.takeProfit, candle.timestamp, 'take_profit');\n      }\n    }\n  }\n\n  /**\n   * Update equity curve\n   */\n  private updateEquityCurve(state: BacktestState, timestamp: Date): void {\n    const openPositionsValue = state.positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);\n    const equity = state.currentCapital + openPositionsValue;\n    const drawdown = state.peakCapital - equity;\n    const drawdownPercent = state.peakCapital > 0 ? (drawdown / state.peakCapital) * 100 : 0;\n\n    state.equityCurve.push({\n      timestamp,\n      equity,\n      drawdown,\n      drawdownPercent,\n    });\n  }\n\n  /**\n   * Calculate backtest metrics\n   */\n  calculateMetrics(state: BacktestState, config: BacktestConfig): BacktestMetrics {\n    const trades = state.closedPositions;\n    const winningTrades = trades.filter((t) => t.realizedPnl > 0);\n    const losingTrades = trades.filter((t) => t.realizedPnl < 0);\n\n    const totalReturn = state.currentCapital - config.initialCapital;\n    const totalReturnPercent = (totalReturn / config.initialCapital) * 100;\n\n    const averageReturn = trades.length > 0 ? totalReturn / trades.length : 0;\n    const averageReturnPercent = trades.length > 0 ? totalReturnPercent / trades.length : 0;\n\n    const totalWins = winningTrades.reduce((sum, t) => sum + t.realizedPnl, 0);\n    const totalLosses = Math.abs(losingTrades.reduce((sum, t) => sum + t.realizedPnl, 0));\n\n    const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;\n\n    // Calculate Sharpe Ratio (simplified)\n    const returns = trades.map((t) => t.realizedPnlPercent);\n    const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length || 0;\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length || 0;\n    const stdDev = Math.sqrt(variance);\n    const sharpeRatio = stdDev > 0 ? (avgReturn - 0) / stdDev : 0; // Assuming risk-free rate = 0\n\n    // Calculate Sortino Ratio (only downside deviation)\n    const downsideReturns = returns.filter((r) => r < 0);\n    const downsideVariance =\n      downsideReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / downsideReturns.length || 0;\n    const downsideDeviation = Math.sqrt(downsideVariance);\n    const sortinoRatio = downsideDeviation > 0 ? avgReturn / downsideDeviation : 0;\n\n    // Max drawdown\n    const maxDrawdown = Math.max(...state.equityCurve.map((e) => e.drawdown));\n    const maxDrawdownPercent = Math.max(...state.equityCurve.map((e) => e.drawdownPercent));\n\n    // Consecutive wins/losses\n    let consecutiveWins = 0;\n    let consecutiveLosses = 0;\n    let maxConsecutiveWins = 0;\n    let maxConsecutiveLosses = 0;\n\n    for (const trade of trades) {\n      if (trade.realizedPnl > 0) {\n        consecutiveWins++;\n        consecutiveLosses = 0;\n        maxConsecutiveWins = Math.max(maxConsecutiveWins, consecutiveWins);\n      } else {\n        consecutiveLosses++;\n        consecutiveWins = 0;\n        maxConsecutiveLosses = Math.max(maxConsecutiveLosses, consecutiveLosses);\n      }\n    }\n\n    // Time analysis\n    const holdingPeriods = trades.map((t) => t.holdingPeriod);\n    const averageHoldingPeriod =\n      holdingPeriods.reduce((sum, p) => sum + p, 0) / holdingPeriods.length || 0;\n\n    const totalBacktestPeriod =\n      config.endDate.getTime() - config.startDate.getTime();\n    const averageTimeBetweenTrades = trades.length > 1 ? totalBacktestPeriod / (trades.length - 1) : 0;\n\n    const daysInBacktest = totalBacktestPeriod / (1000 * 60 * 60 * 24);\n    const averageTradesPerDay = daysInBacktest > 0 ? trades.length / daysInBacktest : 0;\n\n    return {\n      totalTrades: trades.length,\n      winningTrades: winningTrades.length,\n      losingTrades: losingTrades.length,\n      winRate: trades.length > 0 ? (winningTrades.length / trades.length) * 100 : 0,\n      totalReturn,\n      totalReturnPercent,\n      averageReturn,\n      averageReturnPercent,\n      averageWin: winningTrades.length > 0 ? totalWins / winningTrades.length : 0,\n      averageLoss: losingTrades.length > 0 ? totalLosses / losingTrades.length : 0,\n      largestWin: Math.max(...winningTrades.map((t) => t.realizedPnl), 0),\n      largestLoss: Math.min(...losingTrades.map((t) => t.realizedPnl), 0),\n      profitFactor,\n      sharpeRatio,\n      sortinoRatio,\n      maxDrawdown,\n      maxDrawdownPercent,\n      maxConsecutiveWins,\n      maxConsecutiveLosses,\n      averageHoldingPeriod,\n      averageTimeBetweenTrades,\n      totalBacktestPeriod,\n      initialCapital: config.initialCapital,\n      finalCapital: state.currentCapital,\n      peakCapital: state.peakCapital,\n      longTrades: trades.filter((t) => t.side === 'long').length,\n      shortTrades: trades.filter((t) => t.side === 'short').length,\n      averageTradesPerDay,\n    };\n  }\n\n  /**\n   * Analyze backtest results\n   */\n  analyzeResults(result: BacktestResult): {\n    bestTrades: TradeAnalysis[];\n    worstTrades: TradeAnalysis[];\n    recommendations: string[];\n    warnings: string[];\n  } {\n    const bestTrades = result.trades\n      .filter((t) => t.realizedPnl > 0)\n      .sort((a, b) => b.realizedPnl - a.realizedPnl)\n      .slice(0, 5)\n      .map((trade) => this.analyzeTrade(trade));\n\n    const worstTrades = result.trades\n      .filter((t) => t.realizedPnl < 0)\n      .sort((a, b) => a.realizedPnl - b.realizedPnl)\n      .slice(0, 5)\n      .map((trade) => this.analyzeTrade(trade));\n\n    const recommendations: string[] = [];\n    const warnings: string[] = [];\n\n    // Generate recommendations based on metrics\n    if (result.metrics.winRate < 40) {\n      warnings.push(`Low win rate: ${result.metrics.winRate.toFixed(2)}%. Consider reviewing entry conditions.`);\n    }\n\n    if (result.metrics.profitFactor < 1) {\n      warnings.push(\n        `Profit factor below 1: ${result.metrics.profitFactor.toFixed(2)}. Strategy is losing money overall.`\n      );\n    } else if (result.metrics.profitFactor > 2) {\n      recommendations.push(\n        `Strong profit factor: ${result.metrics.profitFactor.toFixed(2)}. Strategy shows good potential.`\n      );\n    }\n\n    if (result.metrics.maxDrawdownPercent > 20) {\n      warnings.push(\n        `High maximum drawdown: ${result.metrics.maxDrawdownPercent.toFixed(2)}%. Consider implementing better risk management.`\n      );\n    }\n\n    if (result.metrics.sharpeRatio > 1) {\n      recommendations.push(\n        `Good Sharpe ratio: ${result.metrics.sharpeRatio.toFixed(2)}. Strategy has favorable risk-adjusted returns.`\n      );\n    } else if (result.metrics.sharpeRatio < 0.5) {\n      warnings.push(\n        `Low Sharpe ratio: ${result.metrics.sharpeRatio.toFixed(2)}. Risk-adjusted returns are poor.`\n      );\n    }\n\n    if (result.metrics.totalTrades < 30) {\n      warnings.push(\n        `Low sample size: Only ${result.metrics.totalTrades} trades. Results may not be statistically significant.`\n      );\n    }\n\n    if (result.metrics.maxConsecutiveLosses > 5) {\n      warnings.push(\n        `High consecutive losses: ${result.metrics.maxConsecutiveLosses}. Consider adding filters to avoid unfavorable conditions.`\n      );\n    }\n\n    if (result.metrics.averageWin > 0 && result.metrics.averageLoss > 0) {\n      const winLossRatio = result.metrics.averageWin / result.metrics.averageLoss;\n      if (winLossRatio < 1) {\n        recommendations.push(\n          `Average loss exceeds average win. Focus on improving exit strategy or reducing losses.`\n        );\n      } else if (winLossRatio > 2) {\n        recommendations.push(\n          `Strong win/loss ratio: ${winLossRatio.toFixed(2)}. Winning trades significantly outpace losing trades.`\n        );\n      }\n    }\n\n    return {\n      bestTrades,\n      worstTrades,\n      recommendations,\n      warnings,\n    };\n  }\n\n  /**\n   * Analyze individual trade\n   */\n  private analyzeTrade(trade: ClosedPosition): TradeAnalysis {\n    // Simplified analysis - in production would analyze market conditions\n    const priceChange = trade.exitPrice - trade.entryPrice;\n    const trend = priceChange > 0 ? 'bullish' : priceChange < 0 ? 'bearish' : 'sideways';\n    const volatility = Math.abs(trade.realizedPnlPercent); // Simplified\n\n    return {\n      trade,\n      marketCondition: {\n        trend,\n        volatility,\n      },\n      signalQuality: {\n        strength: 50, // Would come from stored signal data\n        confidence: 50, // Would come from stored signal data\n      },\n    };\n  }\n\n  /**\n   * Fetch market data for backtest period\n   */\n  private async fetchMarketData(config: BacktestConfig): Promise<MarketDataPoint[]> {\n    try {\n      // Calculate required candles based on timeframe\n      const timeframeMs = this.parseTimeframe(config.timeframe);\n      const periodMs = config.endDate.getTime() - config.startDate.getTime();\n      const limit = Math.ceil(periodMs / timeframeMs);\n\n      const ohlcvData = await OHLCVService.fetchOHLCV({\n        exchangeId: config.strategy.exchangeId,\n        symbol: config.symbol,\n        timeframe: config.timeframe as any, // Cast to match OHLCV service expectations\n        since: config.startDate,\n        limit: Math.min(limit, 1000), // Cap at 1000 candles per request\n      });\n\n      return ohlcvData.map((candle) => ({\n        timestamp: candle.timestamp,\n        open: candle.open,\n        high: candle.high,\n        low: candle.low,\n        close: candle.close,\n        volume: candle.volume,\n      }));\n    } catch (error) {\n      logger.error('Failed to fetch market data for backtest', {\n        symbol: config.symbol,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Parse timeframe string to milliseconds\n   */\n  private parseTimeframe(timeframe: string): number {\n    const match = timeframe.match(/^(\\d+)([mhd])$/);\n    if (!match) return 60000; // Default 1 minute\n\n    const value = parseInt(match[1]);\n    const unit = match[2];\n\n    switch (unit) {\n      case 'm':\n        return value * 60 * 1000;\n      case 'h':\n        return value * 60 * 60 * 1000;\n      case 'd':\n        return value * 24 * 60 * 60 * 1000;\n      default:\n        return 60000;\n    }\n  }\n}\n\n// Export singleton instance\nexport const backtestEngine = new BacktestEngine();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/engine/backtest-engine.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/engine/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/routes/backtest.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/schema/backtest.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/backtest/services/backtest.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/routes/portfolio.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/routes/wallet.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used. Allowed unused args must match /^_/u.","line":585,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":585,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Wallet Routes\n *\n * API endpoints for wallet operations\n */\n\nimport { Elysia, t } from 'elysia';\n// Move DB access into walletService (layering)\nimport { walletService } from '../services/wallet.service';\nimport { sessionGuard, requireTenant } from '../../auth/middleware/session.middleware';\nimport { requirePermission } from '../../security/middleware/rbac.middleware';\nimport logger from '@/utils/logger';\n\nexport const walletRoutes = new Elysia({ prefix: '/api/v1/wallets' })\n  .use(sessionGuard)\n  .use(requireTenant)\n\n  /**\n   * List wallets for current user\n   * GET /api/v1/wallets\n   */\n  .get(\n    '/',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ user, tenantId }) => {\n      logger.info('Listing wallets', { userId: user.id });\n      const rows = await walletService.listUserWallets(user.id, tenantId);\n      return { success: true, data: rows, count: rows.length };\n    },\n    {\n      detail: {\n        tags: ['Banco - Wallets'],\n        summary: 'List wallets',\n        description: 'List all wallets for the authenticated user',\n      },\n    }\n  )\n\n  /**\n   * Lock wallet (admin/manage)\n   * POST /api/v1/wallets/:id/lock\n   */\n  .post(\n    '/:id/lock',\n    { beforeHandle: [requirePermission('wallets', 'manage')] },\n    async ({ params, body, user, tenantId }) => {\n      const result = await walletService.setWalletLock(params.id, user.id, tenantId, true, body.reason);\n      return result;\n    },\n    {\n      params: t.Object({ id: t.String() }),\n      body: t.Object({ reason: t.Optional(t.String({ maxLength: 200 })) }),\n      detail: {\n        tags: ['Banco - Admin'],\n        summary: 'Lock wallet',\n        description: 'Lock a wallet from operations (admin only)',\n      },\n    }\n  )\n\n  /**\n   * Unlock wallet (admin/manage)\n   * POST /api/v1/wallets/:id/unlock\n   */\n  .post(\n    '/:id/unlock',\n    { beforeHandle: [requirePermission('wallets', 'manage')] },\n    async ({ params, user, tenantId }) => {\n      const result = await walletService.setWalletLock(params.id, user.id, tenantId, false);\n      return result;\n    },\n    {\n      params: t.Object({ id: t.String() }),\n      detail: {\n        tags: ['Banco - Admin'],\n        summary: 'Unlock wallet',\n        description: 'Unlock a wallet for normal operations (admin only)',\n      },\n    }\n  )\n\n  /**\n   * Export transactions as CSV\n   * GET /api/v1/wallets/:id/transactions/export?type=&status=&asset=&limit=&offset=\n   */\n  .get(\n    '/:id/transactions/export',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ params, query, user, set }) => {\n      const csv = await walletService.exportTransactionsCsv({\n        walletId: params.id,\n        userId: user.id,\n        type: query.type as any,\n        status: query.status as any,\n        asset: query.asset as any,\n        limit: query.limit ? parseInt(query.limit) : 500,\n        offset: query.offset ? parseInt(query.offset) : 0,\n      });\n      set.headers['Content-Type'] = 'text/csv; charset=utf-8';\n      return csv;\n    },\n    {\n      params: t.Object({ id: t.String() }),\n      query: t.Object({\n        type: t.Optional(t.String()),\n        status: t.Optional(t.String()),\n        asset: t.Optional(t.String()),\n        limit: t.Optional(t.String()),\n        offset: t.Optional(t.String()),\n      }),\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'Export wallet transactions to CSV',\n        description: 'Download a CSV export of wallet transactions with optional filters',\n      },\n    }\n  )\n\n  /**\n   * Create a new wallet\n   * POST /api/v1/wallets\n   */\n  .post(\n    '/',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ body, user, tenantId }) => {\n      logger.info('Creating wallet', { userId: user.id, type: body.type });\n\n      const result = await walletService.createWallet({\n        userId: user.id,\n        tenantId,\n        name: body.name,\n        type: body.type,\n        description: body.description,\n        metadata: body.metadata,\n      });\n\n      if (!result.success) {\n        return {\n          success: false,\n          error: result.error,\n        };\n      }\n\n      return {\n        success: true,\n        wallet: result.wallet,\n      };\n    },\n    {\n      body: t.Object({\n        name: t.String({ minLength: 1, maxLength: 100 }),\n        type: t.Union([\n          t.Literal('main'),\n          t.Literal('savings'),\n          t.Literal('trading'),\n          t.Literal('staking'),\n        ]),\n        description: t.Optional(t.String({ maxLength: 500 })),\n        metadata: t.Optional(\n          t.Object({\n            color: t.Optional(t.String()),\n            icon: t.Optional(t.String()),\n            displayOrder: t.Optional(t.Number()),\n          })\n        ),\n      }),\n      detail: {\n        tags: ['Banco - Wallets'],\n        summary: 'Create new wallet',\n        description: 'Create a new wallet for the authenticated user',\n      },\n    }\n  )\n\n  /**\n   * Get wallet summary\n   * GET /api/v1/wallets/:id\n   */\n  .get(\n    '/:id',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ params, user }) => {\n      logger.info('Getting wallet summary', { walletId: params.id, userId: user.id });\n\n      const summary = await walletService.getWalletSummary(params.id);\n\n      if (!summary) {\n        return {\n          success: false,\n          error: 'Wallet not found',\n        };\n      }\n\n      // Verify ownership\n      if (summary.wallet.userId !== user.id) {\n        return {\n          success: false,\n          error: 'Access denied',\n        };\n      }\n\n      return {\n        success: true,\n        summary,\n      };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      detail: {\n        tags: ['Banco - Wallets'],\n        summary: 'Get wallet summary',\n        description: 'Get complete summary of a wallet including all assets',\n      },\n    }\n  )\n\n  /**\n   * Get asset balance\n   * GET /api/v1/wallets/:id/assets/:asset\n   */\n  .get(\n    '/:id/assets/:asset',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ params, user }) => {\n      logger.info('Getting asset balance', {\n        walletId: params.id,\n        asset: params.asset,\n        userId: user.id,\n      });\n\n      const balance = await walletService.getAssetBalance(params.id, params.asset);\n\n      if (!balance) {\n        return {\n          success: false,\n          error: 'Asset not found in wallet',\n        };\n      }\n\n      return {\n        success: true,\n        balance,\n      };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n        asset: t.String(),\n      }),\n      detail: {\n        tags: ['Banco - Wallets'],\n        summary: 'Get asset balance',\n        description: 'Get balance of a specific asset in a wallet',\n      },\n    }\n  )\n\n  /**\n   * Process deposit\n   * POST /api/v1/wallets/:id/deposit\n   */\n  .post(\n    '/:id/deposit',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ params, body, user, tenantId }) => {\n      logger.info('Processing deposit', {\n        walletId: params.id,\n        asset: body.asset,\n        amount: body.amount,\n        userId: user.id,\n      });\n\n      const result = await walletService.processDeposit({\n        walletId: params.id,\n        userId: user.id,\n        tenantId,\n        asset: body.asset as any,\n        amount: body.amount,\n        fromAddress: body.fromAddress,\n        txHash: body.txHash,\n        network: body.network,\n        metadata: body.metadata,\n      });\n\n      return result;\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      body: t.Object({\n        asset: t.Union([\n          t.Literal('BTC'), t.Literal('ETH'), t.Literal('USDT'), t.Literal('USDC'), t.Literal('BNB'), t.Literal('SOL'), t.Literal('ADA'), t.Literal('DOT'), t.Literal('MATIC'), t.Literal('AVAX'), t.Literal('BRL'), t.Literal('USD'),\n        ]),\n        amount: t.Number({ minimum: 0.00000001 }),\n        fromAddress: t.Optional(t.String()),\n        txHash: t.Optional(t.String()),\n        network: t.Optional(t.String()),\n        metadata: t.Optional(t.Record(t.String(), t.Any())),\n      }),\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'Process deposit',\n        description: 'Process a deposit to a wallet',\n      },\n    }\n  )\n\n  /**\n   * Create withdrawal request\n   * POST /api/v1/wallets/:id/withdraw\n   */\n  .post(\n    '/:id/withdraw',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ params, body, user, tenantId }) => {\n      logger.info('Creating withdrawal request', {\n        walletId: params.id,\n        asset: body.asset,\n        amount: body.amount,\n        userId: user.id,\n      });\n\n      const result = await walletService.createWithdrawal({\n        walletId: params.id,\n        userId: user.id,\n        tenantId,\n        asset: body.asset as any,\n        amount: body.amount,\n        destinationAddress: body.destinationAddress,\n        network: body.network,\n        twoFactorCode: body.twoFactorCode,\n        notes: body.notes,\n      });\n\n      return result;\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      body: t.Object({\n        asset: t.Union([\n          t.Literal('BTC'), t.Literal('ETH'), t.Literal('USDT'), t.Literal('USDC'), t.Literal('BNB'), t.Literal('SOL'), t.Literal('ADA'), t.Literal('DOT'), t.Literal('MATIC'), t.Literal('AVAX'), t.Literal('BRL'), t.Literal('USD'),\n        ]),\n        amount: t.Number({ minimum: 0.00000001 }),\n        destinationAddress: t.String({ minLength: 1 }),\n        network: t.String({ minLength: 1 }),\n        twoFactorCode: t.Optional(t.String()),\n        notes: t.Optional(t.String({ maxLength: 500 })),\n      }),\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'Create withdrawal request',\n        description: 'Create a withdrawal request (requires approval)',\n      },\n    }\n  )\n\n  /**\n   * Transfer between wallets\n   * POST /api/v1/wallets/:id/transfer\n   */\n  .post(\n    '/:id/transfer',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ params, body, user, tenantId }) => {\n      logger.info('Processing transfer', {\n        fromWalletId: params.id,\n        toWalletId: body.toWalletId,\n        asset: body.asset,\n        amount: body.amount,\n        userId: user.id,\n      });\n\n      const result = await walletService.transfer({\n        fromWalletId: params.id,\n        toWalletId: body.toWalletId,\n        userId: user.id,\n        tenantId,\n        asset: body.asset as any,\n        amount: body.amount,\n        description: body.description,\n      });\n\n      return result;\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      body: t.Object({\n        toWalletId: t.String(),\n        asset: t.Union([\n          t.Literal('BTC'), t.Literal('ETH'), t.Literal('USDT'), t.Literal('USDC'), t.Literal('BNB'), t.Literal('SOL'), t.Literal('ADA'), t.Literal('DOT'), t.Literal('MATIC'), t.Literal('AVAX'), t.Literal('BRL'), t.Literal('USD'),\n        ]),\n        amount: t.Number({ minimum: 0.00000001 }),\n        description: t.Optional(t.String({ maxLength: 500 })),\n      }),\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'Transfer between wallets',\n        description: 'Transfer assets between two wallets',\n      },\n    }\n  )\n\n  /**\n   * Get transactions\n   * GET /api/v1/wallets/:id/transactions\n   */\n  .get(\n    '/:id/transactions',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ params, query, user }) => {\n      logger.info('Getting transactions', { walletId: params.id, userId: user.id });\n\n      const transactions = await walletService.getTransactions({\n        walletId: params.id,\n        userId: user.id,\n        type: query.type as any,\n        status: query.status as any,\n        asset: query.asset as any,\n        limit: query.limit ? parseInt(query.limit) : 100,\n        offset: query.offset ? parseInt(query.offset) : 0,\n      });\n\n      return {\n        success: true,\n        transactions,\n        total: transactions.length,\n      };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      query: t.Object({\n        type: t.Optional(t.String()),\n        status: t.Optional(t.String()),\n        asset: t.Optional(t.String()),\n        limit: t.Optional(t.String()),\n        offset: t.Optional(t.String()),\n      }),\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'Get wallet transactions',\n        description: 'Get transaction history for a wallet with filters',\n      },\n    }\n  )\n\n  /**\n   * Create savings goal\n   * POST /api/v1/wallets/:id/goals\n   */\n  .post(\n    '/:id/goals',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ params, body, user }) => {\n      const result = await walletService.createSavingsGoal({\n        userId: user.id,\n        walletId: params.id,\n        name: body.name,\n        description: body.description,\n        targetAmount: body.targetAmount,\n        asset: body.asset as any,\n        targetDate: body.targetDate ? new Date(body.targetDate) : undefined,\n        metadata: body.metadata,\n      });\n      return result;\n    },\n    {\n      params: t.Object({ id: t.String() }),\n      body: t.Object({\n        name: t.String({ minLength: 1, maxLength: 100 }),\n        description: t.Optional(t.String({ maxLength: 500 })),\n        targetAmount: t.Number({ minimum: 0.00000001 }),\n        asset: t.Union([\n          t.Literal('BTC'), t.Literal('ETH'), t.Literal('USDT'), t.Literal('USDC'), t.Literal('BNB'), t.Literal('SOL'), t.Literal('ADA'), t.Literal('DOT'), t.Literal('MATIC'), t.Literal('AVAX'), t.Literal('BRL'), t.Literal('USD'),\n        ]),\n        targetDate: t.Optional(t.String()),\n        metadata: t.Optional(t.Record(t.String(), t.Any())),\n      }),\n      detail: {\n        tags: ['Banco - Savings'],\n        summary: 'Create savings goal',\n        description: 'Create a savings goal for a wallet',\n      },\n    }\n  )\n\n  /**\n   * List savings goals\n   * GET /api/v1/wallets/:id/goals\n   */\n  .get(\n    '/:id/goals',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ params, user }) => {\n      const rows = await walletService.listSavingsGoals(user.id, params.id);\n      return { success: true, data: rows, count: rows.length };\n    },\n    {\n      params: t.Object({ id: t.String() }),\n      detail: {\n        tags: ['Banco - Savings'],\n        summary: 'List savings goals',\n        description: 'List active savings goals for a wallet',\n      },\n    }\n  )\n\n  /**\n   * Add progress to a savings goal\n   * POST /api/v1/wallets/goals/:goalId/progress\n   */\n  .post(\n    '/goals/:goalId/progress',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ params, body, user }) => {\n      const result = await walletService.addSavingsProgress(params.goalId, user.id, body.amount);\n      return result;\n    },\n    {\n      params: t.Object({ goalId: t.String() }),\n      body: t.Object({ amount: t.Number({ minimum: 0.00000001 }) }),\n      detail: {\n        tags: ['Banco - Savings'],\n        summary: 'Add savings progress',\n        description: 'Increase the current amount of a savings goal',\n      },\n    }\n  )\n\n  /**\n   * Approve/Reject withdrawal\n   * POST /api/v1/wallets/withdrawals/:id/approve\n   */\n  .post(\n    '/withdrawals/:id/approve',\n    { beforeHandle: [requirePermission('wallets', 'manage')] },\n    async ({ params, body, user }) => {\n      logger.info('Approving/rejecting withdrawal', {\n        withdrawalId: params.id,\n        approved: body.approved,\n        approverId: user.id,\n      });\n\n      const result = await walletService.approveWithdrawal({\n        withdrawalId: params.id,\n        approverId: user.id,\n        approved: body.approved,\n        reason: body.reason,\n      });\n\n      return result;\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      body: t.Object({\n        approved: t.Boolean(),\n        reason: t.Optional(t.String({ maxLength: 500 })),\n      }),\n      detail: {\n        tags: ['Banco - Admin'],\n        summary: 'Approve/Reject withdrawal',\n        description: 'Approve or reject a pending withdrawal request (admin only)',\n      },\n    }\n  )\n\n  /**\n   * Preview withdrawal\n   * POST /api/v1/wallets/:id/withdraw/preview\n   */\n  .post(\n    '/:id/withdraw/preview',\n    { beforeHandle: [requirePermission('wallets', 'write')] },\n    async ({ params, body }) => {\n      const amount = body.amount as number;\n      const platformFee = amount * 0.005;\n      const networkFee = 0;\n      return {\n        success: true,\n        data: {\n          asset: body.asset,\n          amount,\n          platformFee,\n          networkFee,\n          totalFee: platformFee + networkFee,\n          requiresTwoFactor: true,\n        },\n      };\n    },\n    {\n      params: t.Object({ id: t.String() }),\n      body: t.Object({\n        asset: t.Union([\n          t.Literal('BTC'), t.Literal('ETH'), t.Literal('USDT'), t.Literal('USDC'), t.Literal('BNB'), t.Literal('SOL'), t.Literal('ADA'), t.Literal('DOT'), t.Literal('MATIC'), t.Literal('AVAX'), t.Literal('BRL'), t.Literal('USD'),\n        ]),\n        amount: t.Number({ minimum: 0.00000001 }),\n      }),\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'Preview withdrawal fees',\n        description: 'Returns fees and 2FA requirements for a withdrawal request',\n      },\n    }\n  )\n\n  /**\n   * List user withdrawal requests\n   * GET /api/v1/wallets/withdrawals\n   */\n  .get(\n    '/withdrawals',\n    { beforeHandle: [requirePermission('wallets', 'read')] },\n    async ({ user }) => {\n      const rows = await walletService.listUserWithdrawals(user.id);\n      return { success: true, data: rows, count: rows.length };\n    },\n    {\n      detail: {\n        tags: ['Banco - Transactions'],\n        summary: 'List withdrawal requests',\n        description: 'List all withdrawal requests for the authenticated user',\n      },\n    }\n  );\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/schema/wallet.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/services/__tests__/export-csv.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/services/portfolio.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/services/price.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/services/wallet.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/banco/types/wallet.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/bot-engine.registry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/bot-engine.registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/bot-execution.engine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/bot-execution.engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/bot-websocket.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/execution-engine.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/engine/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/routes/bots.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/schema/bots.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/services/bot.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asc' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BotStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":33,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":168,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":168,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tenantId' is defined but never used. Allowed unused args must match /^_/u.","line":793,"column":61,"nodeType":null,"messageId":"unusedVar","endLine":793,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Bot Service\n * Trading bot management and execution service\n */\n\nimport { db } from '@/db';\nimport { bots, botExecutions, botTrades, botLogs, botTemplates } from '../schema/bots.schema';\nimport { eq, and, desc, asc, gte, lte, sql, inArray, or, like } from 'drizzle-orm';\nimport logger from '../../../utils/logger';\nimport type {\n  Bot,\n  BotExecution,\n  BotTrade,\n  BotLog,\n  BotTemplate,\n  BotPerformanceSummary,\n  BotStatistics,\n  BotHealthStatus,\n  CreateBotRequest,\n  UpdateBotRequest,\n  CreateTemplateRequest,\n  UpdateTemplateRequest,\n  BotQueryFilters,\n  ExecutionQueryFilters,\n  TradeQueryFilters,\n  LogQueryFilters,\n  TemplateQueryFilters,\n  PaginationOptions,\n  PaginatedResponse,\n  IBotService,\n  LogLevel,\n  LogCategory,\n  BotStatus,\n} from '../types/bots.types';\nimport { botEngineRegistry } from '../engine/bot-engine.registry';\n\nclass BotService implements IBotService {\n  // ============================================================================\n  // BOT MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Create new trading bot\n   */\n  async createBot(userId: string, tenantId: string, request: CreateBotRequest): Promise<Bot> {\n    try {\n      logger.info('Creating new bot', {\n        userId,\n        tenantId,\n        botName: request.name,\n        botType: request.type,\n      });\n\n      // If template provided, load template configuration\n      let templateConfig: Record<string, any> = {};\n      if (request.templateId) {\n        const template = await this.getTemplate(request.templateId);\n        if (template) {\n          templateConfig = template.configuration;\n          logger.info('Loaded bot template configuration', {\n            templateId: request.templateId,\n            templateName: template.name,\n          });\n        }\n      }\n\n      // Merge template config with request\n      const botConfig = {\n        ...templateConfig,\n        ...request,\n      };\n\n      // Create bot record\n      const [bot] = await db\n        .insert(bots)\n        .values({\n          userId,\n          tenantId,\n          name: botConfig.name,\n          description: botConfig.description,\n          type: botConfig.type,\n          status: 'stopped',\n          strategyId: botConfig.strategyId,\n          templateId: botConfig.templateId,\n          exchangeId: botConfig.exchangeId,\n          symbol: botConfig.symbol,\n          timeframe: botConfig.timeframe || '1h',\n          allocatedCapital: botConfig.allocatedCapital.toString(),\n          currentCapital: botConfig.allocatedCapital.toString(),\n          maxDrawdown: (botConfig.maxDrawdown || 10.0).toString(),\n          stopLossPercent: (botConfig.stopLossPercent || 2.0).toString(),\n          takeProfitPercent: (botConfig.takeProfitPercent || 5.0).toString(),\n          maxPositions: (botConfig.maxPositions || 5).toString(),\n          positionSizing: botConfig.positionSizing || 'fixed',\n          positionSizePercent: (botConfig.positionSizePercent || 20.0).toString(),\n          orderType: botConfig.orderType || 'limit',\n          useTrailingStop: botConfig.useTrailingStop ?? false,\n          trailingStopPercent: (botConfig.trailingStopPercent || 1.5).toString(),\n          gridLevels: botConfig.gridLevels?.toString(),\n          gridUpperPrice: botConfig.gridUpperPrice?.toString(),\n          gridLowerPrice: botConfig.gridLowerPrice?.toString(),\n          gridProfitPercent: botConfig.gridProfitPercent?.toString(),\n          dcaOrderCount: botConfig.dcaOrderCount?.toString(),\n          dcaOrderAmount: botConfig.dcaOrderAmount?.toString(),\n          dcaStepPercent: botConfig.dcaStepPercent?.toString(),\n          dcaTakeProfitPercent: botConfig.dcaTakeProfitPercent?.toString(),\n          parameters: botConfig.parameters,\n          riskLimits: botConfig.riskLimits,\n          notifications: botConfig.notifications,\n          runOnWeekends: botConfig.runOnWeekends ?? true,\n          runOnHolidays: botConfig.runOnHolidays ?? true,\n          startTime: botConfig.startTime,\n          endTime: botConfig.endTime,\n          maxDailyTrades: botConfig.maxDailyTrades?.toString(),\n          cooldownMinutes: (botConfig.cooldownMinutes || 5).toString(),\n          autoRestart: botConfig.autoRestart ?? true,\n          autoStopOnDrawdown: botConfig.autoStopOnDrawdown ?? true,\n          autoStopOnLoss: botConfig.autoStopOnLoss ?? false,\n          enabled: botConfig.enabled ?? true,\n          notes: botConfig.notes,\n          tags: botConfig.tags,\n        })\n        .returning();\n\n      logger.info('Bot created successfully', {\n        botId: bot.id,\n        botName: bot.name,\n      });\n\n      return this.mapBotFromDb(bot);\n    } catch (error) {\n      logger.error('Error creating bot', {\n        userId,\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get bot by ID\n   */\n  async getBot(botId: string, userId: string, tenantId: string): Promise<Bot | null> {\n    try {\n      const [bot] = await db\n        .select()\n        .from(bots)\n        .where(and(eq(bots.id, botId), eq(bots.userId, userId), eq(bots.tenantId, tenantId)))\n        .limit(1);\n\n      return bot ? this.mapBotFromDb(bot) : null;\n    } catch (error) {\n      logger.error('Error getting bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get all bots for user\n   */\n  async getBots(userId: string, tenantId: string, filters?: BotQueryFilters): Promise<Bot[]> {\n    try {\n      const query = db\n        .select()\n        .from(bots)\n        .where(and(eq(bots.userId, userId), eq(bots.tenantId, tenantId)));\n\n      // Apply filters\n      const conditions: any[] = [eq(bots.userId, userId), eq(bots.tenantId, tenantId)];\n\n      if (filters?.status) {\n        conditions.push(eq(bots.status, filters.status));\n      }\n      if (filters?.type) {\n        conditions.push(eq(bots.type, filters.type));\n      }\n      if (filters?.exchangeId) {\n        conditions.push(eq(bots.exchangeId, filters.exchangeId));\n      }\n      if (filters?.symbol) {\n        conditions.push(eq(bots.symbol, filters.symbol));\n      }\n      if (filters?.enabled !== undefined) {\n        conditions.push(eq(bots.enabled, filters.enabled));\n      }\n      if (filters?.search) {\n        conditions.push(\n          or(like(bots.name, `%${filters.search}%`), like(bots.description, `%${filters.search}%`))\n        );\n      }\n\n      const results = await db\n        .select()\n        .from(bots)\n        .where(and(...conditions))\n        .orderBy(desc(bots.createdAt));\n\n      return results.map((bot: any) => this.mapBotFromDb(bot));\n    } catch (error) {\n      logger.error('Error getting bots', {\n        userId,\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update bot configuration\n   */\n  async updateBot(botId: string, userId: string, tenantId: string, updates: UpdateBotRequest): Promise<Bot> {\n    try {\n      logger.info('Updating bot', { botId, userId, tenantId });\n\n      const updateData: any = {\n        updatedAt: new Date(),\n      };\n\n      // Map update fields\n      if (updates.name !== undefined) updateData.name = updates.name;\n      if (updates.description !== undefined) updateData.description = updates.description;\n      if (updates.allocatedCapital !== undefined) updateData.allocatedCapital = updates.allocatedCapital.toString();\n      if (updates.maxDrawdown !== undefined) updateData.maxDrawdown = updates.maxDrawdown.toString();\n      if (updates.stopLossPercent !== undefined) updateData.stopLossPercent = updates.stopLossPercent.toString();\n      if (updates.takeProfitPercent !== undefined) updateData.takeProfitPercent = updates.takeProfitPercent.toString();\n      if (updates.maxPositions !== undefined) updateData.maxPositions = updates.maxPositions.toString();\n      if (updates.positionSizing !== undefined) updateData.positionSizing = updates.positionSizing;\n      if (updates.positionSizePercent !== undefined) updateData.positionSizePercent = updates.positionSizePercent.toString();\n      if (updates.orderType !== undefined) updateData.orderType = updates.orderType;\n      if (updates.useTrailingStop !== undefined) updateData.useTrailingStop = updates.useTrailingStop;\n      if (updates.trailingStopPercent !== undefined) updateData.trailingStopPercent = updates.trailingStopPercent.toString();\n      if (updates.parameters !== undefined) updateData.parameters = updates.parameters;\n      if (updates.riskLimits !== undefined) updateData.riskLimits = updates.riskLimits;\n      if (updates.notifications !== undefined) updateData.notifications = updates.notifications;\n      if (updates.runOnWeekends !== undefined) updateData.runOnWeekends = updates.runOnWeekends;\n      if (updates.runOnHolidays !== undefined) updateData.runOnHolidays = updates.runOnHolidays;\n      if (updates.startTime !== undefined) updateData.startTime = updates.startTime;\n      if (updates.endTime !== undefined) updateData.endTime = updates.endTime;\n      if (updates.maxDailyTrades !== undefined) updateData.maxDailyTrades = updates.maxDailyTrades.toString();\n      if (updates.cooldownMinutes !== undefined) updateData.cooldownMinutes = updates.cooldownMinutes.toString();\n      if (updates.autoRestart !== undefined) updateData.autoRestart = updates.autoRestart;\n      if (updates.autoStopOnDrawdown !== undefined) updateData.autoStopOnDrawdown = updates.autoStopOnDrawdown;\n      if (updates.autoStopOnLoss !== undefined) updateData.autoStopOnLoss = updates.autoStopOnLoss;\n      if (updates.enabled !== undefined) updateData.enabled = updates.enabled;\n      if (updates.notes !== undefined) updateData.notes = updates.notes;\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\n\n      const [updated] = await db\n        .update(bots)\n        .set(updateData)\n        .where(and(eq(bots.id, botId), eq(bots.userId, userId), eq(bots.tenantId, tenantId)))\n        .returning();\n\n      if (!updated) {\n        throw new Error('Bot not found or unauthorized');\n      }\n\n      logger.info('Bot updated successfully', { botId });\n      return this.mapBotFromDb(updated);\n    } catch (error) {\n      logger.error('Error updating bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete bot\n   */\n  async deleteBot(botId: string, userId: string, tenantId: string): Promise<void> {\n    try {\n      logger.info('Deleting bot', { botId, userId, tenantId });\n\n      // Check if bot is running\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (bot?.status === 'running') {\n        throw new Error('Cannot delete running bot. Stop the bot first.');\n      }\n\n      // Delete bot (cascade will handle related records)\n      await db\n        .delete(bots)\n        .where(and(eq(bots.id, botId), eq(bots.userId, userId), eq(bots.tenantId, tenantId)));\n\n      logger.info('Bot deleted successfully', { botId });\n    } catch (error) {\n      logger.error('Error deleting bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // BOT CONTROL\n  // ============================================================================\n\n  /**\n   * Start bot execution\n   */\n  async startBot(botId: string, userId: string, tenantId: string): Promise<BotExecution> {\n    try {\n      logger.info('Starting bot', { botId, userId, tenantId });\n\n      // Get bot\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      // Validate bot can start\n      if (bot.status === 'running') {\n        throw new Error('Bot is already running');\n      }\n      if (!bot.enabled) {\n        throw new Error('Bot is disabled');\n      }\n\n      // Get last execution number\n      const lastExecution = await db\n        .select()\n        .from(botExecutions)\n        .where(eq(botExecutions.botId, botId))\n        .orderBy(desc(botExecutions.executionNumber))\n        .limit(1);\n\n      const executionNumber = lastExecution.length > 0 ? Number(lastExecution[0].executionNumber) + 1 : 1;\n\n      // Create new execution\n      const [execution] = await db\n        .insert(botExecutions)\n        .values({\n          botId,\n          userId,\n          tenantId,\n          executionNumber: executionNumber.toString(),\n          status: 'running',\n          startingCapital: bot.currentCapital?.toString() || bot.allocatedCapital.toString(),\n          configuration: {\n            type: bot.type,\n            symbol: bot.symbol,\n            timeframe: bot.timeframe,\n            parameters: bot.parameters,\n          },\n          startedAt: new Date(),\n        })\n        .returning();\n\n      // Update bot status\n      await db\n        .update(bots)\n        .set({\n          status: 'running',\n          lastExecutionId: execution.id,\n          startedAt: new Date(),\n          consecutiveErrors: '0',\n          updatedAt: new Date(),\n        })\n        .where(eq(bots.id, botId));\n\n      // Log bot start\n      await this.addLog(botId, userId, tenantId, 'info', 'execution', `Bot started - Execution #${executionNumber}`, {\n        executionId: execution.id,\n        allocatedCapital: bot.allocatedCapital,\n      });\n\n      // Attempt to start live execution engine (non-critical to DB record)\n      try {\n        await botEngineRegistry.start({ ...bot, lastExecutionId: execution.id }, undefined, false);\n      } catch (engineError) {\n        logger.error('Failed to start execution engine for bot', {\n          botId,\n          error: engineError instanceof Error ? engineError.message : String(engineError),\n        });\n        // Mark bot as error if engine failed right away\n        await db\n          .update(bots)\n          .set({ status: 'error', updatedAt: new Date(), lastErrorAt: new Date(), lastErrorMessage: 'Engine start failed' })\n          .where(eq(bots.id, botId));\n      }\n\n      logger.info('Bot started successfully', {\n        botId,\n        executionId: execution.id,\n        executionNumber,\n      });\n\n      return this.mapExecutionFromDb(execution);\n    } catch (error) {\n      logger.error('Error starting bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Stop bot execution\n   */\n  async stopBot(botId: string, userId: string, tenantId: string, reason?: string): Promise<void> {\n    try {\n      logger.info('Stopping bot', { botId, userId, tenantId, reason });\n\n      // Get bot\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      if (bot.status === 'stopped') {\n        logger.warn('Bot already stopped', { botId });\n        return;\n      }\n\n      // Get current execution\n      if (bot.lastExecutionId) {\n        const currentExecution = await this.getExecution(bot.lastExecutionId, userId, tenantId);\n        if (currentExecution && currentExecution.status === 'running') {\n          // Calculate execution metrics\n          const durationSeconds = Math.floor(\n            (new Date().getTime() - new Date(currentExecution.startedAt).getTime()) / 1000\n          );\n\n          // Update execution\n          await db\n            .update(botExecutions)\n            .set({\n              status: 'stopped',\n              endedAt: new Date(),\n              durationSeconds: durationSeconds.toString(),\n              endingCapital: bot.currentCapital?.toString() || bot.allocatedCapital.toString(),\n              stopReason: reason || 'manual',\n              stopDetails: reason,\n            })\n            .where(eq(botExecutions.id, bot.lastExecutionId));\n        }\n      }\n\n      // Stop live execution engine first (best-effort)\n      await botEngineRegistry.stop(botId);\n\n      // Update bot status\n      await db\n        .update(bots)\n        .set({\n          status: 'stopped',\n          stoppedAt: new Date(),\n          updatedAt: new Date(),\n        })\n        .where(eq(bots.id, botId));\n\n      // Log bot stop\n      await this.addLog(botId, userId, tenantId, 'info', 'execution', `Bot stopped - Reason: ${reason || 'manual'}`, {\n        stopReason: reason || 'manual',\n      });\n\n      logger.info('Bot stopped successfully', { botId });\n    } catch (error) {\n      logger.error('Error stopping bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Pause bot execution\n   */\n  async pauseBot(botId: string, userId: string, tenantId: string): Promise<void> {\n    try {\n      logger.info('Pausing bot', { botId, userId, tenantId });\n\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      if (bot.status !== 'running') {\n        throw new Error('Bot is not running');\n      }\n\n      await db\n        .update(bots)\n        .set({\n          status: 'paused',\n          updatedAt: new Date(),\n        })\n        .where(eq(bots.id, botId));\n\n      await this.addLog(botId, userId, tenantId, 'info', 'execution', 'Bot paused');\n      logger.info('Bot paused successfully', { botId });\n    } catch (error) {\n      logger.error('Error pausing bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Resume bot execution\n   */\n  async resumeBot(botId: string, userId: string, tenantId: string): Promise<void> {\n    try {\n      logger.info('Resuming bot', { botId, userId, tenantId });\n\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      if (bot.status !== 'paused') {\n        throw new Error('Bot is not paused');\n      }\n\n      await db\n        .update(bots)\n        .set({\n          status: 'running',\n          updatedAt: new Date(),\n        })\n        .where(eq(bots.id, botId));\n\n      await this.addLog(botId, userId, tenantId, 'info', 'execution', 'Bot resumed');\n      logger.info('Bot resumed successfully', { botId });\n    } catch (error) {\n      logger.error('Error resuming bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Restart bot execution\n   */\n  async restartBot(botId: string, userId: string, tenantId: string): Promise<BotExecution> {\n    try {\n      logger.info('Restarting bot', { botId, userId, tenantId });\n\n      // Stop bot if running\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (bot?.status === 'running' || bot?.status === 'paused') {\n        await this.stopBot(botId, userId, tenantId, 'restart');\n      }\n\n      // Start bot again\n      return await this.startBot(botId, userId, tenantId);\n    } catch (error) {\n      logger.error('Error restarting bot', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // BOT STATISTICS & MONITORING\n  // ============================================================================\n\n  /**\n   * Get comprehensive bot statistics\n   */\n  async getBotStatistics(botId: string, userId: string, tenantId: string): Promise<BotStatistics> {\n    try {\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      const performance = await this.getBotPerformance(botId, userId, tenantId);\n      const recentTrades = await this.getTrades(userId, tenantId, { botId, status: 'closed' }, { page: 1, limit: 10 });\n      const currentExecution = bot.lastExecutionId\n        ? await this.getExecution(bot.lastExecutionId, userId, tenantId)\n        : null;\n\n      // Calculate time-based stats\n      const now = new Date();\n      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const weekStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n      const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);\n\n      const todayTrades = await this.getTradesInPeriod(botId, userId, tenantId, todayStart, now);\n      const weekTrades = await this.getTradesInPeriod(botId, userId, tenantId, weekStart, now);\n      const monthTrades = await this.getTradesInPeriod(botId, userId, tenantId, monthStart, now);\n\n      return {\n        bot,\n        performance,\n        recentTrades: recentTrades.data,\n        currentExecution: currentExecution || undefined,\n        todayStats: {\n          tradesExecuted: todayTrades.length,\n          profitLoss: todayTrades.reduce((sum, t) => sum + (Number(t.netProfitLoss) || 0), 0),\n          profitLossPercent: this.calculateProfitLossPercent(todayTrades, bot.allocatedCapital),\n        },\n        weekStats: {\n          tradesExecuted: weekTrades.length,\n          profitLoss: weekTrades.reduce((sum, t) => sum + (Number(t.netProfitLoss) || 0), 0),\n          profitLossPercent: this.calculateProfitLossPercent(weekTrades, bot.allocatedCapital),\n        },\n        monthStats: {\n          tradesExecuted: monthTrades.length,\n          profitLoss: monthTrades.reduce((sum, t) => sum + (Number(t.netProfitLoss) || 0), 0),\n          profitLossPercent: this.calculateProfitLossPercent(monthTrades, bot.allocatedCapital),\n        },\n      };\n    } catch (error) {\n      logger.error('Error getting bot statistics', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get bot performance summary\n   */\n  async getBotPerformance(botId: string, userId: string, tenantId: string): Promise<BotPerformanceSummary> {\n    try {\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      const runningDays = bot.startedAt\n        ? Math.floor((new Date().getTime() - new Date(bot.startedAt).getTime()) / (1000 * 60 * 60 * 24))\n        : 0;\n\n      const capitalGrowth = bot.currentCapital\n        ? ((bot.currentCapital - bot.allocatedCapital) / bot.allocatedCapital) * 100\n        : 0;\n\n      return {\n        botId: bot.id,\n        botName: bot.name,\n        allocatedCapital: bot.allocatedCapital,\n        currentCapital: bot.currentCapital || bot.allocatedCapital,\n        capitalGrowth,\n        totalTrades: bot.totalTrades,\n        winningTrades: bot.winningTrades,\n        losingTrades: bot.losingTrades,\n        winRate: bot.winRate || 0,\n        profitFactor: bot.profitFactor || 0,\n        totalProfit: bot.totalProfit,\n        totalLoss: bot.totalLoss,\n        netProfit: bot.netProfit,\n        netProfitPercent: (bot.netProfit / bot.allocatedCapital) * 100,\n        averageWin: bot.averageWin || 0,\n        averageLoss: bot.averageLoss || 0,\n        largestWin: bot.largestWin || 0,\n        largestLoss: bot.largestLoss || 0,\n        currentDrawdown: bot.currentDrawdown,\n        maxDrawdownReached: bot.maxDrawdownReached,\n        sharpeRatio: bot.sharpeRatio,\n        sortinoRatio: bot.sortinoRatio,\n        returnOnInvestment: bot.returnOnInvestment || capitalGrowth,\n        runningDays,\n        lastTradeAt: bot.lastTradeAt,\n      };\n    } catch (error) {\n      logger.error('Error getting bot performance', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get bot health status\n   */\n  async getBotHealth(botId: string, userId: string, tenantId: string): Promise<BotHealthStatus> {\n    try {\n      const bot = await this.getBot(botId, userId, tenantId);\n      if (!bot) {\n        throw new Error('Bot not found');\n      }\n\n      const issues: BotHealthStatus['issues'] = [];\n\n      // Check consecutive errors\n      if (bot.consecutiveErrors > 3) {\n        issues.push({\n          severity: 'high',\n          category: 'errors',\n          message: 'High error rate detected',\n          details: `Bot has encountered ${bot.consecutiveErrors} consecutive errors`,\n        });\n      }\n\n      // Check drawdown\n      if (bot.currentDrawdown > bot.maxDrawdown * 0.8) {\n        issues.push({\n          severity: 'critical',\n          category: 'risk',\n          message: 'Approaching maximum drawdown limit',\n          details: `Current drawdown: ${bot.currentDrawdown.toFixed(2)}%, Max: ${bot.maxDrawdown}%`,\n        });\n      }\n\n      // Check capital\n      const capitalRatio = bot.currentCapital ? bot.currentCapital / bot.allocatedCapital : 1;\n      let capitalStatus: 'sufficient' | 'low' | 'depleted' = 'sufficient';\n      if (capitalRatio < 0.1) {\n        capitalStatus = 'depleted';\n        issues.push({\n          severity: 'critical',\n          category: 'capital',\n          message: 'Capital depleted',\n          details: 'Bot has lost 90% or more of allocated capital',\n        });\n      } else if (capitalRatio < 0.5) {\n        capitalStatus = 'low';\n        issues.push({\n          severity: 'medium',\n          category: 'capital',\n          message: 'Low capital',\n          details: 'Bot has lost more than 50% of allocated capital',\n        });\n      }\n\n      // Check performance\n      let performanceStatus: 'good' | 'acceptable' | 'poor' = 'good';\n      if (bot.winRate && bot.winRate < 30) {\n        performanceStatus = 'poor';\n        issues.push({\n          severity: 'medium',\n          category: 'performance',\n          message: 'Low win rate',\n          details: `Current win rate: ${bot.winRate.toFixed(2)}%`,\n        });\n      } else if (bot.winRate && bot.winRate < 45) {\n        performanceStatus = 'acceptable';\n      }\n\n      // Cross-check engine registry state vs DB state\n      const engineRunning = botEngineRegistry.isRunning(botId);\n      if (bot.status === 'running' && !engineRunning) {\n        issues.push({ severity: 'high', category: 'engine', message: 'Engine not active while bot marked running' });\n      }\n\n      const isHealthy = issues.filter((i) => i.severity === 'critical' || i.severity === 'high').length === 0;\n\n      return {\n        botId: bot.id,\n        status: bot.status,\n        isHealthy,\n        issues,\n        lastHeartbeat: bot.updatedAt,\n        consecutiveErrors: bot.consecutiveErrors,\n        marketConnection: engineRunning ? 'connected' : bot.status === 'running' ? 'degraded' : 'disconnected',\n        capitalStatus,\n        performanceStatus,\n      };\n    } catch (error) {\n      logger.error('Error getting bot health', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update bot performance metrics\n   */\n  async updateBotPerformance(botId: string, userId: string, tenantId: string): Promise<void> {\n    try {\n      // Get all closed trades\n      const allTrades = await db\n        .select()\n        .from(botTrades)\n        .where(and(eq(botTrades.botId, botId), eq(botTrades.status, 'closed')));\n\n      if (allTrades.length === 0) {\n        return;\n      }\n\n      // Calculate metrics\n      const totalTrades = allTrades.length;\n      const winningTrades = allTrades.filter((t: any) => Number(t.netProfitLoss) > 0).length;\n      const losingTrades = allTrades.filter((t: any) => Number(t.netProfitLoss) < 0).length;\n      const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;\n\n      const totalProfit = allTrades\n        .filter((t: any) => Number(t.netProfitLoss) > 0)\n        .reduce((sum: number, t: any) => sum + Number(t.netProfitLoss), 0);\n\n      const totalLoss = Math.abs(\n        allTrades.filter((t: any) => Number(t.netProfitLoss) < 0).reduce((sum: number, t: any) => sum + Number(t.netProfitLoss), 0)\n      );\n\n      const netProfit = totalProfit - totalLoss;\n      const profitFactor = totalLoss > 0 ? totalProfit / totalLoss : 0;\n\n      const averageWin = winningTrades > 0 ? totalProfit / winningTrades : 0;\n      const averageLoss = losingTrades > 0 ? totalLoss / losingTrades : 0;\n\n      const largestWin = Math.max(...allTrades.map((t: any) => Number(t.netProfitLoss) || 0));\n      const largestLoss = Math.abs(Math.min(...allTrades.map((t: any) => Number(t.netProfitLoss) || 0)));\n\n      // Update bot\n      await db\n        .update(bots)\n        .set({\n          totalTrades: totalTrades.toString(),\n          winningTrades: winningTrades.toString(),\n          losingTrades: losingTrades.toString(),\n          winRate: winRate.toString(),\n          totalProfit: totalProfit.toString(),\n          totalLoss: totalLoss.toString(),\n          netProfit: netProfit.toString(),\n          profitFactor: profitFactor.toString(),\n          averageWin: averageWin.toString(),\n          averageLoss: averageLoss.toString(),\n          largestWin: largestWin.toString(),\n          largestLoss: largestLoss.toString(),\n          updatedAt: new Date(),\n        })\n        .where(eq(bots.id, botId));\n\n      logger.info('Bot performance metrics updated', { botId });\n    } catch (error) {\n      logger.error('Error updating bot performance', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // EXECUTIONS\n  // ============================================================================\n\n  /**\n   * Get execution by ID\n   */\n  async getExecution(executionId: string, userId: string, tenantId: string): Promise<BotExecution | null> {\n    try {\n      const [execution] = await db\n        .select()\n        .from(botExecutions)\n        .where(\n          and(\n            eq(botExecutions.id, executionId),\n            eq(botExecutions.userId, userId),\n            eq(botExecutions.tenantId, tenantId)\n          )\n        )\n        .limit(1);\n\n      return execution ? this.mapExecutionFromDb(execution) : null;\n    } catch (error) {\n      logger.error('Error getting execution', {\n        executionId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get executions with pagination\n   */\n  async getExecutions(\n    userId: string,\n    tenantId: string,\n    filters?: ExecutionQueryFilters,\n    pagination?: PaginationOptions\n  ): Promise<PaginatedResponse<BotExecution>> {\n    try {\n      const page = pagination?.page || 1;\n      const limit = pagination?.limit || 20;\n      const offset = (page - 1) * limit;\n\n      const conditions: any[] = [eq(botExecutions.userId, userId), eq(botExecutions.tenantId, tenantId)];\n\n      if (filters?.botId) {\n        conditions.push(eq(botExecutions.botId, filters.botId));\n      }\n      if (filters?.status) {\n        conditions.push(eq(botExecutions.status, filters.status));\n      }\n      if (filters?.dateFrom) {\n        conditions.push(gte(botExecutions.startedAt, filters.dateFrom));\n      }\n      if (filters?.dateTo) {\n        conditions.push(lte(botExecutions.startedAt, filters.dateTo));\n      }\n\n      const [countResult] = await db\n        .select({ count: sql<number>`count(*)` })\n        .from(botExecutions)\n        .where(and(...conditions));\n\n      const total = Number(countResult.count);\n      const totalPages = Math.ceil(total / limit);\n\n      const results = await db\n        .select()\n        .from(botExecutions)\n        .where(and(...conditions))\n        .orderBy(desc(botExecutions.startedAt))\n        .limit(limit)\n        .offset(offset);\n\n      return {\n        data: results.map((execution: any) => this.mapExecutionFromDb(execution)),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages,\n          hasNext: page < totalPages,\n          hasPrev: page > 1,\n        },\n      };\n    } catch (error) {\n      logger.error('Error getting executions', {\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get current execution for bot\n   */\n  async getCurrentExecution(botId: string, userId: string, tenantId: string): Promise<BotExecution | null> {\n    try {\n      const [execution] = await db\n        .select()\n        .from(botExecutions)\n        .where(\n          and(\n            eq(botExecutions.botId, botId),\n            eq(botExecutions.userId, userId),\n            eq(botExecutions.tenantId, tenantId),\n            eq(botExecutions.status, 'running')\n          )\n        )\n        .orderBy(desc(botExecutions.startedAt))\n        .limit(1);\n\n      return execution ? this.mapExecutionFromDb(execution) : null;\n    } catch (error) {\n      logger.error('Error getting current execution', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // TRADES\n  // ============================================================================\n\n  /**\n   * Get trade by ID\n   */\n  async getTrade(tradeId: string, userId: string, tenantId: string): Promise<BotTrade | null> {\n    try {\n      const [trade] = await db\n        .select()\n        .from(botTrades)\n        .where(and(eq(botTrades.id, tradeId), eq(botTrades.userId, userId), eq(botTrades.tenantId, tenantId)))\n        .limit(1);\n\n      return trade ? this.mapTradeFromDb(trade) : null;\n    } catch (error) {\n      logger.error('Error getting trade', {\n        tradeId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get trades with pagination\n   */\n  async getTrades(\n    userId: string,\n    tenantId: string,\n    filters?: TradeQueryFilters,\n    pagination?: PaginationOptions\n  ): Promise<PaginatedResponse<BotTrade>> {\n    try {\n      const page = pagination?.page || 1;\n      const limit = pagination?.limit || 50;\n      const offset = (page - 1) * limit;\n\n      const conditions: any[] = [eq(botTrades.userId, userId), eq(botTrades.tenantId, tenantId)];\n\n      if (filters?.botId) {\n        conditions.push(eq(botTrades.botId, filters.botId));\n      }\n      if (filters?.executionId) {\n        conditions.push(eq(botTrades.executionId, filters.executionId));\n      }\n      if (filters?.status) {\n        conditions.push(eq(botTrades.status, filters.status));\n      }\n      if (filters?.symbol) {\n        conditions.push(eq(botTrades.symbol, filters.symbol));\n      }\n      if (filters?.side) {\n        conditions.push(eq(botTrades.side, filters.side));\n      }\n      if (filters?.dateFrom) {\n        conditions.push(gte(botTrades.openedAt, filters.dateFrom));\n      }\n      if (filters?.dateTo) {\n        conditions.push(lte(botTrades.openedAt, filters.dateTo));\n      }\n\n      const [countResult] = await db\n        .select({ count: sql<number>`count(*)` })\n        .from(botTrades)\n        .where(and(...conditions));\n\n      const total = Number(countResult.count);\n      const totalPages = Math.ceil(total / limit);\n\n      const results = await db\n        .select()\n        .from(botTrades)\n        .where(and(...conditions))\n        .orderBy(desc(botTrades.openedAt))\n        .limit(limit)\n        .offset(offset);\n\n      return {\n        data: results.map((trade: any) => this.mapTradeFromDb(trade)),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages,\n          hasNext: page < totalPages,\n          hasPrev: page > 1,\n        },\n      };\n    } catch (error) {\n      logger.error('Error getting trades', {\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get open trades for bot\n   */\n  async getOpenTrades(botId: string, userId: string, tenantId: string): Promise<BotTrade[]> {\n    try {\n      const results = await db\n        .select()\n        .from(botTrades)\n        .where(\n          and(\n            eq(botTrades.botId, botId),\n            eq(botTrades.userId, userId),\n            eq(botTrades.tenantId, tenantId),\n            eq(botTrades.status, 'open')\n          )\n        )\n        .orderBy(desc(botTrades.openedAt));\n\n      return results.map((trade: any) => this.mapTradeFromDb(trade));\n    } catch (error) {\n      logger.error('Error getting open trades', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // LOGS\n  // ============================================================================\n\n  /**\n   * Get logs with pagination\n   */\n  async getLogs(\n    userId: string,\n    tenantId: string,\n    filters?: LogQueryFilters,\n    pagination?: PaginationOptions\n  ): Promise<PaginatedResponse<BotLog>> {\n    try {\n      const page = pagination?.page || 1;\n      const limit = pagination?.limit || 100;\n      const offset = (page - 1) * limit;\n\n      const conditions: any[] = [eq(botLogs.userId, userId), eq(botLogs.tenantId, tenantId)];\n\n      if (filters?.botId) {\n        conditions.push(eq(botLogs.botId, filters.botId));\n      }\n      if (filters?.executionId) {\n        conditions.push(eq(botLogs.executionId, filters.executionId));\n      }\n      if (filters?.level) {\n        conditions.push(eq(botLogs.level, filters.level));\n      }\n      if (filters?.category) {\n        conditions.push(eq(botLogs.category, filters.category));\n      }\n      if (filters?.dateFrom) {\n        conditions.push(gte(botLogs.timestamp, filters.dateFrom));\n      }\n      if (filters?.dateTo) {\n        conditions.push(lte(botLogs.timestamp, filters.dateTo));\n      }\n\n      const [countResult] = await db.select({ count: sql<number>`count(*)` }).from(botLogs).where(and(...conditions));\n\n      const total = Number(countResult.count);\n      const totalPages = Math.ceil(total / limit);\n\n      const results = await db\n        .select()\n        .from(botLogs)\n        .where(and(...conditions))\n        .orderBy(desc(botLogs.timestamp))\n        .limit(limit)\n        .offset(offset);\n\n      return {\n        data: results.map((log: any) => this.mapLogFromDb(log)),\n        pagination: {\n          page,\n          limit,\n          total,\n          totalPages,\n          hasNext: page < totalPages,\n          hasPrev: page > 1,\n        },\n      };\n    } catch (error) {\n      logger.error('Error getting logs', {\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Add log entry\n   */\n  async addLog(\n    botId: string,\n    userId: string,\n    tenantId: string,\n    level: LogLevel,\n    category: LogCategory,\n    message: string,\n    details?: Record<string, any>\n  ): Promise<BotLog> {\n    try {\n      const [log] = await db\n        .insert(botLogs)\n        .values({\n          botId,\n          userId,\n          tenantId,\n          level,\n          category,\n          message,\n          details,\n          timestamp: new Date(),\n        })\n        .returning();\n\n      return this.mapLogFromDb(log);\n    } catch (error) {\n      logger.error('Error adding log', {\n        botId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // TEMPLATES\n  // ============================================================================\n\n  /**\n   * Create bot template\n   */\n  async createTemplate(userId: string, tenantId: string, request: CreateTemplateRequest): Promise<BotTemplate> {\n    try {\n      logger.info('Creating bot template', { userId, tenantId, templateName: request.name });\n\n      const [template] = await db\n        .insert(botTemplates)\n        .values({\n          userId,\n          tenantId,\n          name: request.name,\n          description: request.description,\n          type: request.type,\n          category: request.category || 'general',\n          isPublic: request.isPublic || false,\n          isSystem: false,\n          isFeatured: false,\n          configuration: request.configuration,\n          requiredParameters: request.requiredParameters,\n          defaultParameters: request.defaultParameters,\n          documentation: request.documentation,\n          setupInstructions: request.setupInstructions,\n          riskWarning: request.riskWarning,\n          tags: request.tags,\n        })\n        .returning();\n\n      logger.info('Template created successfully', { templateId: template.id });\n      return this.mapTemplateFromDb(template);\n    } catch (error) {\n      logger.error('Error creating template', {\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get template by ID\n   */\n  async getTemplate(templateId: string): Promise<BotTemplate | null> {\n    try {\n      const [template] = await db.select().from(botTemplates).where(eq(botTemplates.id, templateId)).limit(1);\n\n      return template ? this.mapTemplateFromDb(template) : null;\n    } catch (error) {\n      logger.error('Error getting template', {\n        templateId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get templates with filters\n   */\n  async getTemplates(filters?: TemplateQueryFilters): Promise<BotTemplate[]> {\n    try {\n      const conditions: any[] = [];\n\n      if (filters?.type) {\n        conditions.push(eq(botTemplates.type, filters.type));\n      }\n      if (filters?.category) {\n        conditions.push(eq(botTemplates.category, filters.category));\n      }\n      if (filters?.isPublic !== undefined) {\n        conditions.push(eq(botTemplates.isPublic, filters.isPublic));\n      }\n      if (filters?.isSystem !== undefined) {\n        conditions.push(eq(botTemplates.isSystem, filters.isSystem));\n      }\n      if (filters?.isFeatured !== undefined) {\n        conditions.push(eq(botTemplates.isFeatured, filters.isFeatured));\n      }\n      if (filters?.search) {\n        conditions.push(\n          or(\n            like(botTemplates.name, `%${filters.search}%`),\n            like(botTemplates.description, `%${filters.search}%`)\n          )\n        );\n      }\n\n      const query = conditions.length > 0 ? db.select().from(botTemplates).where(and(...conditions)) : db.select().from(botTemplates);\n\n      const results = await query.orderBy(desc(botTemplates.isFeatured), desc(botTemplates.createdAt));\n\n      return results.map((template: any) => this.mapTemplateFromDb(template));\n    } catch (error) {\n      logger.error('Error getting templates', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update template\n   */\n  async updateTemplate(templateId: string, userId: string, updates: UpdateTemplateRequest): Promise<BotTemplate> {\n    try {\n      const updateData: any = { updatedAt: new Date() };\n\n      if (updates.name !== undefined) updateData.name = updates.name;\n      if (updates.description !== undefined) updateData.description = updates.description;\n      if (updates.category !== undefined) updateData.category = updates.category;\n      if (updates.configuration !== undefined) updateData.configuration = updates.configuration;\n      if (updates.requiredParameters !== undefined) updateData.requiredParameters = updates.requiredParameters;\n      if (updates.defaultParameters !== undefined) updateData.defaultParameters = updates.defaultParameters;\n      if (updates.isPublic !== undefined) updateData.isPublic = updates.isPublic;\n      if (updates.documentation !== undefined) updateData.documentation = updates.documentation;\n      if (updates.setupInstructions !== undefined) updateData.setupInstructions = updates.setupInstructions;\n      if (updates.riskWarning !== undefined) updateData.riskWarning = updates.riskWarning;\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\n\n      const [updated] = await db\n        .update(botTemplates)\n        .set(updateData)\n        .where(and(eq(botTemplates.id, templateId), eq(botTemplates.userId, userId)))\n        .returning();\n\n      if (!updated) {\n        throw new Error('Template not found or unauthorized');\n      }\n\n      return this.mapTemplateFromDb(updated);\n    } catch (error) {\n      logger.error('Error updating template', {\n        templateId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete template\n   */\n  async deleteTemplate(templateId: string, userId: string): Promise<void> {\n    try {\n      await db.delete(botTemplates).where(and(eq(botTemplates.id, templateId), eq(botTemplates.userId, userId)));\n      logger.info('Template deleted', { templateId });\n    } catch (error) {\n      logger.error('Error deleting template', {\n        templateId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Clone bot from template\n   */\n  async cloneBotFromTemplate(\n    templateId: string,\n    userId: string,\n    tenantId: string,\n    overrides: Partial<CreateBotRequest>\n  ): Promise<Bot> {\n    try {\n      const template = await this.getTemplate(templateId);\n      if (!template) {\n        throw new Error('Template not found');\n      }\n\n      const botRequest: CreateBotRequest = {\n        name: overrides.name || `${template.name} - Copy`,\n        description: overrides.description || template.description,\n        type: template.type,\n        templateId: template.id,\n        exchangeId: '',\n        symbol: '',\n        allocatedCapital: 0,\n        ...template.configuration,\n        ...overrides,\n      } as CreateBotRequest;\n\n      return await this.createBot(userId, tenantId, botRequest);\n    } catch (error) {\n      logger.error('Error cloning bot from template', {\n        templateId,\n        userId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Validate bot configuration\n   */\n  async validateBotConfiguration(config: CreateBotRequest): Promise<{\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  }> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Required fields\n    if (!config.name || config.name.trim().length === 0) {\n      errors.push('Bot name is required');\n    }\n    if (!config.type) {\n      errors.push('Bot type is required');\n    }\n    if (!config.exchangeId) {\n      errors.push('Exchange ID is required');\n    }\n    if (!config.symbol) {\n      errors.push('Trading symbol is required');\n    }\n    if (!config.allocatedCapital || config.allocatedCapital <= 0) {\n      errors.push('Allocated capital must be greater than 0');\n    }\n\n    // Risk validation\n    if (config.maxDrawdown && config.maxDrawdown > 50) {\n      warnings.push('Max drawdown is very high (>50%). Consider reducing for better risk management.');\n    }\n    if (config.stopLossPercent && config.stopLossPercent > 10) {\n      warnings.push('Stop loss is very wide (>10%). Consider tightening for better risk control.');\n    }\n\n    // Position sizing validation\n    if (config.positionSizePercent && config.positionSizePercent > 50) {\n      warnings.push('Position size is very large (>50% of capital). This increases risk significantly.');\n    }\n    if (config.maxPositions && config.maxPositions > 10) {\n      warnings.push('Managing more than 10 positions simultaneously can be challenging.');\n    }\n\n    // Grid bot validation\n    if (config.type === 'grid') {\n      if (!config.gridLevels || config.gridLevels < 2) {\n        errors.push('Grid bot requires at least 2 levels');\n      }\n      if (!config.gridUpperPrice || !config.gridLowerPrice) {\n        errors.push('Grid bot requires upper and lower price bounds');\n      }\n      if (config.gridUpperPrice && config.gridLowerPrice && config.gridUpperPrice <= config.gridLowerPrice) {\n        errors.push('Grid upper price must be greater than lower price');\n      }\n    }\n\n    // DCA bot validation\n    if (config.type === 'dca') {\n      if (!config.dcaOrderCount || config.dcaOrderCount < 2) {\n        errors.push('DCA bot requires at least 2 orders');\n      }\n      if (!config.dcaOrderAmount || config.dcaOrderAmount <= 0) {\n        errors.push('DCA order amount must be greater than 0');\n      }\n      if (!config.dcaStepPercent || config.dcaStepPercent <= 0) {\n        errors.push('DCA step percent must be greater than 0');\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  // ============================================================================\n  // HELPER METHODS\n  // ============================================================================\n\n  /**\n   * Get trades in period\n   */\n  private async getTradesInPeriod(\n    botId: string,\n    userId: string,\n    tenantId: string,\n    from: Date,\n    to: Date\n  ): Promise<BotTrade[]> {\n    const results = await db\n      .select()\n      .from(botTrades)\n      .where(\n        and(\n          eq(botTrades.botId, botId),\n          eq(botTrades.userId, userId),\n          eq(botTrades.tenantId, tenantId),\n          eq(botTrades.status, 'closed'),\n          gte(botTrades.closedAt, from),\n          lte(botTrades.closedAt, to)\n        )\n      );\n\n    return results.map((trade: any) => this.mapTradeFromDb(trade));\n  }\n\n  /**\n   * Calculate profit/loss percentage\n   */\n  private calculateProfitLossPercent(trades: BotTrade[], allocatedCapital: number): number {\n    if (trades.length === 0 || allocatedCapital === 0) return 0;\n    const totalPL = trades.reduce((sum, t) => sum + (Number(t.netProfitLoss) || 0), 0);\n    return (totalPL / allocatedCapital) * 100;\n  }\n\n  /**\n   * Map database bot to domain model\n   */\n  private mapBotFromDb(bot: any): Bot {\n    return {\n      id: bot.id,\n      userId: bot.userId,\n      tenantId: bot.tenantId,\n      name: bot.name,\n      description: bot.description,\n      type: bot.type,\n      status: bot.status,\n      strategyId: bot.strategyId,\n      templateId: bot.templateId,\n      exchangeId: bot.exchangeId,\n      symbol: bot.symbol,\n      timeframe: bot.timeframe,\n      allocatedCapital: Number(bot.allocatedCapital),\n      currentCapital: bot.currentCapital ? Number(bot.currentCapital) : undefined,\n      maxDrawdown: Number(bot.maxDrawdown),\n      stopLossPercent: Number(bot.stopLossPercent),\n      takeProfitPercent: Number(bot.takeProfitPercent),\n      maxPositions: Number(bot.maxPositions),\n      positionSizing: bot.positionSizing,\n      positionSizePercent: Number(bot.positionSizePercent),\n      orderType: bot.orderType,\n      useTrailingStop: bot.useTrailingStop,\n      trailingStopPercent: Number(bot.trailingStopPercent),\n      gridLevels: bot.gridLevels ? Number(bot.gridLevels) : undefined,\n      gridUpperPrice: bot.gridUpperPrice ? Number(bot.gridUpperPrice) : undefined,\n      gridLowerPrice: bot.gridLowerPrice ? Number(bot.gridLowerPrice) : undefined,\n      gridProfitPercent: bot.gridProfitPercent ? Number(bot.gridProfitPercent) : undefined,\n      dcaOrderCount: bot.dcaOrderCount ? Number(bot.dcaOrderCount) : undefined,\n      dcaOrderAmount: bot.dcaOrderAmount ? Number(bot.dcaOrderAmount) : undefined,\n      dcaStepPercent: bot.dcaStepPercent ? Number(bot.dcaStepPercent) : undefined,\n      dcaTakeProfitPercent: bot.dcaTakeProfitPercent ? Number(bot.dcaTakeProfitPercent) : undefined,\n      parameters: bot.parameters,\n      riskLimits: bot.riskLimits,\n      notifications: bot.notifications,\n      runOnWeekends: bot.runOnWeekends,\n      runOnHolidays: bot.runOnHolidays,\n      startTime: bot.startTime,\n      endTime: bot.endTime,\n      maxDailyTrades: bot.maxDailyTrades ? Number(bot.maxDailyTrades) : undefined,\n      cooldownMinutes: Number(bot.cooldownMinutes),\n      totalTrades: Number(bot.totalTrades),\n      winningTrades: Number(bot.winningTrades),\n      losingTrades: Number(bot.losingTrades),\n      totalProfit: Number(bot.totalProfit),\n      totalLoss: Number(bot.totalLoss),\n      netProfit: Number(bot.netProfit),\n      profitFactor: bot.profitFactor ? Number(bot.profitFactor) : undefined,\n      winRate: bot.winRate ? Number(bot.winRate) : undefined,\n      averageWin: bot.averageWin ? Number(bot.averageWin) : undefined,\n      averageLoss: bot.averageLoss ? Number(bot.averageLoss) : undefined,\n      largestWin: bot.largestWin ? Number(bot.largestWin) : undefined,\n      largestLoss: bot.largestLoss ? Number(bot.largestLoss) : undefined,\n      currentDrawdown: Number(bot.currentDrawdown),\n      maxDrawdownReached: Number(bot.maxDrawdownReached),\n      sharpeRatio: bot.sharpeRatio ? Number(bot.sharpeRatio) : undefined,\n      sortinoRatio: bot.sortinoRatio ? Number(bot.sortinoRatio) : undefined,\n      returnOnInvestment: bot.returnOnInvestment ? Number(bot.returnOnInvestment) : undefined,\n      lastExecutionId: bot.lastExecutionId,\n      lastTradeAt: bot.lastTradeAt,\n      lastErrorAt: bot.lastErrorAt,\n      lastErrorMessage: bot.lastErrorMessage,\n      consecutiveErrors: Number(bot.consecutiveErrors),\n      autoRestart: bot.autoRestart,\n      autoStopOnDrawdown: bot.autoStopOnDrawdown,\n      autoStopOnLoss: bot.autoStopOnLoss,\n      enabled: bot.enabled,\n      version: Number(bot.version),\n      backtestId: bot.backtestId,\n      notes: bot.notes,\n      tags: bot.tags,\n      createdAt: bot.createdAt,\n      updatedAt: bot.updatedAt,\n      startedAt: bot.startedAt,\n      stoppedAt: bot.stoppedAt,\n    };\n  }\n\n  /**\n   * Map database execution to domain model\n   */\n  private mapExecutionFromDb(execution: any): BotExecution {\n    return {\n      id: execution.id,\n      botId: execution.botId,\n      userId: execution.userId,\n      tenantId: execution.tenantId,\n      executionNumber: Number(execution.executionNumber),\n      status: execution.status,\n      startingCapital: Number(execution.startingCapital),\n      endingCapital: execution.endingCapital ? Number(execution.endingCapital) : undefined,\n      profitLoss: Number(execution.profitLoss),\n      profitLossPercent: Number(execution.profitLossPercent),\n      tradesExecuted: Number(execution.tradesExecuted),\n      tradesWon: Number(execution.tradesWon),\n      tradesLost: Number(execution.tradesLost),\n      winRate: execution.winRate ? Number(execution.winRate) : undefined,\n      errorsEncountered: Number(execution.errorsEncountered),\n      warningsEncountered: Number(execution.warningsEncountered),\n      lastError: execution.lastError,\n      configuration: execution.configuration,\n      marketConditions: execution.marketConditions,\n      startedAt: execution.startedAt,\n      endedAt: execution.endedAt,\n      durationSeconds: execution.durationSeconds ? Number(execution.durationSeconds) : undefined,\n      stopReason: execution.stopReason,\n      stopDetails: execution.stopDetails,\n      createdAt: execution.createdAt,\n    };\n  }\n\n  /**\n   * Map database trade to domain model\n   */\n  private mapTradeFromDb(trade: any): BotTrade {\n    return {\n      id: trade.id,\n      botId: trade.botId,\n      executionId: trade.executionId,\n      userId: trade.userId,\n      tenantId: trade.tenantId,\n      orderId: trade.orderId,\n      positionId: trade.positionId,\n      exchangeOrderId: trade.exchangeOrderId,\n      symbol: trade.symbol,\n      side: trade.side,\n      type: trade.type,\n      quantity: Number(trade.quantity),\n      entryPrice: Number(trade.entryPrice),\n      exitPrice: trade.exitPrice ? Number(trade.exitPrice) : undefined,\n      averagePrice: trade.averagePrice ? Number(trade.averagePrice) : undefined,\n      stopLoss: trade.stopLoss ? Number(trade.stopLoss) : undefined,\n      takeProfit: trade.takeProfit ? Number(trade.takeProfit) : undefined,\n      trailingStop: trade.trailingStop ? Number(trade.trailingStop) : undefined,\n      status: trade.status,\n      profitLoss: trade.profitLoss ? Number(trade.profitLoss) : undefined,\n      profitLossPercent: trade.profitLossPercent ? Number(trade.profitLossPercent) : undefined,\n      fees: Number(trade.fees),\n      netProfitLoss: trade.netProfitLoss ? Number(trade.netProfitLoss) : undefined,\n      gridLevel: trade.gridLevel ? Number(trade.gridLevel) : undefined,\n      dcaLevel: trade.dcaLevel ? Number(trade.dcaLevel) : undefined,\n      signalType: trade.signalType,\n      signalStrength: trade.signalStrength ? Number(trade.signalStrength) : undefined,\n      strategySnapshot: trade.strategySnapshot,\n      openedAt: trade.openedAt,\n      closedAt: trade.closedAt,\n      durationMinutes: trade.durationMinutes ? Number(trade.durationMinutes) : undefined,\n      closeReason: trade.closeReason,\n      closeDetails: trade.closeDetails,\n      riskRewardRatio: trade.riskRewardRatio ? Number(trade.riskRewardRatio) : undefined,\n      maxDrawdownPercent: trade.maxDrawdownPercent ? Number(trade.maxDrawdownPercent) : undefined,\n      maxProfitPercent: trade.maxProfitPercent ? Number(trade.maxProfitPercent) : undefined,\n      notes: trade.notes,\n      createdAt: trade.createdAt,\n      updatedAt: trade.updatedAt,\n    };\n  }\n\n  /**\n   * Map database log to domain model\n   */\n  private mapLogFromDb(log: any): BotLog {\n    return {\n      id: log.id,\n      botId: log.botId,\n      executionId: log.executionId,\n      userId: log.userId,\n      tenantId: log.tenantId,\n      level: log.level,\n      category: log.category,\n      message: log.message,\n      details: log.details,\n      tradeId: log.tradeId,\n      orderId: log.orderId,\n      errorCode: log.errorCode,\n      errorStack: log.errorStack,\n      timestamp: log.timestamp,\n      createdAt: log.createdAt,\n    };\n  }\n\n  /**\n   * Map database template to domain model\n   */\n  private mapTemplateFromDb(template: any): BotTemplate {\n    return {\n      id: template.id,\n      userId: template.userId,\n      tenantId: template.tenantId,\n      name: template.name,\n      description: template.description,\n      type: template.type,\n      category: template.category,\n      isPublic: template.isPublic,\n      isSystem: template.isSystem,\n      isFeatured: template.isFeatured,\n      configuration: template.configuration,\n      requiredParameters: template.requiredParameters,\n      defaultParameters: template.defaultParameters,\n      backtestResults: template.backtestResults,\n      expectedReturn: template.expectedReturn ? Number(template.expectedReturn) : undefined,\n      expectedRisk: template.expectedRisk ? Number(template.expectedRisk) : undefined,\n      minimumCapital: template.minimumCapital ? Number(template.minimumCapital) : undefined,\n      recommendedCapital: template.recommendedCapital ? Number(template.recommendedCapital) : undefined,\n      supportedExchanges: template.supportedExchanges,\n      supportedSymbols: template.supportedSymbols,\n      supportedTimeframes: template.supportedTimeframes,\n      timesUsed: Number(template.timesUsed),\n      averageRating: template.averageRating ? Number(template.averageRating) : undefined,\n      totalRatings: Number(template.totalRatings),\n      documentation: template.documentation,\n      setupInstructions: template.setupInstructions,\n      riskWarning: template.riskWarning,\n      version: template.version,\n      tags: template.tags,\n      createdAt: template.createdAt,\n      updatedAt: template.updatedAt,\n    };\n  }\n}\n\n// Export singleton instance\nexport const botService = new BotService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/bots/types/bots.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/routes/ceo.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/schema/ceo.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/services/ceo.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chartOfAccounts' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'accountBalances' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'periodLength' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":536,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":536,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CEO Dashboard Service\n * Aggregates metrics from all modules for executive dashboard\n */\n\nimport { db } from '../../../db';\nimport { eq, and, sql, gte, lte, desc, isNotNull } from 'drizzle-orm';\nimport { ceoDashboardConfigs, ceoKpis, ceoAlerts } from '../schema/ceo.schema';\nimport { tenantSubscriptionPlans, subscriptionPlans } from '../../subscriptions/schema/subscription-plans.schema';\nimport { subscriptionHistory } from '../../subscriptions/schema/subscription-history.schema';\nimport { users } from '../../auth/schema/auth.schema';\nimport { tenantMembers } from '../../tenants/schema/tenants.schema';\nimport { cacheManager } from '../../../cache/cache-manager';\nimport logger from '../../../utils/logger';\nimport { invoices } from '../../financial/schema/invoices.schema';\nimport { paymentTransactions, paymentGateways } from '../../financial/schema/payments.schema';\nimport { chartOfAccounts, accountBalances } from '../../financial/schema/ledger.schema';\nimport { tradingStrategies } from '../../strategies/schema/strategies.schema';\nimport { bots } from '../../bots/schema/bots.schema';\nimport { metricsRegistry } from '../../monitoring/metrics/registry';\nimport { systemMetrics } from '../../monitoring/metrics/collectors/system.metrics';\nimport { summarizeHttpMetrics } from '../utils/metrics.util';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport type {\n  DashboardData,\n  DashboardConfig,\n  KPIMetric,\n  Alert,\n  RevenueMetrics,\n  UserMetrics,\n  SubscriptionMetrics,\n  FinancialHealthMetrics,\n  SystemHealthMetrics,\n  ServiceResponse,\n  DashboardQueryOptions,\n} from '../types/ceo.types';\n\nexport class CeoService {\n  private readonly CACHE_TTL = 300; // 5 minutes\n  private readonly CACHE_NAMESPACE = 'ceo';\n\n  /**\n   * Get complete dashboard data\n   */\n  async getDashboardData(options: DashboardQueryOptions): Promise<ServiceResponse<DashboardData>> {\n    try {\n      const cacheKey = `dashboard:${options.tenantId}:${options.dateRange}`;\n\n      // Try cache first\n      const cached = await cacheManager.get<DashboardData>(this.CACHE_NAMESPACE, cacheKey);\n      if (cached) {\n        logger.debug('CEO dashboard data retrieved from cache', { tenantId: options.tenantId });\n        return { success: true, data: cached };\n      }\n\n      // Calculate date range\n      const { startDate, endDate } = this.calculateDateRange(options);\n\n      // Fetch all metrics in parallel\n      const [revenue, userMetrics, subscriptions, financial, system, alerts] = await Promise.all([\n        this.getRevenueMetrics(options.tenantId, startDate, endDate),\n        this.getUserMetrics(options.tenantId, startDate, endDate),\n        this.getSubscriptionMetrics(options.tenantId, startDate, endDate),\n        this.getFinancialHealthMetrics(options.tenantId, startDate, endDate),\n        this.getSystemHealthMetrics(options.tenantId, startDate, endDate),\n        this.getActiveAlerts(options.tenantId),\n      ]);\n\n      const dashboardData: DashboardData = {\n        period: {\n          start: startDate,\n          end: endDate,\n          days: Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)),\n        },\n        revenue: revenue.data ?? ({} as RevenueMetrics),\n        users: userMetrics.data ?? ({} as UserMetrics),\n        subscriptions: subscriptions.data ?? ({} as SubscriptionMetrics),\n        financial: financial.data ?? ({} as FinancialHealthMetrics),\n        system: system.data ?? ({} as SystemHealthMetrics),\n        activeAlerts: alerts.data || [],\n        criticalAlertsCount: alerts.data?.filter((a) => a.severity === 'critical').length || 0,\n        generatedAt: new Date(),\n        cacheExpiresAt: new Date(Date.now() + this.CACHE_TTL * 1000),\n      };\n\n      // Cache the result\n      await cacheManager.set(this.CACHE_NAMESPACE, cacheKey, dashboardData, this.CACHE_TTL);\n\n      logger.info('CEO dashboard data generated', {\n        tenantId: options.tenantId,\n        period: `${startDate.toISOString()} - ${endDate.toISOString()}`,\n      });\n\n      return { success: true, data: dashboardData };\n    } catch (error) {\n      logger.error('Error getting CEO dashboard data', { error, options });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'CEO_DASHBOARD_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Get real-time KPIs\n   */\n  async getKPIs(tenantId: string): Promise<ServiceResponse<KPIMetric[]>> {\n    try {\n      const cacheKey = `kpis:${tenantId}`;\n\n      // Try cache first\n      const cached = await cacheManager.get<KPIMetric[]>(this.CACHE_NAMESPACE, cacheKey);\n      if (cached) {\n        return { success: true, data: cached };\n      }\n\n      // Get custom KPIs from database (reserved for future use)\n      const _customKpis = await db\n        .select()\n        .from(ceoKpis)\n        .where(and(eq(ceoKpis.tenantId, tenantId), eq(ceoKpis.isActive, true)))\n        .orderBy(ceoKpis.sortOrder);\n\n      // Calculate standard KPIs\n      const now = new Date();\n      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n      const [revenue, userMetrics, subscriptions] = await Promise.all([\n        this.getRevenueMetrics(tenantId, thirtyDaysAgo, now),\n        this.getUserMetrics(tenantId, thirtyDaysAgo, now),\n        this.getSubscriptionMetrics(tenantId, thirtyDaysAgo, now),\n      ]);\n\n      const revenueData = revenue.data ?? { mrr: 0, arr: 0, mrrGrowth: 0, arrGrowth: 0, previousPeriod: { mrr: 0, arr: 0 } } as RevenueMetrics;\n      const userMetricsData = userMetrics.data ?? { activeUsers: 0, activeUserGrowth: 0, churnRate: 0, previousPeriod: { activeUsers: 0 } } as UserMetrics;\n      const subscriptionsData = subscriptions.data ?? { activeSubscriptions: 0, previousPeriod: { activeSubscriptions: 0 } } as SubscriptionMetrics;\n\n      const kpis: KPIMetric[] = [\n        {\n          id: 'mrr',\n          name: 'MRR',\n          displayName: 'Monthly Recurring Revenue',\n          category: 'revenue',\n          metric: 'mrr',\n          value: revenueData.mrr,\n          previousValue: revenueData.previousPeriod.mrr,\n          changePercent: revenueData.mrrGrowth,\n          unit: 'currency',\n          trend: revenueData.mrrGrowth > 0 ? 'up' : revenueData.mrrGrowth < 0 ? 'down' : 'stable',\n          color: 'green',\n          icon: 'dollar-sign',\n        },\n        {\n          id: 'arr',\n          name: 'ARR',\n          displayName: 'Annual Recurring Revenue',\n          category: 'revenue',\n          metric: 'arr',\n          value: revenueData.arr,\n          previousValue: revenueData.previousPeriod.arr,\n          changePercent: revenueData.arrGrowth,\n          unit: 'currency',\n          trend: revenueData.arrGrowth > 0 ? 'up' : revenueData.arrGrowth < 0 ? 'down' : 'stable',\n          color: 'blue',\n          icon: 'trending-up',\n        },\n        {\n          id: 'active_users',\n          name: 'Active Users',\n          displayName: 'Active Users',\n          category: 'users',\n          metric: 'active_users',\n          value: userMetricsData.activeUsers,\n          previousValue: userMetricsData.previousPeriod.activeUsers,\n          changePercent: userMetricsData.activeUserGrowth,\n          unit: 'number',\n          trend:\n            userMetricsData.activeUserGrowth > 0\n              ? 'up'\n              : userMetricsData.activeUserGrowth < 0\n                ? 'down'\n                : 'stable',\n          color: 'purple',\n          icon: 'users',\n        },\n        {\n          id: 'churn_rate',\n          name: 'Churn Rate',\n          displayName: 'Churn Rate',\n          category: 'retention',\n          metric: 'churn',\n          value: userMetricsData.churnRate,\n          unit: 'percentage',\n          trend: userMetricsData.churnRate < 5 ? 'stable' : 'down',\n          color: userMetricsData.churnRate < 5 ? 'green' : 'red',\n          icon: 'alert-triangle',\n        },\n        {\n          id: 'total_subscriptions',\n          name: 'Total Subscriptions',\n          displayName: 'Total Subscriptions',\n          category: 'growth',\n          metric: 'active_users',\n          value: subscriptionsData.activeSubscriptions,\n          previousValue: subscriptionsData.previousPeriod.activeSubscriptions,\n          changePercent: this.calculateGrowth(\n            subscriptionsData.activeSubscriptions,\n            subscriptionsData.previousPeriod.activeSubscriptions\n          ),\n          unit: 'number',\n          color: 'indigo',\n          icon: 'credit-card',\n        },\n      ];\n\n      // Cache the result\n      await cacheManager.set(this.CACHE_NAMESPACE, cacheKey, kpis, this.CACHE_TTL);\n\n      return { success: true, data: kpis };\n    } catch (error) {\n      logger.error('Error getting KPIs', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'KPI_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Get active alerts\n   */\n  async getAlerts(tenantId: string, severity?: string): Promise<ServiceResponse<Alert[]>> {\n    try {\n      const query = db\n        .select()\n        .from(ceoAlerts)\n        .where(\n          severity\n            ? and(\n                eq(ceoAlerts.tenantId, tenantId),\n                eq(ceoAlerts.status, 'active'),\n                eq(ceoAlerts.severity, severity as any)\n              )\n            : and(eq(ceoAlerts.tenantId, tenantId), eq(ceoAlerts.status, 'active'))\n        )\n        .orderBy(desc(ceoAlerts.createdAt))\n        .limit(50);\n\n      const alerts = await query;\n\n      // Transform decimal strings to numbers for client\n      const transformedAlerts = alerts.map((alert) => ({\n        ...alert,\n        currentValue: alert.currentValue ? parseFloat(alert.currentValue) : undefined,\n        previousValue: alert.previousValue ? parseFloat(alert.previousValue) : undefined,\n        changePercent: alert.changePercent ? parseFloat(alert.changePercent) : undefined,\n        threshold: alert.threshold ? parseFloat(alert.threshold) : undefined,\n      })) as Alert[];\n\n      return { success: true, data: transformedAlerts };\n    } catch (error) {\n      logger.error('Error getting alerts', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'ALERTS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Acknowledge an alert\n   */\n  async acknowledgeAlert(tenantId: string, alertId: string, userId: string): Promise<ServiceResponse<Alert>> {\n    try {\n      const [updated] = await db\n        .update(ceoAlerts)\n        .set({ status: 'acknowledged', acknowledgedAt: new Date(), acknowledgedBy: userId, updatedAt: new Date() })\n        .where(and(eq(ceoAlerts.id, alertId as any), eq(ceoAlerts.tenantId, tenantId as any)))\n        .returning();\n      if (!updated) {\n        return { success: false, error: 'Alert not found', code: 'ALERT_NOT_FOUND' };\n      }\n      return { success: true, data: (updated as unknown) as Alert };\n    } catch (error) {\n      logger.error('Error acknowledging alert', { error, tenantId, alertId });\n      return { success: false, error: 'ALERT_ACK_ERROR', code: 'ALERT_ACK_ERROR' };\n    }\n  }\n\n  /** Resolve an alert */\n  async resolveAlert(tenantId: string, alertId: string, userId: string): Promise<ServiceResponse<Alert>> {\n    try {\n      const [updated] = await db\n        .update(ceoAlerts)\n        .set({ status: 'resolved', resolvedAt: new Date(), resolvedBy: userId, updatedAt: new Date() })\n        .where(and(eq(ceoAlerts.id, alertId as any), eq(ceoAlerts.tenantId, tenantId as any)))\n        .returning();\n      if (!updated) {\n        return { success: false, error: 'Alert not found', code: 'ALERT_NOT_FOUND' };\n      }\n      return { success: true, data: (updated as unknown) as Alert };\n    } catch (error) {\n      logger.error('Error resolving alert', { error, tenantId, alertId });\n      return { success: false, error: 'ALERT_RESOLVE_ERROR', code: 'ALERT_RESOLVE_ERROR' };\n    }\n  }\n\n  /** Dismiss an alert */\n  async dismissAlert(tenantId: string, alertId: string): Promise<ServiceResponse<Alert>> {\n    try {\n      const [updated] = await db\n        .update(ceoAlerts)\n        .set({ status: 'dismissed', updatedAt: new Date() })\n        .where(and(eq(ceoAlerts.id, alertId as any), eq(ceoAlerts.tenantId, tenantId as any)))\n        .returning();\n      if (!updated) return { success: false, error: 'Alert not found', code: 'ALERT_NOT_FOUND' };\n      return { success: true, data: (updated as unknown) as Alert };\n    } catch (error) {\n      logger.error('Error dismissing alert', { error, tenantId, alertId });\n      return { success: false, error: 'ALERT_DISMISS_ERROR', code: 'ALERT_DISMISS_ERROR' };\n    }\n  }\n\n  /**\n   * Trend: new users per day\n   */\n  async getUserTrends(tenantId: string, startDate: Date, endDate: Date): Promise<ServiceResponse<Array<{ bucket: string; count: number }>>> {\n    try {\n      const rows = await db\n        .select({\n          bucket: sql<string>`to_char(date_trunc('day', ${tenantMembers.joinedAt}) AT TIME ZONE 'UTC', 'YYYY-MM-DD')`,\n          count: sql<number>`count(*)::int`,\n        })\n        .from(tenantMembers)\n        .where(\n          and(\n            eq(tenantMembers.tenantId, tenantId as any),\n            gte(tenantMembers.joinedAt, startDate),\n            lte(tenantMembers.joinedAt, endDate)\n          )\n        )\n        .groupBy(sql`date_trunc('day', ${tenantMembers.joinedAt})`)\n        .orderBy(sql`date_trunc('day', ${tenantMembers.joinedAt})`);\n\n      return { success: true, data: rows };\n    } catch (error) {\n      logger.error('Error getting user trends', { error, tenantId });\n      return { success: false, error: 'USER_TRENDS_ERROR', code: 'USER_TRENDS_ERROR' };\n    }\n  }\n\n  /**\n   * Get revenue metrics\n   */\n  async getRevenueMetrics(\n    tenantId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ServiceResponse<RevenueMetrics>> {\n    try {\n      // Query active subscriptions for the period\n      const activeSubscriptions = await db\n        .select({\n          planId: subscriptionPlans.id,\n          planName: subscriptionPlans.name,\n          priceMonthly: subscriptionPlans.priceMonthly,\n          billingPeriod: tenantSubscriptionPlans.billingPeriod,\n        })\n        .from(tenantSubscriptionPlans)\n        .innerJoin(subscriptionPlans, eq(tenantSubscriptionPlans.planId, subscriptionPlans.id))\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'active')\n          )\n        );\n\n      // Calculate MRR\n      let mrr = 0;\n      const revenueByPlan: { [key: string]: { planId: string; planName: string; revenue: number } } = {};\n\n      for (const sub of activeSubscriptions) {\n        const monthlyPrice = parseFloat(sub.priceMonthly);\n        mrr += monthlyPrice;\n\n        if (!revenueByPlan[sub.planId]) {\n          revenueByPlan[sub.planId] = {\n            planId: sub.planId,\n            planName: sub.planName,\n            revenue: 0,\n          };\n        }\n        revenueByPlan[sub.planId].revenue += monthlyPrice;\n      }\n\n      const arr = mrr * 12;\n\n      // Get previous period for comparison\n      const periodLength = endDate.getTime() - startDate.getTime();\n      const _prevStartDate = new Date(startDate.getTime() - periodLength);\n      const prevEndDate = startDate;\n\n      const prevSubscriptions = await db\n        .select({\n          priceMonthly: subscriptionPlans.priceMonthly,\n        })\n        .from(tenantSubscriptionPlans)\n        .innerJoin(subscriptionPlans, eq(tenantSubscriptionPlans.planId, subscriptionPlans.id))\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'active'),\n            lte(tenantSubscriptionPlans.currentPeriodStart, prevEndDate)\n          )\n        );\n\n      const prevMrr = prevSubscriptions.reduce((sum, sub) => sum + parseFloat(sub.priceMonthly), 0);\n      const prevArr = prevMrr * 12;\n\n      const mrrGrowth = this.calculateGrowth(mrr, prevMrr);\n      const arrGrowth = this.calculateGrowth(arr, prevArr);\n\n      // Calculate ARPU (Average Revenue Per User)\n      const arpu = activeSubscriptions.length > 0 ? mrr / activeSubscriptions.length : 0;\n\n      // Calculate churned revenue from canceled subscriptions in period\n      const churnedRevenueResult = await db\n        .select({\n          total: sql<string>`COALESCE(SUM(CAST(${subscriptionHistory.oldPrice} AS DECIMAL)), 0)`,\n        })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.eventType, 'canceled'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const churnedRevenue = parseFloat(churnedRevenueResult[0]?.total || '0');\n\n      // Calculate expansion revenue from upgrades in period\n      const upgradesResult = await db\n        .select({\n          oldPrice: subscriptionHistory.oldPrice,\n          newPrice: subscriptionHistory.newPrice,\n        })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.eventType, 'upgraded'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const expansionRevenue = upgradesResult.reduce((sum, upgrade) => {\n        const oldPrice = parseFloat(upgrade.oldPrice || '0');\n        const newPrice = parseFloat(upgrade.newPrice || '0');\n        return sum + Math.max(0, newPrice - oldPrice);\n      }, 0);\n\n      const metrics: RevenueMetrics = {\n        mrr,\n        arr,\n        totalRevenue: mrr,\n        newRevenue: Math.max(0, mrr - prevMrr),\n        mrrGrowth,\n        arrGrowth,\n        revenueGrowth: mrrGrowth,\n        arpu,\n        churnedRevenue,\n        expansionRevenue,\n        revenueByPlan: Object.values(revenueByPlan).map((item) => ({\n          ...item,\n          percentage: mrr > 0 ? (item.revenue / mrr) * 100 : 0,\n        })),\n        previousPeriod: {\n          mrr: prevMrr,\n          arr: prevArr,\n          totalRevenue: prevMrr,\n        },\n      };\n\n      return { success: true, data: metrics };\n    } catch (error) {\n      logger.error('Error getting revenue metrics', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'REVENUE_METRICS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Get user metrics\n   */\n  async getUserMetrics(\n    tenantId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ServiceResponse<UserMetrics>> {\n    try {\n      // Total users in tenant = active memberships count\n      const totalUsersResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantMembers)\n        .where(and(eq(tenantMembers.tenantId, tenantId as any), eq(tenantMembers.status, 'active')));\n      const totalUsers = totalUsersResult[0]?.count || 0;\n\n      // New users in period = memberships joined in range\n      const newUsersResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantMembers)\n        .where(\n          and(\n            eq(tenantMembers.tenantId, tenantId as any),\n            gte(tenantMembers.joinedAt, startDate),\n            lte(tenantMembers.joinedAt, endDate)\n          )\n        );\n      const newUsers = newUsersResult[0]?.count || 0;\n\n      // Active/Churn approximations (until session/activity and churn events available)\n      const activeUsers = Math.floor(totalUsers * 0.7);\n      const churnedUsers = Math.floor(totalUsers * 0.05);\n\n      // Previous period comparison based on membership snapshot\n      const periodLength = endDate.getTime() - startDate.getTime();\n      const prevEnd = startDate;\n      const prevTotalUsersResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantMembers)\n        .where(and(eq(tenantMembers.tenantId, tenantId as any), lte(tenantMembers.joinedAt, prevEnd)));\n      const prevTotalUsers = prevTotalUsersResult[0]?.count || 0;\n      const prevActiveUsers = Math.floor(prevTotalUsers * 0.7);\n\n      const userGrowth = this.calculateGrowth(totalUsers, prevTotalUsers);\n      const activeUserGrowth = this.calculateGrowth(activeUsers, prevActiveUsers);\n\n      const churnRate = totalUsers > 0 ? (churnedUsers / totalUsers) * 100 : 0;\n      const retentionRate = 100 - churnRate;\n\n      const metrics: UserMetrics = {\n        totalUsers,\n        activeUsers,\n        newUsers,\n        churnedUsers,\n        userGrowth,\n        activeUserGrowth,\n        churnRate,\n        retentionRate,\n        dailyActiveUsers: Math.floor(activeUsers * 0.4),\n        weeklyActiveUsers: Math.floor(activeUsers * 0.7),\n        monthlyActiveUsers: activeUsers,\n        avgSessionDuration: 1800, // 30 minutes\n        avgSessionsPerUser: 15,\n        previousPeriod: {\n          totalUsers: prevTotalUsers,\n          activeUsers: prevActiveUsers,\n          newUsers: Math.floor(newUsers * 0.8), // Estimate\n        },\n      };\n\n      return { success: true, data: metrics };\n    } catch (error) {\n      logger.error('Error getting user metrics', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'USER_METRICS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Get subscription metrics\n   */\n  async getSubscriptionMetrics(\n    tenantId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ServiceResponse<SubscriptionMetrics>> {\n    try {\n      // Count active subscriptions\n      const activeSubsResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantSubscriptionPlans)\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'active')\n          )\n        );\n\n      const activeSubscriptions = activeSubsResult[0]?.count || 0;\n\n      // Count trialing subscriptions\n      const trialingSubsResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantSubscriptionPlans)\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'trialing')\n          )\n        );\n\n      const trialingSubscriptions = trialingSubsResult[0]?.count || 0;\n\n      // Count new subscriptions in period\n      const newSubsResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantSubscriptionPlans)\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            gte(tenantSubscriptionPlans.currentPeriodStart, startDate),\n            lte(tenantSubscriptionPlans.currentPeriodStart, endDate)\n          )\n        );\n\n      const newSubscriptions = newSubsResult[0]?.count || 0;\n\n      // Get subscriptions by plan\n      const subsByPlan = await db\n        .select({\n          planId: subscriptionPlans.id,\n          planName: subscriptionPlans.name,\n          count: sql<number>`count(*)::int`,\n        })\n        .from(tenantSubscriptionPlans)\n        .innerJoin(subscriptionPlans, eq(tenantSubscriptionPlans.planId, subscriptionPlans.id))\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'active')\n          )\n        )\n        .groupBy(subscriptionPlans.id, subscriptionPlans.name);\n\n      // Get subscriptions by billing period\n      const subsByBilling = await db\n        .select({\n          period: tenantSubscriptionPlans.billingPeriod,\n          count: sql<number>`count(*)::int`,\n        })\n        .from(tenantSubscriptionPlans)\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'active')\n          )\n        )\n        .groupBy(tenantSubscriptionPlans.billingPeriod);\n\n      const totalSubscriptions = activeSubscriptions + trialingSubscriptions;\n\n      // Previous period\n      const _periodLength = endDate.getTime() - startDate.getTime();\n      const prevEndDate = startDate;\n\n      const prevActiveSubsResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantSubscriptionPlans)\n        .where(\n          and(\n            eq(tenantSubscriptionPlans.tenantId, tenantId),\n            eq(tenantSubscriptionPlans.status, 'active'),\n            lte(tenantSubscriptionPlans.currentPeriodStart, prevEndDate)\n          )\n        );\n\n      const prevActiveSubscriptions = prevActiveSubsResult[0]?.count || 0;\n\n      // Count canceled subscriptions in period\n      const canceledSubsResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.eventType, 'canceled'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const canceledSubscriptions = canceledSubsResult[0]?.count || 0;\n\n      // Count upgrades in period\n      const upgradesCountResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.eventType, 'upgraded'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const upgrades = upgradesCountResult[0]?.count || 0;\n\n      // Count downgrades in period\n      const downgradesCountResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.eventType, 'downgraded'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const downgrades = downgradesCountResult[0]?.count || 0;\n\n      // Count cancellations in period (same as canceledSubscriptions)\n      const cancellations = canceledSubscriptions;\n\n      // Calculate trial conversion rate\n      // Find trials created in period\n      const trialsCreatedResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.eventType, 'created'),\n            eq(subscriptionHistory.oldStatus, 'trialing'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const trialsCreated = trialsCreatedResult[0]?.count || 0;\n\n      // Find trials that converted to active in period\n      const trialsConvertedResult = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(subscriptionHistory)\n        .where(\n          and(\n            eq(subscriptionHistory.tenantId, tenantId),\n            eq(subscriptionHistory.oldStatus, 'trialing'),\n            eq(subscriptionHistory.newStatus, 'active'),\n            gte(subscriptionHistory.eventTime, startDate),\n            lte(subscriptionHistory.eventTime, endDate)\n          )\n        );\n\n      const trialsConverted = trialsConvertedResult[0]?.count || 0;\n\n      // Calculate conversion rate percentage\n      const trialConversionRate = trialsCreated > 0 ? (trialsConverted / trialsCreated) * 100 : 0;\n\n      const metrics: SubscriptionMetrics = {\n        totalSubscriptions,\n        activeSubscriptions,\n        trialingSubscriptions,\n        canceledSubscriptions,\n        subscriptionsByPlan: subsByPlan.map((item) => ({\n          planId: item.planId,\n          planName: item.planName,\n          count: item.count,\n          percentage: activeSubscriptions > 0 ? (item.count / activeSubscriptions) * 100 : 0,\n        })),\n        subscriptionsByBilling: subsByBilling.map((item) => ({\n          period: item.period as 'monthly' | 'quarterly' | 'yearly',\n          count: item.count,\n          percentage: activeSubscriptions > 0 ? (item.count / activeSubscriptions) * 100 : 0,\n        })),\n        newSubscriptions,\n        upgrades,\n        downgrades,\n        cancellations,\n        trialConversionRate,\n        previousPeriod: {\n          totalSubscriptions: prevActiveSubscriptions,\n          activeSubscriptions: prevActiveSubscriptions,\n          newSubscriptions: Math.floor(newSubscriptions * 0.8), // Estimate\n        },\n      };\n\n      return { success: true, data: metrics };\n    } catch (error) {\n      logger.error('Error getting subscription metrics', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'SUBSCRIPTION_METRICS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Get financial health metrics\n   */\n  async getFinancialHealthMetrics(\n    tenantId: string,\n    _startDate: Date,\n    _endDate: Date\n  ): Promise<ServiceResponse<FinancialHealthMetrics>> {\n    try {\n      // Determine fiscal period (YYYY-MM) using endDate\n      const end = _endDate || new Date();\n      const fiscalPeriod = `${end.getUTCFullYear()}-${String(end.getUTCMonth() + 1).padStart(2, '0')}`;\n\n      // Profit & Loss for net margin\n      const { ReportService } = await import('../../financial/services/report.service');\n      const reportService = new ReportService();\n      const pl = await reportService.generateProfitLoss(tenantId, fiscalPeriod);\n\n      let netMargin = 0;\n      let revenueTotal = 0;\n      let expenseTotal = 0;\n      if (pl.success && pl.data) {\n        revenueTotal = parseFloat(pl.data.revenue.total);\n        expenseTotal = parseFloat(pl.data.expenses.total);\n        const netIncome = revenueTotal - expenseTotal;\n        netMargin = revenueTotal > 0 ? (netIncome / revenueTotal) * 100 : 0;\n      }\n\n      // Cash flow closing balance as cash balance\n      const cf = await reportService.generateCashFlow(tenantId, fiscalPeriod);\n      const cashBalance = cf.success && cf.data ? parseFloat(cf.data.closingBalance) : 0;\n\n      // Approximate cash burn: if net negative in P&L, use -(netIncome); else 0\n      const netIncome = revenueTotal - expenseTotal;\n      const cashBurn = netIncome < 0 ? Math.abs(netIncome) : 0;\n      const runwayMonths = cashBurn > 0 ? +(cashBalance / cashBurn).toFixed(2) : Infinity;\n\n      // Outstanding invoices (pending AR)\n      const [outstandingRow] = await db\n        .select({\n          total: sql<string>`COALESCE(SUM(CAST(${invoices.remainingAmount} AS DECIMAL)), 0)::text`,\n        })\n        .from(invoices)\n        .where(\n          and(\n            eq(invoices.tenantId, tenantId as any),\n            sql`${invoices.type} = 'income'`,\n            sql`${invoices.paymentStatus} IN ('pending','partial')`\n          )\n        );\n      const outstandingInvoices = parseFloat(outstandingRow?.total || '0');\n\n      // Overdue invoices (past due and not fully paid)\n      const now = new Date();\n      const [overdueRow] = await db\n        .select({\n          total: sql<string>`COALESCE(SUM(CAST(${invoices.remainingAmount} AS DECIMAL)), 0)::text`,\n        })\n        .from(invoices)\n        .where(\n          and(\n            eq(invoices.tenantId, tenantId as any),\n            sql`${invoices.type} = 'income'`,\n            lte(invoices.dueDate, now),\n            sql`${invoices.paymentStatus} <> 'paid'`\n          )\n        );\n      const overdueInvoices = parseFloat(overdueRow?.total || '0');\n\n      // Pending payments (AP transactions not completed)\n      const [pendingPaymentsRow] = await db\n        .select({\n          total: sql<string>`COALESCE(SUM(CAST(${paymentTransactions.amount} AS DECIMAL)), 0)::text`,\n        })\n        .from(paymentTransactions)\n        .where(\n          and(\n            eq(paymentTransactions.tenantId, tenantId as any),\n            sql`${paymentTransactions.status} IN ('pending','processing')`\n          )\n        );\n      const pendingPayments = parseFloat(pendingPaymentsRow?.total || '0');\n\n      // CAC/LTV best-effort placeholders from available data: derive from ARPU where possible\n      // ARPU proxy: monthly revenue per active subscription\n      const activeSubsCountRow = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tenantSubscriptionPlans)\n        .where(and(eq(tenantSubscriptionPlans.tenantId, tenantId), eq(tenantSubscriptionPlans.status, 'active')))\n        .limit(1);\n      const activeSubsCount = activeSubsCountRow[0]?.count || 0;\n      const mrrProxy = revenueTotal / Math.max(1, (_endDate.getTime() - _startDate.getTime()) / (1000 * 60 * 60 * 24 * 30));\n      const arpuProxy = activeSubsCount > 0 ? mrrProxy / activeSubsCount : 0;\n      const ltv = +(arpuProxy * 24).toFixed(2); // assume 24 months lifetime unless better data exists\n      const cac = 0; // marketing spend not modeled; report 0 until expense classification exists\n      const ltvCacRatio = cac > 0 ? +(ltv / cac).toFixed(2) : Infinity;\n\n      const metrics: FinancialHealthMetrics = {\n        cac,\n        ltv,\n        ltvCacRatio,\n        grossMargin: netMargin, // without COGS classification, use net margin as conservative proxy\n        netMargin: +netMargin.toFixed(2),\n        cashBalance: +cashBalance.toFixed(2),\n        cashBurn: +cashBurn.toFixed(2),\n        runwayMonths: isFinite(runwayMonths) ? runwayMonths : 0,\n        outstandingInvoices: +outstandingInvoices.toFixed(2),\n        overdueInvoices: +overdueInvoices.toFixed(2),\n        pendingPayments: +pendingPayments.toFixed(2),\n      };\n\n      return { success: true, data: metrics };\n    } catch (error) {\n      logger.error('Error getting financial health metrics', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'FINANCIAL_METRICS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Get system health metrics\n   */\n  async getSystemHealthMetrics(\n    tenantId: string,\n    _startDate: Date,\n    _endDate: Date\n  ): Promise<ServiceResponse<SystemHealthMetrics>> {\n    try {\n      // Force collection of latest system metrics\n      systemMetrics.collect();\n      const metricsJSON = await metricsRegistry.getMetricsJSON();\n\n      const httpSummary = summarizeHttpMetrics(metricsJSON as any[]);\n      const totalApiCalls = httpSummary.totalApiCalls;\n      const errorRate = httpSummary.errorRatePercent;\n      const avgResponseTime = httpSummary.avgResponseTimeMs;\n\n      // Uptime approximation: process uptime vs period length (capped 100)\n      const periodSeconds = Math.max(1, Math.floor((_endDate.getTime() - _startDate.getTime()) / 1000));\n      const uptimeSeconds = Math.min(process.uptime(), periodSeconds);\n      const uptime = +Math.min(100, (uptimeSeconds / periodSeconds) * 100).toFixed(2);\n\n      // Storage usage (local provider)\n      const baseDir = process.env.STORAGE_LOCAL_PATH || './storage/documents';\n      const storageUsedBytes = await this.getDirectorySizeSafe(baseDir);\n      const storageUsed = +(storageUsedBytes / (1024 ** 3)).toFixed(2); // GB\n      const storageLimit = +(process.env.STORAGE_LIMIT_GB ? Number(process.env.STORAGE_LIMIT_GB) : 500);\n      const storagePercent = +Math.min(100, (storageUsed / storageLimit) * 100).toFixed(2);\n\n      // Active resources (DB counts)\n      const activeBotsRow = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(bots)\n        .where(and(eq(bots.tenantId, tenantId), eq(bots.status, 'running')))\n        .limit(1);\n      const activeBotsCount = activeBotsRow[0]?.count || 0;\n\n      const activeStrategiesRow = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(tradingStrategies)\n        .where(and(eq(tradingStrategies.tenantId, tenantId), eq(tradingStrategies.status, 'active')))\n        .limit(1);\n      const activeStrategies = activeStrategiesRow[0]?.count || 0;\n\n      const activeWebhooksRow = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(paymentGateways)\n        .where(and(eq(paymentGateways.isActive, true), isNotNull(paymentGateways.webhookUrl)))\n        .limit(1);\n      const activeWebhooks = activeWebhooksRow[0]?.count || 0;\n\n      const metrics: SystemHealthMetrics = {\n        avgResponseTime,\n        errorRate,\n        uptime,\n        totalApiCalls,\n        apiCallsGrowth: 0,\n        storageUsed,\n        storageLimit,\n        storagePercent,\n        activeBots: activeBotsCount,\n        activeStrategies,\n        activeWebhooks,\n      };\n\n      return { success: true, data: metrics };\n    } catch (error) {\n      logger.error('Error getting system health metrics', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'SYSTEM_METRICS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Compute directory size safely (returns 0 if not found)\n   */\n  private async getDirectorySizeSafe(dirPath: string): Promise<number> {\n    try {\n      const stat = await fs.promises.stat(dirPath).catch(() => null as any);\n      if (!stat) return 0;\n      if (stat.isFile()) return stat.size;\n      if (!stat.isDirectory()) return 0;\n      let total = 0;\n      const entries = await fs.promises.readdir(dirPath);\n      for (const entry of entries) {\n        const full = path.join(dirPath, entry);\n        total += await this.getDirectorySizeSafe(full);\n      }\n      return total;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Get active alerts\n   */\n  async getActiveAlerts(tenantId: string): Promise<ServiceResponse<Alert[]>> {\n    try {\n      const alerts = await db\n        .select()\n        .from(ceoAlerts)\n        .where(and(eq(ceoAlerts.tenantId, tenantId), eq(ceoAlerts.status, 'active')))\n        .orderBy(desc(ceoAlerts.createdAt))\n        .limit(20);\n\n      // Transform decimal strings to numbers for client\n      const transformedAlerts = alerts.map((alert) => ({\n        ...alert,\n        currentValue: alert.currentValue ? parseFloat(alert.currentValue) : undefined,\n        previousValue: alert.previousValue ? parseFloat(alert.previousValue) : undefined,\n        changePercent: alert.changePercent ? parseFloat(alert.changePercent) : undefined,\n        threshold: alert.threshold ? parseFloat(alert.threshold) : undefined,\n      })) as Alert[];\n\n      return { success: true, data: transformedAlerts };\n    } catch (error) {\n      logger.error('Error getting active alerts', { error, tenantId });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'ALERTS_ERROR',\n      };\n    }\n  }\n\n  /**\n   * Save dashboard configuration\n   */\n  async saveDashboardConfig(\n    config: Partial<DashboardConfig> & { userId: string; tenantId: string }\n  ): Promise<ServiceResponse<DashboardConfig>> {\n    try {\n      // Check if config exists\n      const existing = await db\n        .select()\n        .from(ceoDashboardConfigs)\n        .where(\n          and(\n            eq(ceoDashboardConfigs.userId, config.userId),\n            eq(ceoDashboardConfigs.tenantId, config.tenantId)\n          )\n        )\n        .limit(1);\n\n      if (existing.length > 0) {\n        // Update existing - only update provided fields\n        const updateData: any = {\n          updatedAt: new Date(),\n        };\n\n        if (config.displayName !== undefined) updateData.displayName = config.displayName;\n        if (config.theme) updateData.theme = config.theme;\n        if (config.defaultDateRange) updateData.defaultDateRange = config.defaultDateRange;\n        if (config.refreshInterval !== undefined) updateData.refreshInterval = config.refreshInterval;\n        if (config.currency) updateData.currency = config.currency;\n        if (config.emailAlerts !== undefined) updateData.emailAlerts = config.emailAlerts;\n        if (config.pushAlerts !== undefined) updateData.pushAlerts = config.pushAlerts;\n\n        // Handle alertThresholds - merge with existing or use defaults\n        if (config.alertThresholds) {\n          const existingThresholds = existing[0].alertThresholds as any || {};\n          updateData.alertThresholds = {\n            revenueDropPercent: config.alertThresholds.revenueDropPercent ?? existingThresholds.revenueDropPercent ?? 10,\n            churnRatePercent: config.alertThresholds.churnRatePercent ?? existingThresholds.churnRatePercent ?? 5,\n            activeUsersDropPercent: config.alertThresholds.activeUsersDropPercent ?? existingThresholds.activeUsersDropPercent ?? 15,\n            errorRatePercent: config.alertThresholds.errorRatePercent ?? existingThresholds.errorRatePercent ?? 5,\n          };\n        }\n\n        const updated = await db\n          .update(ceoDashboardConfigs)\n          .set(updateData)\n          .where(eq(ceoDashboardConfigs.id, existing[0].id))\n          .returning();\n\n        return { success: true, data: updated[0] as DashboardConfig };\n      } else {\n        // Insert new - provide all required defaults\n        const defaultThresholds = {\n          revenueDropPercent: 10,\n          churnRatePercent: 5,\n          activeUsersDropPercent: 15,\n          errorRatePercent: 5,\n        };\n\n        const alertThresholds = config.alertThresholds ? {\n          revenueDropPercent: config.alertThresholds.revenueDropPercent ?? defaultThresholds.revenueDropPercent,\n          churnRatePercent: config.alertThresholds.churnRatePercent ?? defaultThresholds.churnRatePercent,\n          activeUsersDropPercent: config.alertThresholds.activeUsersDropPercent ?? defaultThresholds.activeUsersDropPercent,\n          errorRatePercent: config.alertThresholds.errorRatePercent ?? defaultThresholds.errorRatePercent,\n        } : defaultThresholds;\n\n        const created = await db\n          .insert(ceoDashboardConfigs)\n          .values({\n            userId: config.userId,\n            tenantId: config.tenantId,\n            displayName: config.displayName,\n            theme: config.theme || 'light',\n            defaultDateRange: config.defaultDateRange || '30d',\n            refreshInterval: config.refreshInterval || 300,\n            currency: config.currency || 'BRL',\n            emailAlerts: config.emailAlerts ?? true,\n            pushAlerts: config.pushAlerts ?? true,\n            alertThresholds,\n          })\n          .returning();\n\n        return { success: true, data: created[0] as DashboardConfig };\n      }\n    } catch (error) {\n      logger.error('Error saving dashboard config', { error, config });\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 'CONFIG_SAVE_ERROR',\n      };\n    }\n  }\n\n  // ============================================================================\n  // Private Helper Methods\n  // ============================================================================\n\n  /**\n   * Calculate date range from options\n   */\n  private calculateDateRange(options: DashboardQueryOptions): { startDate: Date; endDate: Date } {\n    const endDate = options.endDate || new Date();\n    let startDate: Date;\n\n    if (options.startDate) {\n      startDate = options.startDate;\n    } else {\n      switch (options.dateRange) {\n        case '7d':\n          startDate = new Date(endDate.getTime() - 7 * 24 * 60 * 60 * 1000);\n          break;\n        case '90d':\n          startDate = new Date(endDate.getTime() - 90 * 24 * 60 * 60 * 1000);\n          break;\n        case '1y':\n          startDate = new Date(endDate.getTime() - 365 * 24 * 60 * 60 * 1000);\n          break;\n        case '30d':\n        default:\n          startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1000);\n          break;\n      }\n    }\n\n    return { startDate, endDate };\n  }\n\n  /**\n   * Calculate growth percentage\n   */\n  private calculateGrowth(current: number, previous: number): number {\n    if (previous === 0) return current > 0 ? 100 : 0;\n    return ((current - previous) / previous) * 100;\n  }\n}\n\n// Export singleton instance\nexport const ceoService = new CeoService();\nexport default ceoService;\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/types/ceo.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/utils/__tests__/metrics.util.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/ceo/utils/metrics.util.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/configurations/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/configurations/routes/configuration.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/configurations/schema/configurations.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/configurations/services/configuration.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/configurations/types/configuration.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/routes/analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/routes/department.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/routes/membership.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/schema/departments.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/services/analytics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/services/department.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/services/membership.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/types/department.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/departments/validation/department.validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/__tests__/storage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/__tests__/validators.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/routes/documents.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/routes/folders.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/routes/shares.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/schema/documents.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/services/documents.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/services/folders.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/types/documents.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/utils/storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/documents/utils/validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/routes/exchanges.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/schema/exchange-markets.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/schema/exchanges.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/services/__tests__/exchange.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":188,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Exchange Service Tests\n * Ensures critical exchange workflows are covered before enabling realtime pipelines\n */\n\nimport { describe, test, expect, beforeEach, mock } from 'bun:test';\n\nclass BadRequestError extends Error {}\nclass NotFoundError extends Error {}\n\nmock.module('@/utils/errors', () => ({\n  BadRequestError,\n  NotFoundError,\n}));\n\n/**\n * Encryption mocks (deterministic output for assertions)\n */\nconst encryptMock = mock((value: string) => `enc(${value})`);\nconst decryptMock = mock((value: string) =>\n  value.startsWith('enc(') ? value.slice(4, -1) : value\n);\n\nmock.module('../../utils/encryption', () => ({\n  encrypt: encryptMock,\n  decrypt: decryptMock,\n}));\n\n/**\n * Database mock (Drizzle-like chainable API)\n */\ntype SelectResult = Array<Record<string, any>>;\n\nlet selectResult: SelectResult = [];\nlet insertedValues: Record<string, any> | null = null;\nlet updateValues: Record<string, any> | null = null;\nlet updateReturningRows: Array<Record<string, any>> = [{ id: 'connection-1' }];\n\nconst dbMock = {\n  insert: mock(() => ({\n    values: (values: Record<string, any>) => {\n      insertedValues = values;\n      return {\n        returning: () => Promise.resolve([{ id: 'connection-1', ...values }]),\n      };\n    },\n  })),\n  update: mock(() => ({\n    set: (values: Record<string, any>) => {\n      updateValues = values;\n      return {\n        where: () => ({\n          returning: () => Promise.resolve(updateReturningRows),\n        }),\n      };\n    },\n  })),\n  select: mock(() => ({\n    from: () => ({\n      where: () => {\n        const promise = Promise.resolve(selectResult);\n        (promise as any).limit = (limit: number) =>\n          Promise.resolve(selectResult.slice(0, limit));\n        return promise as any;\n      },\n    }),\n  })),\n};\n\nmock.module('@/db', () => ({\n  db: dbMock,\n}));\n\n/**\n * CCXT Mocks\n */\nconst loadMarketsMock = mock(async () => {});\nconst fetchBalanceMock = mock(async () => ({\n  info: {},\n  BTC: { total: 1, free: 0.6, used: 0.4 },\n  ETH: { total: 0, free: 0, used: 0 },\n}));\nconst fetchTickerMock = mock(async (_exchange: string, symbol: string) => ({\n  symbol,\n  timestamp: 1700000000000,\n  datetime: '2023-11-14T00:00:00Z',\n  high: 102,\n  low: 98,\n  bid: 99.5,\n  ask: 100.5,\n  last: 100,\n  close: 100,\n  baseVolume: 12,\n  quoteVolume: 1200,\n  percentage: 1.25,\n}));\nconst fetchPositionsMock = mock(async () => [\n  {\n    symbol: 'BTC/USDT',\n    id: 'pos-1',\n    timestamp: 1700000000000,\n    datetime: '2023-11-14T00:00:00Z',\n    contracts: 3,\n    contractSize: 1,\n    side: 'long',\n    notional: 3000,\n    leverage: 2,\n    unrealizedPnl: 150,\n    realizedPnl: 50,\n    collateral: 1500,\n    entryPrice: 980,\n    markPrice: 1005,\n    liquidationPrice: 800,\n    marginMode: 'cross',\n    hedged: false,\n    maintenanceMargin: 60,\n    maintenanceMarginPercentage: 2,\n    initialMargin: 150,\n    initialMarginPercentage: 5,\n    marginRatio: 0.1,\n    lastUpdateTimestamp: 1700000000500,\n    lastPrice: 1005,\n    stopLossPrice: 930,\n    takeProfitPrice: 1100,\n    percentage: 5.1,\n    info: {},\n  },\n  {\n    symbol: 'ETH/USDT',\n    contracts: 0,\n  },\n]);\n\nlet fetchPositionsSupported = true;\n\nfunction createExchangeClass(id: string) {\n  return class MockExchange {\n    public id = id;\n    public config: any;\n    public has = {\n      fetchPositions: fetchPositionsSupported,\n    };\n\n    constructor(config: any) {\n      this.config = config;\n    }\n\n    async loadMarkets() {\n      await loadMarketsMock(id);\n    }\n\n    async fetchBalance() {\n      return fetchBalanceMock(id);\n    }\n\n    async fetchTicker(symbol: string) {\n      return fetchTickerMock(id, symbol);\n    }\n\n    async fetchPositions(symbols?: string[]) {\n      return fetchPositionsMock(id, symbols);\n    }\n\n    async close() {\n      // No-op for mocks\n    }\n  };\n}\n\nconst ccxtMock = {\n  exchanges: ['binance', 'kraken'],\n  binance: createExchangeClass('binance'),\n  kraken: createExchangeClass('kraken'),\n  __mocks: {\n    loadMarketsMock,\n    fetchBalanceMock,\n    fetchTickerMock,\n    fetchPositionsMock,\n  },\n};\n\nmock.module('ccxt', () => ({\n  default: ccxtMock,\n}));\n\n// Import after mock configuration to ensure modules receive mocks\nconst { ExchangeService } = await import('../exchange.service');\nconst { db } = await import('@/db');\nconst ccxt = (await import('ccxt')).default as any;\n\ndescribe('ExchangeService - critical workflows', () => {\n  beforeEach(() => {\n    // Reset shared state between tests\n    insertedValues = null;\n    updateValues = null;\n    selectResult = [];\n    fetchPositionsSupported = true;\n    updateReturningRows = [{ id: 'connection-1' }];\n\n    encryptMock.mockReset();\n    encryptMock.mockImplementation((value: string) => `enc(${value})`);\n    decryptMock.mockReset();\n    decryptMock.mockImplementation((value: string) =>\n      value.startsWith('enc(') ? value.slice(4, -1) : value\n    );\n\n    loadMarketsMock.mockReset();\n    fetchBalanceMock.mockReset();\n    fetchBalanceMock.mockImplementation(async () => ({\n      info: {},\n      BTC: { total: 1, free: 0.6, used: 0.4 },\n      ETH: { total: 0, free: 0, used: 0 },\n    }));\n    fetchTickerMock.mockReset();\n    fetchTickerMock.mockImplementation(async (_exchange: string, symbol: string) => ({\n      symbol,\n      timestamp: 1700000000000,\n      datetime: '2023-11-14T00:00:00Z',\n      high: 102,\n      low: 98,\n      bid: 99.5,\n      ask: 100.5,\n      last: 100,\n      close: 100,\n      baseVolume: 12,\n      quoteVolume: 1200,\n      percentage: 1.25,\n    }));\n    fetchPositionsMock.mockReset();\n    fetchPositionsMock.mockImplementation(async () => [\n      {\n        symbol: 'BTC/USDT',\n        id: 'pos-1',\n        timestamp: 1700000000000,\n        datetime: '2023-11-14T00:00:00Z',\n        contracts: 3,\n        contractSize: 1,\n        side: 'long',\n        notional: 3000,\n        leverage: 2,\n        unrealizedPnl: 150,\n        realizedPnl: 50,\n        collateral: 1500,\n        entryPrice: 980,\n        markPrice: 1005,\n        liquidationPrice: 800,\n        marginMode: 'cross',\n        hedged: false,\n        maintenanceMargin: 60,\n        maintenanceMarginPercentage: 2,\n        initialMargin: 150,\n        initialMarginPercentage: 5,\n        marginRatio: 0.1,\n        lastUpdateTimestamp: 1700000000500,\n        lastPrice: 1005,\n        stopLossPrice: 930,\n        takeProfitPrice: 1100,\n        percentage: 5.1,\n        info: {},\n      },\n      { symbol: 'ETH/USDT', contracts: 0 },\n    ]);\n\n    dbMock.insert.mockReset();\n    dbMock.insert.mockImplementation(() => ({\n      values: (values: Record<string, any>) => {\n        insertedValues = values;\n        return {\n          returning: () => Promise.resolve([{ id: 'connection-1', ...values }]),\n        };\n      },\n    }));\n\n    dbMock.update.mockReset();\n    dbMock.update.mockImplementation(() => ({\n      set: (values: Record<string, any>) => {\n        updateValues = values;\n        return {\n          where: () => ({\n            returning: () => Promise.resolve(updateReturningRows),\n          }),\n        };\n      },\n    }));\n\n    dbMock.select.mockReset();\n    dbMock.select.mockImplementation(() => ({\n      from: () => ({\n        where: () => {\n          const promise = Promise.resolve(selectResult);\n          (promise as any).limit = (limit: number) =>\n            Promise.resolve(selectResult.slice(0, limit));\n          return promise as any;\n        },\n      }),\n    }));\n  });\n\n  test('getSupportedExchanges returns sorted list', () => {\n    ccxt.exchanges = ['kraken', 'binance', 'coinbasepro'];\n\n    const result = ExchangeService.getSupportedExchanges();\n\n    expect(result).toEqual(['binance', 'coinbasepro', 'kraken']);\n  });\n\n  test('createCCXTInstance builds configured exchange client', () => {\n    const instance = ExchangeService.createCCXTInstance('binance', {\n      apiKey: 'key',\n      apiSecret: 'secret',\n      apiPassword: 'pass',\n      sandbox: true,\n    });\n\n    expect(instance).toBeInstanceOf(ccxt.binance);\n    expect(instance.config).toEqual({\n      apiKey: 'key',\n      secret: 'secret',\n      enableRateLimit: true,\n      password: 'pass',\n      sandbox: true,\n    });\n  });\n\n  test('createCCXTInstance rejects unsupported exchange', () => {\n    expect(() =>\n      ExchangeService.createCCXTInstance('unsupported' as any, {\n        apiKey: 'k',\n        apiSecret: 's',\n        sandbox: false,\n      })\n    ).toThrow(BadRequestError);\n  });\n\n  test('createConnection stores encrypted credentials after verification', async () => {\n    const data = {\n      userId: 'user-1',\n      tenantId: 'tenant-1',\n      exchangeId: 'binance' as const,\n      apiKey: 'plain-key',\n      apiSecret: 'plain-secret',\n      apiPassword: 'plain-pass',\n      sandbox: true,\n      enableTrading: true,\n      enableWithdrawal: false,\n    };\n\n    const connection = await ExchangeService.createConnection(data);\n\n    expect(fetchBalanceMock).toHaveBeenCalledTimes(1);\n    expect(insertedValues).toMatchObject({\n      apiKey: 'enc(plain-key)',\n      apiSecret: 'enc(plain-secret)',\n      apiPassword: 'enc(plain-pass)',\n      sandbox: true,\n      enableTrading: true,\n      enableWithdrawal: false,\n      isVerified: true,\n      status: 'active',\n    });\n    expect(connection.id).toBe('connection-1');\n  });\n\n  test('createConnection throws BadRequestError when verification fails', async () => {\n    fetchBalanceMock.mockImplementationOnce(async () => {\n      throw new Error('invalid credentials');\n    });\n\n    await expect(\n      ExchangeService.createConnection({\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'key',\n        apiSecret: 'secret',\n        sandbox: false,\n      })\n    ).rejects.toThrow(BadRequestError);\n\n    expect(dbMock.insert).not.toHaveBeenCalled();\n  });\n\n  test('fetchBalances maps positive totals and updates cache', async () => {\n    selectResult = [\n      {\n        id: 'connection-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'enc(plain-key)',\n        apiSecret: 'enc(plain-secret)',\n        sandbox: false,\n      },\n    ];\n\n    const balances = await ExchangeService.fetchBalances('connection-1', 'user-1', 'tenant-1');\n\n    expect(balances).toEqual([\n      {\n        currency: 'BTC',\n        free: 0.6,\n        used: 0.4,\n        total: 1,\n      },\n    ]);\n    expect(updateValues?.balances).toEqual(balances);\n  });\n\n  test('fetchTicker normalizes ticker payload', async () => {\n    selectResult = [\n      {\n        id: 'connection-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'enc(key)',\n        apiSecret: 'enc(secret)',\n        sandbox: false,\n      },\n    ];\n\n    const ticker = await ExchangeService.fetchTicker('connection-1', 'user-1', 'tenant-1', 'BTC/USDT');\n\n    expect(ticker).toMatchObject({\n      symbol: 'BTC/USDT',\n      timestamp: 1700000000000,\n      datetime: '2023-11-14T00:00:00Z',\n      high: 102,\n      low: 98,\n      bid: 99.5,\n      ask: 100.5,\n      last: 100,\n      close: 100,\n      baseVolume: 12,\n      quoteVolume: 1200,\n      percentage: 1.25,\n    });\n  });\n\n  test('fetchPositions returns only active contracts', async () => {\n    selectResult = [\n      {\n        id: 'connection-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'enc(key)',\n        apiSecret: 'enc(secret)',\n        sandbox: false,\n      },\n    ];\n\n    const positions = await ExchangeService.fetchPositions('connection-1', 'user-1', 'tenant-1');\n\n    expect(positions).toHaveLength(1);\n    expect(positions[0]).toMatchObject({\n      symbol: 'BTC/USDT',\n      side: 'long',\n      contracts: 3,\n      leverage: 2,\n      unrealizedPnl: 150,\n      takeProfitPrice: 1100,\n    });\n  });\n\n  test('fetchPositions rejects when exchange lacks fetchPositions capability', async () => {\n    fetchPositionsSupported = false;\n    selectResult = [\n      {\n        id: 'connection-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'enc(key)',\n        apiSecret: 'enc(secret)',\n        sandbox: false,\n      },\n    ];\n\n    await expect(\n      ExchangeService.fetchPositions('connection-1', 'user-1', 'tenant-1')\n    ).rejects.toThrow(BadRequestError);\n  });\n\n  test('updateConnection re-encrypts and verifies when credentials change', async () => {\n    selectResult = [\n      {\n        id: 'connection-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'enc(old-key)',\n        apiSecret: 'enc(old-secret)',\n        sandbox: false,\n        enableTrading: true,\n      },\n    ];\n    updateReturningRows = [\n      {\n        id: 'connection-1',\n        apiKey: 'enc(new-key)',\n        apiSecret: 'enc(old-secret)',\n        enableTrading: false,\n        status: 'active',\n        isVerified: true,\n      },\n    ];\n\n    const updated = await ExchangeService.updateConnection(\n      'connection-1',\n      'user-1',\n      'tenant-1',\n      {\n        apiKey: 'new-key',\n        enableTrading: false,\n      }\n    );\n\n    expect(fetchBalanceMock).toHaveBeenCalledTimes(1);\n    expect(encryptMock).toHaveBeenCalledWith('new-key');\n    expect(updateValues).toMatchObject({\n      apiKey: 'enc(new-key)',\n      enableTrading: false,\n      isVerified: true,\n      status: 'active',\n    });\n    expect(updated).toMatchObject({\n      id: 'connection-1',\n      apiKey: 'enc(new-key)',\n      enableTrading: false,\n    });\n  });\n\n  test('updateConnection throws NotFound when update returns no record', async () => {\n    selectResult = [\n      {\n        id: 'connection-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        exchangeId: 'binance',\n        apiKey: 'enc(old-key)',\n        apiSecret: 'enc(old-secret)',\n        sandbox: false,\n      },\n    ];\n    updateReturningRows = [];\n\n    await expect(\n      ExchangeService.updateConnection('connection-1', 'user-1', 'tenant-1', {\n        enableTrading: true,\n      })\n    ).rejects.toThrow(NotFoundError);\n  });\n\n  test('getUserConnections returns active connections', async () => {\n    selectResult = [\n      { id: 'c1', userId: 'user-1', tenantId: 'tenant-1', status: 'active' },\n      { id: 'c2', userId: 'user-1', tenantId: 'tenant-1', status: 'active' },\n    ];\n\n    const result = await ExchangeService.getUserConnections('user-1', 'tenant-1');\n\n    expect(result).toEqual(selectResult);\n  });\n\n  test('getConnectionById throws when connection missing', async () => {\n    selectResult = [];\n\n    await expect(\n      ExchangeService.getConnectionById('missing', 'user-1', 'tenant-1')\n    ).rejects.toThrow(NotFoundError);\n  });\n\n  test('deleteConnection disables connection status', async () => {\n    updateReturningRows = [{ id: 'connection-1' }];\n\n    await ExchangeService.deleteConnection('connection-1', 'user-1', 'tenant-1');\n\n    expect(updateValues).toMatchObject({\n      status: 'disabled',\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/services/__tests__/market-data-methods.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/services/exchange-websocket-metadata.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/services/exchange-websocket.factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/services/exchange.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/types/exchanges.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/types/realtime.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/utils/encryption.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/utils/normalizers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/websocket/adapters/binance-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/websocket/adapters/coinbase-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/exchanges/websocket/adapters/kraken-adapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timestamp' is defined but never used. Allowed unused args must match /^_/u.","line":203,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":203,"endColumn":74},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timestamp' is defined but never used. Allowed unused args must match /^_/u.","line":208,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":208,"endColumn":74}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Kraken WebSocket adapter implementation\n * @module market-data/websocket/adapters/kraken\n */\n\nimport type { SubscriptionRequest, OrderBook, Trade, Ticker, Candle } from '@/modules/market-data/websocket/types';\nimport type { ConnectionConfig } from '@/modules/exchanges';\nimport { BaseExchangeAdapter } from '@/modules/market-data/websocket/base-adapter';\nimport type WebSocket from 'ws';\n\n/**\n * Kraken WebSocket adapter\n *\n * @see https://docs.kraken.com/websockets/\n */\nexport class KrakenAdapter extends BaseExchangeAdapter {\n  private channelIds: Map<number, { channel: string; symbol: string }> = new Map();\n\n  constructor(config: ConnectionConfig) {\n    super('kraken', config);\n  }\n\n  protected getWebSocketUrl(): string {\n    return this.config.url || 'wss://ws.kraken.com';\n  }\n\n  protected formatSubscriptionMessage(request: SubscriptionRequest): string {\n    const pair = this.formatPair(request.symbol);\n    const channelName = this.mapChannel(request.channel);\n\n    const subscription: any = {\n      name: channelName,\n    };\n\n    if (request.channel === 'candles' && request.params?.interval) {\n      subscription.interval = parseInt(request.params.interval as string);\n    }\n\n    if (request.channel === 'orderbook' && request.params?.depth) {\n      subscription.depth = request.params.depth;\n    }\n\n    return JSON.stringify({\n      event: 'subscribe',\n      pair: [pair],\n      subscription,\n    });\n  }\n\n  protected formatUnsubscriptionMessage(request: SubscriptionRequest): string {\n    const pair = this.formatPair(request.symbol);\n    const channelName = this.mapChannel(request.channel);\n\n    return JSON.stringify({\n      event: 'unsubscribe',\n      pair: [pair],\n      subscription: {\n        name: channelName,\n      },\n    });\n  }\n\n  protected parseMessage(data: WebSocket.Data): void {\n    const message = JSON.parse(data.toString());\n\n    // Handle system messages\n    if (message.event) {\n      this.handleSystemMessage(message);\n      return;\n    }\n\n    // Handle data messages (array format)\n    if (Array.isArray(message)) {\n      this.handleDataMessage(message);\n    }\n  }\n\n  private mapChannel(channel: string): string {\n    switch (channel) {\n      case 'ticker':\n        return 'ticker';\n      case 'trades':\n        return 'trade';\n      case 'orderbook':\n        return 'book';\n      case 'candles':\n        return 'ohlc';\n      default:\n        return channel;\n    }\n  }\n\n  private formatPair(symbol: string): string {\n    // Convert BTC/USDT to XBT/USDT (Kraken uses XBT instead of BTC)\n    const pair = symbol.replace('BTC', 'XBT');\n    // Remove slash: XBT/USDT -> XBTUSDT\n    return pair.replace('/', '');\n  }\n\n  private parsePair(krakenPair: string): string {\n    // Convert XBT/USD to BTC/USD\n    return krakenPair.replace('XBT', 'BTC');\n  }\n\n  private handleSystemMessage(message: any): void {\n    switch (message.event) {\n      case 'subscriptionStatus':\n        if (message.status === 'subscribed') {\n          this.channelIds.set(message.channelID, {\n            channel: message.subscription.name,\n            symbol: this.parsePair(message.pair),\n          });\n        }\n        break;\n      case 'error':\n        this.emitTypedEvent('error', {\n          code: 'KRAKEN_ERROR',\n          message: message.errorMessage || 'Unknown error',\n          exchange: this.exchangeId,\n          timestamp: Date.now(),\n          fatal: false,\n        });\n        break;\n    }\n  }\n\n  private handleDataMessage(message: any[]): void {\n    const channelId = message[0];\n    const data = message[1];\n    const channelInfo = this.channelIds.get(channelId);\n\n    if (!channelInfo) {\n      return;\n    }\n\n    const channelName = message[2];\n\n    switch (channelName) {\n      case 'ticker':\n        this.handleTicker(data, channelInfo.symbol);\n        break;\n      case 'trade':\n        this.handleTrades(data, channelInfo.symbol);\n        break;\n      case 'book-5':\n      case 'book-10':\n      case 'book-25':\n      case 'book-100':\n      case 'book-500':\n      case 'book-1000':\n        this.handleOrderBook(data, channelInfo.symbol);\n        break;\n      case 'ohlc':\n      case 'ohlc-1':\n      case 'ohlc-5':\n      case 'ohlc-15':\n      case 'ohlc-30':\n      case 'ohlc-60':\n      case 'ohlc-240':\n      case 'ohlc-1440':\n      case 'ohlc-10080':\n      case 'ohlc-21600':\n        this.handleCandle(data, channelInfo.symbol, channelName);\n        break;\n    }\n  }\n\n  private handleTicker(data: any, symbol: string): void {\n    const ticker: Ticker = {\n      symbol,\n      exchange: this.exchangeId,\n      timestamp: Date.now(),\n      last: parseFloat(data.c[0]),\n      bid: parseFloat(data.b[0]),\n      ask: parseFloat(data.a[0]),\n      high24h: parseFloat(data.h[1]),\n      low24h: parseFloat(data.l[1]),\n      volume24h: parseFloat(data.v[1]),\n      change24h: 0, // Calculate from open and close\n    };\n\n    this.emitTypedEvent('ticker', ticker);\n  }\n\n  private handleTrades(data: any[], symbol: string): void {\n    data.forEach((tradeData) => {\n      const trade: Trade = {\n        id: `${Date.now()}-${Math.random()}`,\n        symbol,\n        exchange: this.exchangeId,\n        timestamp: Math.floor(parseFloat(tradeData[2]) * 1000),\n        price: parseFloat(tradeData[0]),\n        amount: parseFloat(tradeData[1]),\n        side: tradeData[3] === 'b' ? 'buy' : 'sell',\n        takerOrMaker: tradeData[4] === 'm' ? 'maker' : 'taker',\n      };\n\n      this.emitTypedEvent('trade', trade);\n    });\n  }\n\n  private handleOrderBook(data: any, symbol: string): void {\n    const bids = (data.bs || data.b || []).map(([price, amount, timestamp]: [string, string, string]) => ({\n      price: parseFloat(price),\n      amount: parseFloat(amount),\n    }));\n\n    const asks = (data.as || data.a || []).map(([price, amount, timestamp]: [string, string, string]) => ({\n      price: parseFloat(price),\n      amount: parseFloat(amount),\n    }));\n\n    if (bids.length === 0 && asks.length === 0) {\n      return;\n    }\n\n    const orderbook: OrderBook = {\n      symbol,\n      exchange: this.exchangeId,\n      timestamp: Date.now(),\n      bids,\n      asks,\n    };\n\n    this.emitTypedEvent('orderbook', orderbook);\n  }\n\n  private handleCandle(data: any, symbol: string, channelName: string): void {\n    const intervalMatch = channelName.match(/ohlc-(\\d+)/);\n    const interval = intervalMatch ? intervalMatch[1] : '1';\n\n    const candle: Candle = {\n      symbol,\n      exchange: this.exchangeId,\n      timestamp: Math.floor(parseFloat(data[1]) * 1000),\n      timeframe: `${interval}m`,\n      open: parseFloat(data[2]),\n      high: parseFloat(data[3]),\n      low: parseFloat(data[4]),\n      close: parseFloat(data[5]),\n      volume: parseFloat(data[7]),\n    };\n\n    this.emitTypedEvent('candle', candle);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/budget.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/expense.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/invoice.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/ledger.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/payment.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/report.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/tax-jurisdiction.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/tax-report.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/routes/tax.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/budgets.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/expenses.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/invoices.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/ledger.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/payments.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/tax-jurisdiction.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/schema/tax.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/__mocks__/db.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/budget.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/expense.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/integration.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/invoice.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/ledger.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/__tests__/tax.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/budget.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/dunning.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/expense.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/gateway-selector.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/gateways/banco.gateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/gateways/infinitypay.gateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/gateways/stripe.gateway.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/integration.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/invoice.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/ledger.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/payment-gateway.base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/payment-processor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/payout-disbursement.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/report.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/tax-jurisdiction.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/tax-report.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/services/tax.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/types/payment.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/types/tax-jurisdiction.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/__tests__/calculations.estonia.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/__tests__/calculations.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/__tests__/validators.estonia.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/__tests__/validators.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/calculations.estonia.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/calculations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/validators.estonia.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/financial/utils/validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/presets/indicator-presets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/routes/indicators.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Timeframe' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Indicators API Routes V2\n * RESTful endpoints for indicator calculations and management\n * Refactored to use calculator-v2 (async) and updated services\n *\n * @module indicators/routes\n */\n\nimport { Elysia, t } from 'elysia';\nimport { indicatorsService } from '../services/indicators.service';\nimport { sessionGuard } from '../../auth/middleware/session.middleware';\nimport { getUserPrimaryTenantId } from '../../tenants/services/membership.service';\nimport { BadRequestError } from '../../../utils/errors';\nimport type {\n  CalculateIndicatorRequest,\n  BatchCalculateRequest,\n  CreatePresetRequest,\n  UpdatePresetRequest,\n  IndicatorType,\n  IndicatorCategory,\n  Timeframe,\n} from '../types/indicators.types';\n\n/**\n * Simple console logger\n */\nconst logger = {\n  debug: (msg: string, meta?: any) => console.log(`[DEBUG] ${msg}`, meta ? JSON.stringify(meta) : ''),\n  info: (msg: string, meta?: any) => console.log(`[INFO] ${msg}`, meta ? JSON.stringify(meta) : ''),\n  error: (msg: string, meta?: any) => console.error(`[ERROR] ${msg}`, meta ? JSON.stringify(meta) : ''),\n  warn: (msg: string, meta?: any) => console.warn(`[WARN] ${msg}`, meta ? JSON.stringify(meta) : ''),\n};\n\n/**\n * Enhanced validation schemas using Elysia's type system\n */\n\n// Timeframe enum\nconst TimeframeSchema = t.Union([\n  t.Literal('1m'),\n  t.Literal('3m'),\n  t.Literal('5m'),\n  t.Literal('15m'),\n  t.Literal('30m'),\n  t.Literal('1h'),\n  t.Literal('2h'),\n  t.Literal('4h'),\n  t.Literal('6h'),\n  t.Literal('12h'),\n  t.Literal('1d'),\n  t.Literal('1w'),\n  t.Literal('1M'),\n]);\n\n// Indicator category enum\nconst IndicatorCategorySchema = t.Union([\n  t.Literal('momentum'),\n  t.Literal('trend'),\n  t.Literal('volatility'),\n  t.Literal('volume'),\n  t.Literal('support_resistance'),\n]);\n\n// Base indicator configuration\nconst IndicatorConfigSchema = t.Object({\n  type: t.String({ minLength: 1, maxLength: 50 }),\n  period: t.Optional(t.Number({ minimum: 1, maximum: 500 })),\n  parameters: t.Optional(t.Record(t.String(), t.Any())),\n});\n\n// Calculate single indicator request\nconst CalculateRequestSchema = t.Object({\n  exchangeId: t.String({ minLength: 1, maxLength: 255 }),\n  symbol: t.String({ minLength: 1, maxLength: 50, pattern: '^[A-Z0-9]+/[A-Z0-9]+$' }), // e.g., BTC/USDT\n  timeframe: TimeframeSchema,\n  indicatorType: t.String({ minLength: 1, maxLength: 50 }),\n  configuration: IndicatorConfigSchema,\n  limit: t.Optional(t.Number({ minimum: 10, maximum: 1000, default: 100 })),\n  useCache: t.Optional(t.Boolean({ default: true })),\n});\n\n// Batch calculate request\nconst BatchCalculateRequestSchema = t.Object({\n  exchangeId: t.String({ minLength: 1, maxLength: 255 }),\n  symbol: t.String({ minLength: 1, maxLength: 50, pattern: '^[A-Z0-9]+/[A-Z0-9]+$' }),\n  timeframe: TimeframeSchema,\n  indicators: t.Array(IndicatorConfigSchema, { minItems: 1, maxItems: 20 }),\n  limit: t.Optional(t.Number({ minimum: 10, maximum: 1000, default: 100 })),\n  useCache: t.Optional(t.Boolean({ default: true })),\n});\n\n// Create preset request\nconst CreatePresetRequestSchema = t.Object({\n  name: t.String({ minLength: 1, maxLength: 255 }),\n  description: t.Optional(t.String({ maxLength: 1000 })),\n  category: IndicatorCategorySchema,\n  indicatorType: t.String({ minLength: 1, maxLength: 50 }),\n  configuration: IndicatorConfigSchema,\n  isPublic: t.Optional(t.Boolean({ default: false })),\n  tags: t.Optional(t.Array(t.String({ maxLength: 50 }), { maxItems: 10 })),\n});\n\n// Update preset request\nconst UpdatePresetRequestSchema = t.Object({\n  name: t.Optional(t.String({ minLength: 1, maxLength: 255 })),\n  description: t.Optional(t.String({ maxLength: 1000 })),\n  configuration: t.Optional(IndicatorConfigSchema),\n  isPublic: t.Optional(t.Boolean()),\n  tags: t.Optional(t.Array(t.String({ maxLength: 50 }), { maxItems: 10 })),\n});\n\n// Clear cache request\nconst ClearCacheRequestSchema = t.Object({\n  exchangeId: t.Optional(t.String({ maxLength: 255 })),\n  symbol: t.Optional(t.String({ maxLength: 50 })),\n  indicatorType: t.Optional(t.String({ maxLength: 50 })),\n});\n\n// Query filters\nconst PresetFiltersSchema = t.Object({\n  category: t.Optional(IndicatorCategorySchema),\n  indicatorType: t.Optional(t.String({ maxLength: 50 })),\n});\n\n/**\n * Create Indicators Routes Plugin\n */\nexport const indicatorsRoutes = new Elysia({ prefix: '/indicators' })\n  /**\n   * GET /indicators/list\n   * List all available indicators with their configurations\n   */\n  .get('/list', async () => {\n    const indicators = [\n      {\n        type: 'sma',\n        name: 'Simple Moving Average',\n        category: 'trend',\n        description: 'Average of closing prices over a specified period',\n        parameters: {\n          period: { type: 'number', default: 20, min: 2, max: 500, description: 'Number of periods' },\n        },\n      },\n      {\n        type: 'ema',\n        name: 'Exponential Moving Average',\n        category: 'trend',\n        description: 'Weighted average giving more importance to recent prices',\n        parameters: {\n          period: { type: 'number', default: 20, min: 2, max: 500, description: 'Number of periods' },\n        },\n      },\n      {\n        type: 'rsi',\n        name: 'Relative Strength Index',\n        category: 'momentum',\n        description: 'Momentum oscillator measuring speed and change of price movements',\n        parameters: {\n          period: { type: 'number', default: 14, min: 2, max: 100, description: 'Number of periods' },\n        },\n      },\n      {\n        type: 'macd',\n        name: 'MACD',\n        category: 'momentum',\n        description: 'Trend-following momentum indicator',\n        parameters: {\n          fastPeriod: { type: 'number', default: 12, min: 2, max: 100, description: 'Fast EMA period' },\n          slowPeriod: { type: 'number', default: 26, min: 2, max: 100, description: 'Slow EMA period' },\n          signalPeriod: { type: 'number', default: 9, min: 2, max: 100, description: 'Signal line period' },\n        },\n      },\n      {\n        type: 'bb',\n        name: 'Bollinger Bands',\n        category: 'volatility',\n        description: 'Volatility bands placed above and below a moving average',\n        parameters: {\n          period: { type: 'number', default: 20, min: 2, max: 500, description: 'SMA period' },\n          stdDev: { type: 'number', default: 2, min: 0.5, max: 5, description: 'Standard deviations' },\n        },\n      },\n      {\n        type: 'atr',\n        name: 'Average True Range',\n        category: 'volatility',\n        description: 'Volatility indicator showing market volatility',\n        parameters: {\n          period: { type: 'number', default: 14, min: 2, max: 100, description: 'Number of periods' },\n        },\n      },\n      {\n        type: 'obv',\n        name: 'On Balance Volume',\n        category: 'volume',\n        description: 'Momentum indicator using volume flow',\n        parameters: {},\n      },\n      {\n        type: 'stoch',\n        name: 'Stochastic Oscillator',\n        category: 'momentum',\n        description: 'Momentum indicator comparing closing price to price range',\n        parameters: {\n          period: { type: 'number', default: 14, min: 2, max: 100, description: 'Number of periods' },\n          kPeriod: { type: 'number', default: 3, min: 1, max: 50, description: '%K smoothing' },\n          dPeriod: { type: 'number', default: 3, min: 1, max: 50, description: '%D smoothing' },\n        },\n      },\n    ];\n\n    return {\n      success: true,\n      data: indicators,\n      count: indicators.length,\n      timestamp: new Date().toISOString(),\n    };\n  })\n\n  /**\n   * Calculate single indicator\n   * POST /indicators/calculate\n   */\n  .post(\n    '/calculate',\n    async ({ body, set }) => {\n      try {\n        logger.info('Calculating indicator', {\n          type: body.indicatorType,\n          symbol: body.symbol,\n          timeframe: body.timeframe,\n        });\n\n        const result = await indicatorsService.calculate(body as CalculateIndicatorRequest);\n\n        if (!result.success) {\n          set.status = 400;\n          return {\n            success: false,\n            error: result.error || 'Calculation failed',\n          };\n        }\n\n        return {\n          success: true as const,\n          data: result.data,\n          fromCache: result.fromCache || false,\n          calculationTime: result.calculationTime || 0,\n        };\n      } catch (error) {\n        logger.error('Indicator calculation failed', { error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      body: CalculateRequestSchema,\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          data: t.Any(),\n          fromCache: t.Optional(t.Boolean()),\n          calculationTime: t.Number(),\n        }),\n        400: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Indicators'],\n        summary: 'Calculate single indicator',\n        description:\n          'Calculate a technical indicator for a specific symbol and timeframe. ' +\n          'Results are cached for improved performance. Supports 106 indicators from @ixjb94/indicators library.',\n      },\n    }\n  )\n\n  /**\n   * Calculate multiple indicators in batch\n   * POST /indicators/batch\n   */\n  .post(\n    '/batch',\n    async ({ body, set }) => {\n      try {\n        logger.info('Batch calculating indicators', {\n          symbol: body.symbol,\n          timeframe: body.timeframe,\n          count: body.indicators.length,\n        });\n\n        const result = await indicatorsService.calculateBatch(body as BatchCalculateRequest);\n\n        return {\n          success: result.success,\n          results: result.results,\n          totalCalculationTime: result.totalCalculationTime,\n        };\n      } catch (error) {\n        logger.error('Batch calculation failed', { error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n          results: [],\n          totalCalculationTime: 0,\n        };\n      }\n    },\n    {\n      body: BatchCalculateRequestSchema,\n      response: {\n        200: t.Object({\n          success: t.Boolean(),\n          results: t.Array(\n            t.Object({\n              indicatorType: t.String(),\n              data: t.Optional(t.Any()),\n              error: t.Optional(t.String()),\n              fromCache: t.Optional(t.Boolean()),\n            })\n          ),\n          totalCalculationTime: t.Number(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n          results: t.Array(t.Any()),\n          totalCalculationTime: t.Number(),\n        }),\n      },\n      detail: {\n        tags: ['Indicators'],\n        summary: 'Calculate multiple indicators',\n        description:\n          'Calculate multiple technical indicators in a single request for improved performance. ' +\n          'Up to 20 indicators can be calculated simultaneously.',\n      },\n    }\n  )\n\n  /**\n   * Clear cache\n   * DELETE /indicators/cache\n   */\n  .delete(\n    '/cache',\n    async ({ body, set }) => {\n      try {\n        logger.info('Clearing indicator cache', body || {});\n\n        await indicatorsService.clearCache(\n          body?.exchangeId,\n          body?.symbol,\n          body?.indicatorType as IndicatorType | undefined\n        );\n\n        return {\n          success: true,\n          message: 'Cache cleared successfully',\n        };\n      } catch (error) {\n        logger.error('Failed to clear cache', { error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      body: t.Optional(ClearCacheRequestSchema),\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          message: t.String(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Cache'],\n        summary: 'Clear indicator cache',\n        description:\n          'Clear cached indicator results with optional filters. ' +\n          'Filters can be combined to clear specific cache entries.',\n      },\n    }\n  )\n\n  /**\n   * Health check endpoint\n   * GET /indicators/health\n   */\n  .get(\n    '/health',\n    () => {\n      return {\n        status: 'healthy',\n        module: 'indicators',\n        version: '2.0.0',\n        library: '@ixjb94/indicators v1.2.4',\n        indicators: 106,\n        timestamp: new Date().toISOString(),\n      };\n    },\n    {\n      response: t.Object({\n        status: t.String(),\n        module: t.String(),\n        version: t.String(),\n        library: t.String(),\n        indicators: t.Number(),\n        timestamp: t.String(),\n      }),\n      detail: {\n        tags: ['Health'],\n        summary: 'Health check',\n        description: 'Check if the indicators module is operational.',\n      },\n    }\n  )\n\n  // ==================================================\n  // PROTECTED ROUTES (Require Authentication)\n  // ==================================================\n  .use(sessionGuard)\n\n  /**\n   * List indicator presets\n   * GET /indicators/presets\n   */\n  .get(\n    '/presets',\n    async ({ user, query, set }) => {\n      try {\n        const userId = user.id;\n        const tenantId = await getUserPrimaryTenantId(user.id);\n\n        if (!tenantId) {\n          throw new BadRequestError('User has no tenant membership');\n        }\n\n        const presets = await indicatorsService.getPresets(userId, tenantId, {\n          category: query.category as IndicatorCategory | undefined,\n          indicatorType: query.indicatorType as IndicatorType | undefined,\n        });\n\n        return {\n          success: true,\n          data: presets,\n          count: presets.length,\n        };\n      } catch (error) {\n        logger.error('Failed to get presets', { error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n          data: [],\n          count: 0,\n        };\n      }\n    },\n    {\n      query: PresetFiltersSchema,\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          data: t.Array(t.Any()),\n          count: t.Number(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n          data: t.Array(t.Any()),\n          count: t.Number(),\n        }),\n      },\n      detail: {\n        tags: ['Presets'],\n        summary: 'List indicator presets',\n        description:\n          'Get all indicator presets with optional filtering by category or indicator type. ' +\n          'Returns both public presets and user-specific private presets.',\n      },\n    }\n  )\n\n  /**\n   * Create new indicator preset\n   * POST /indicators/presets\n   */\n  .post(\n    '/presets',\n    async ({ user, body, set }) => {\n      try {\n        const userId = user.id;\n        const tenantId = await getUserPrimaryTenantId(user.id);\n\n        if (!tenantId) {\n          throw new BadRequestError('User has no tenant membership');\n        }\n\n        logger.info('Creating indicator preset', { name: body.name });\n\n        const preset = await indicatorsService.createPreset(\n          userId,\n          tenantId,\n          body as CreatePresetRequest\n        );\n\n        set.status = 201;\n        return {\n          success: true,\n          data: preset,\n        };\n      } catch (error) {\n        logger.error('Failed to create preset', { error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      body: CreatePresetRequestSchema,\n      response: {\n        201: t.Object({\n          success: t.Literal(true),\n          data: t.Any(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Presets'],\n        summary: 'Create indicator preset',\n        description:\n          'Create a new reusable indicator configuration preset. ' +\n          'Presets can be private (default) or public for sharing with other users.',\n      },\n    }\n  )\n\n  /**\n   * Get preset by ID\n   * GET /indicators/presets/:id\n   */\n  .get(\n    '/presets/:id',\n    async ({ params, set }) => {\n      try {\n        const preset = await indicatorsService.getPreset(params.id);\n\n        if (!preset) {\n          set.status = 404;\n          return {\n            success: false,\n            error: 'Preset not found',\n          };\n        }\n\n        return {\n          success: true,\n          data: preset,\n        };\n      } catch (error) {\n        logger.error('Failed to get preset', { presetId: params.id, error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      params: t.Object({\n        id: t.String({ format: 'uuid' }),\n      }),\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          data: t.Any(),\n        }),\n        404: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Presets'],\n        summary: 'Get indicator preset',\n        description: 'Retrieve a specific indicator preset by ID. Increments usage count.',\n      },\n    }\n  )\n\n  /**\n   * Update preset\n   * PATCH /indicators/presets/:id\n   */\n  .patch(\n    '/presets/:id',\n    async ({ user, params, body, set }) => {\n      try {\n        const userId = user.id;\n        const tenantId = await getUserPrimaryTenantId(user.id);\n\n        if (!tenantId) {\n          throw new BadRequestError('User has no tenant membership');\n        }\n\n        logger.info('Updating indicator preset', { id: params.id });\n\n        const preset = await indicatorsService.updatePreset(\n          params.id,\n          userId,\n          tenantId,\n          body as UpdatePresetRequest\n        );\n\n        return {\n          success: true,\n          data: preset,\n        };\n      } catch (error) {\n        logger.error('Failed to update preset', { presetId: params.id, error });\n        const status = error instanceof Error && error.message.includes('not found') ? 404 : 500;\n        set.status = status;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      params: t.Object({\n        id: t.String({ format: 'uuid' }),\n      }),\n      body: UpdatePresetRequestSchema,\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          data: t.Any(),\n        }),\n        404: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Presets'],\n        summary: 'Update indicator preset',\n        description: 'Update an existing indicator preset configuration. Requires ownership.',\n      },\n    }\n  )\n\n  /**\n   * Delete preset\n   * DELETE /indicators/presets/:id\n   */\n  .delete(\n    '/presets/:id',\n    async ({ user, params, set }) => {\n      try {\n        const userId = user.id;\n        const tenantId = await getUserPrimaryTenantId(user.id);\n\n        if (!tenantId) {\n          throw new BadRequestError('User has no tenant membership');\n        }\n\n        logger.info('Deleting indicator preset', { id: params.id });\n\n        await indicatorsService.deletePreset(params.id, userId, tenantId);\n\n        return {\n          success: true,\n          message: 'Preset deleted successfully',\n        };\n      } catch (error) {\n        logger.error('Failed to delete preset', { presetId: params.id, error });\n        const status = error instanceof Error && error.message.includes('not found') ? 404 : 500;\n        set.status = status;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      params: t.Object({\n        id: t.String({ format: 'uuid' }),\n      }),\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          message: t.String(),\n        }),\n        404: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Presets'],\n        summary: 'Delete indicator preset',\n        description: 'Delete an indicator preset. Requires ownership.',\n      },\n    }\n  )\n\n  /**\n   * Get usage statistics\n   * GET /indicators/statistics\n   */\n  .get(\n    '/statistics',\n    async ({ user, set }) => {\n      try {\n        const userId = user.id;\n        const tenantId = await getUserPrimaryTenantId(user.id);\n\n        if (!tenantId) {\n          throw new BadRequestError('User has no tenant membership');\n        }\n\n        const stats = await indicatorsService.getStatistics(userId, tenantId);\n\n        return {\n          success: true,\n          data: stats,\n        };\n      } catch (error) {\n        logger.error('Failed to get statistics', { error });\n        set.status = 500;\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Internal server error',\n        };\n      }\n    },\n    {\n      response: {\n        200: t.Object({\n          success: t.Literal(true),\n          data: t.Object({\n            totalCalculations: t.Number(),\n            cacheHitRate: t.Number(),\n            averageCalculationTime: t.Number(),\n            mostUsedIndicators: t.Array(\n              t.Object({\n                type: t.String(),\n                count: t.Number(),\n              })\n            ),\n          }),\n        }),\n        500: t.Object({\n          success: t.Literal(false),\n          error: t.String(),\n        }),\n      },\n      detail: {\n        tags: ['Statistics'],\n        summary: 'Get usage statistics',\n        description:\n          'Retrieve indicator calculation statistics and performance metrics. ' +\n          'Includes cache hit rate, average calculation time, and most used indicators.',\n      },\n    }\n  );\n\n/**\n * Export types for route handlers\n */\nexport type IndicatorsRoutes = typeof indicatorsRoutes;\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/schema/indicators.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/services/indicator-factory.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IndicatorType' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'INDICATOR_CATEGORY_MAP' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":48,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Indicator Factory Service V2\n * Simplified factory pattern using calculator-v2 (async)\n * Provides type-safe wrappers with metadata for key indicators\n *\n * @module indicators/services/indicator-factory\n */\n\nimport type {\n  BaseIndicatorConfig,\n  IndicatorType,\n  IndicatorResult,\n  IndicatorCategory,\n  OHLCVData,\n  RSIConfig,\n  RSIResult,\n  MACDConfig,\n  MACDResult,\n  BollingerBandsConfig,\n  BollingerBandsResult,\n  ATRConfig,\n  ATRResult,\n  SMAConfig,\n  SMAResult,\n  EMAConfig,\n  EMAResult,\n  VWAPConfig,\n  VWAPResult,\n} from '../types/indicators.types';\n\n// Import custom indicator configs and results\nimport type {\n  SuperTrendConfig,\n  SuperTrendResult as SuperTrendResultType,\n  IchimokuConfig,\n  IchimokuResult as IchimokuResultType,\n  PivotPointsConfig,\n  PivotPointsResult as PivotPointsResultType,\n  FibonacciRetracementConfig,\n  FibonacciRetracementResult as FibonacciRetracementResultType,\n} from '../types/crypto-indicators.types';\n\nimport * as Calculator from '../utils/calculator-v2';\n\n/**\n * Indicator category mapping\n */\nconst INDICATOR_CATEGORY_MAP: Record<string, IndicatorCategory> = {\n  RSI: 'momentum',\n  MACD: 'momentum',\n  BollingerBands: 'volatility',\n  ATR: 'volatility',\n  SMA: 'trend',\n  EMA: 'trend',\n  VWAP: 'volume',\n};\n\n/**\n * Indicator Factory for type-safe indicator creation\n * All methods are async to work with calculator-v2\n */\nexport class IndicatorFactory {\n  /**\n   * Calculate RSI (Relative Strength Index)\n   */\n  static async calculateRSI(data: OHLCVData[], config: RSIConfig): Promise<IndicatorResult<RSIResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateRSI(data, config.period);\n    const latestValue = Calculator.getLatestValue(values);\n\n    const result: RSIResult = {\n      rsi: latestValue || 0,\n      overbought: latestValue ? latestValue > 70 : false,\n      oversold: latestValue ? latestValue < 30 : false,\n    };\n\n    return {\n      type: 'RSI',\n      category: 'momentum',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate MACD (Moving Average Convergence Divergence)\n   */\n  static async calculateMACD(data: OHLCVData[], config: MACDConfig): Promise<IndicatorResult<MACDResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateMACD(data, config.fastPeriod, config.slowPeriod, config.signalPeriod);\n\n    // Extract latest values from arrays\n    const latestMACD = Calculator.getLatestValue(values.macd);\n    const latestSignal = Calculator.getLatestValue(values.signal);\n    const latestHistogram = Calculator.getLatestValue(values.histogram);\n\n    // Detect crossover by comparing last 2 values\n    let crossover: 'bullish' | 'bearish' | null = null;\n    if (values.macd.length >= 2 && values.signal.length >= 2) {\n      const prevMACD = values.macd[values.macd.length - 2];\n      const prevSignal = values.signal[values.signal.length - 2];\n\n      if (prevMACD < prevSignal && latestMACD! > latestSignal!) {\n        crossover = 'bullish';\n      } else if (prevMACD > prevSignal && latestMACD! < latestSignal!) {\n        crossover = 'bearish';\n      }\n    }\n\n    const result: MACDResult = {\n      macd: latestMACD || 0,\n      signal: latestSignal || 0,\n      histogram: latestHistogram || 0,\n      crossover,\n    };\n\n    return {\n      type: 'MACD',\n      category: 'momentum',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        parameters: {\n          fastPeriod: config.fastPeriod,\n          slowPeriod: config.slowPeriod,\n          signalPeriod: config.signalPeriod,\n        },\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate Bollinger Bands\n   */\n  static async calculateBollingerBands(\n    data: OHLCVData[],\n    config: BollingerBandsConfig\n  ): Promise<IndicatorResult<BollingerBandsResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateBBands(data, config.period, config.stdDevMultiplier);\n\n    const latestUpper = Calculator.getLatestValue(values.upper);\n    const latestMiddle = Calculator.getLatestValue(values.middle);\n    const latestLower = Calculator.getLatestValue(values.lower);\n    const currentPrice = data[data.length - 1]?.close || 0;\n\n    // Calculate bandwidth: (upper - lower) / middle\n    const bandwidth = latestMiddle ? (latestUpper! - latestLower!) / latestMiddle : 0;\n\n    // Calculate %B: (price - lower) / (upper - lower)\n    const percentB = (latestUpper! - latestLower!) !== 0\n      ? (currentPrice - latestLower!) / (latestUpper! - latestLower!)\n      : 0.5;\n\n    const result: BollingerBandsResult = {\n      upper: latestUpper || 0,\n      middle: latestMiddle || 0,\n      lower: latestLower || 0,\n      bandwidth,\n      percentB,\n      squeeze: bandwidth < 0.1, // Squeeze when bandwidth is low\n    };\n\n    return {\n      type: 'BollingerBands',\n      category: 'volatility',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        parameters: { stdDevMultiplier: config.stdDevMultiplier },\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate ATR (Average True Range)\n   */\n  static async calculateATR(data: OHLCVData[], config: ATRConfig): Promise<IndicatorResult<ATRResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateATR(data, config.period);\n    const latestValue = Calculator.getLatestValue(values);\n    const currentPrice = data[data.length - 1]?.close || 1;\n    const atrPercent = latestValue ? (latestValue / currentPrice) * 100 : 0;\n\n    let volatility: 'low' | 'normal' | 'high' | 'extreme';\n    if (atrPercent > 5) volatility = 'extreme';\n    else if (atrPercent > 3) volatility = 'high';\n    else if (atrPercent > 1) volatility = 'normal';\n    else volatility = 'low';\n\n    const result: ATRResult = {\n      atr: latestValue || 0,\n      atrPercent,\n      volatility,\n    };\n\n    return {\n      type: 'ATR',\n      category: 'volatility',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate SMA (Simple Moving Average)\n   */\n  static async calculateSMA(data: OHLCVData[], config: SMAConfig): Promise<IndicatorResult<SMAResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateSMA(data, config.period);\n    const latestValue = Calculator.getLatestValue(values);\n    const currentPrice = data[data.length - 1]?.close || 0;\n\n    const result: SMAResult = {\n      sma: latestValue || 0,\n      trend: Calculator.determineTrend(values),\n      distance: currentPrice - (latestValue || 0),\n      distancePercent: Calculator.calculatePercentDiff(currentPrice, latestValue || currentPrice),\n    };\n\n    return {\n      type: 'SMA',\n      category: 'trend',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate EMA (Exponential Moving Average)\n   */\n  static async calculateEMA(data: OHLCVData[], config: EMAConfig): Promise<IndicatorResult<EMAResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateEMA(data, config.period);\n    const latestValue = Calculator.getLatestValue(values);\n    const currentPrice = data[data.length - 1]?.close || 0;\n\n    const result: EMAResult = {\n      ema: latestValue || 0,\n      trend: Calculator.determineTrend(values),\n      distance: currentPrice - (latestValue || 0),\n      distancePercent: Calculator.calculatePercentDiff(currentPrice, latestValue || currentPrice),\n    };\n\n    return {\n      type: 'EMA',\n      category: 'trend',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate VWAP (Volume Weighted Average Price)\n   */\n  static async calculateVWAP(data: OHLCVData[], config: VWAPConfig): Promise<IndicatorResult<VWAPResult>> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateVWAP(data, config.period || 14);\n    const latestValue = Calculator.getLatestValue(values);\n    const currentPrice = data[data.length - 1]?.close || 0;\n\n    const distance = currentPrice - (latestValue || 0);\n    const distancePercent = Calculator.calculatePercentDiff(currentPrice, latestValue || currentPrice);\n\n    let position: 'above' | 'below' | 'at';\n    if (Math.abs(distancePercent) < 0.1) position = 'at';\n    else if (distance > 0) position = 'above';\n    else position = 'below';\n\n    const result: VWAPResult = {\n      vwap: latestValue || 0,\n      distance,\n      distancePercent,\n      position,\n    };\n\n    return {\n      type: 'VWAP',\n      category: 'volume',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate SuperTrend (Custom Indicator)\n   */\n  static async calculateSuperTrend(data: OHLCVData[], config: SuperTrendConfig): Promise<{\n    type: 'SuperTrend';\n    category: 'trend';\n    timestamp: Date;\n    value: SuperTrendResultType;\n    metadata: any;\n  }> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateSuperTrend(data, config.period, config.multiplier);\n\n    // Get latest values\n    const latestSupertrend = Calculator.getLatestValue(values.supertrend);\n    const latestDirection = Calculator.getLatestValue(values.direction);\n    const latestSignal = Calculator.getLatestValue(values.signal);\n\n    const result: SuperTrendResultType = {\n      supertrend: latestSupertrend || 0,\n      direction: latestDirection || 'up',\n      signal: latestSignal || 'hold',\n    };\n\n    return {\n      type: 'SuperTrend',\n      category: 'trend',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        period: config.period,\n        parameters: { multiplier: config.multiplier },\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate Ichimoku Cloud (Custom Indicator)\n   */\n  static async calculateIchimoku(data: OHLCVData[], config: IchimokuConfig): Promise<{\n    type: 'Ichimoku';\n    category: 'trend';\n    timestamp: Date;\n    value: IchimokuResultType;\n    metadata: any;\n  }> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateIchimoku(\n      data,\n      config.conversionPeriod,\n      config.basePeriod,\n      config.spanBPeriod,\n      config.displacement\n    );\n\n    // Get latest values\n    const latestTenkanSen = Calculator.getLatestValue(values.tenkanSen);\n    const latestKijunSen = Calculator.getLatestValue(values.kijunSen);\n    const latestSenkouSpanA = Calculator.getLatestValue(values.senkouSpanA);\n    const latestSenkouSpanB = Calculator.getLatestValue(values.senkouSpanB);\n    const latestChikouSpan = Calculator.getLatestValue(values.chikouSpan);\n    const latestCloudColor = Calculator.getLatestValue(values.cloudColor);\n    const latestSignal = Calculator.getLatestValue(values.signal);\n\n    const result: IchimokuResultType = {\n      tenkanSen: latestTenkanSen || 0,\n      kijunSen: latestKijunSen || 0,\n      senkouSpanA: latestSenkouSpanA || 0,\n      senkouSpanB: latestSenkouSpanB || 0,\n      chikouSpan: latestChikouSpan || 0,\n      cloudColor: latestCloudColor || 'bullish',\n      signal: latestSignal || 'neutral',\n    };\n\n    return {\n      type: 'Ichimoku',\n      category: 'trend',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        parameters: {\n          conversionPeriod: config.conversionPeriod,\n          basePeriod: config.basePeriod,\n          spanBPeriod: config.spanBPeriod,\n          displacement: config.displacement,\n        },\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate Pivot Points (Custom Indicator)\n   */\n  static async calculatePivotPoints(data: OHLCVData[], config: PivotPointsConfig): Promise<{\n    type: 'PivotPoints';\n    category: 'support_resistance';\n    timestamp: Date;\n    value: PivotPointsResultType;\n    metadata: any;\n  }> {\n    const startTime = Date.now();\n    const values = await Calculator.calculatePivotPoints(data, config.method);\n\n    const result: PivotPointsResultType = {\n      pivot: values.pivot,\n      resistance1: values.r1,\n      resistance2: values.r2,\n      resistance3: values.r3,\n      support1: values.s1,\n      support2: values.s2,\n      support3: values.s3,\n      currentPosition: values.position,\n    };\n\n    return {\n      type: 'PivotPoints',\n      category: 'support_resistance',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        parameters: { method: config.method },\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Calculate Fibonacci Retracement (Custom Indicator)\n   * @param config - Fibonacci configuration\n   * @param currentPrice - Optional current price for nearest level calculation\n   */\n  static async calculateFibonacciRetracement(\n    config: FibonacciRetracementConfig,\n    currentPrice?: number\n  ): Promise<{\n    type: 'FibonacciRetracement';\n    category: 'support_resistance';\n    timestamp: Date;\n    value: FibonacciRetracementResultType;\n    metadata: any;\n  }> {\n    const startTime = Date.now();\n    const values = await Calculator.calculateFibonacciRetracement(\n      config.high,\n      config.low,\n      config.trend,\n      currentPrice\n    );\n\n    const result: FibonacciRetracementResultType = {\n      level_0: values.level_0,\n      level_236: values.level_236,\n      level_382: values.level_382,\n      level_500: values.level_500,\n      level_618: values.level_618,\n      level_786: values.level_786,\n      level_100: values.level_100,\n      level_1272: values.level_1272,\n      level_1618: values.level_1618,\n      nearestLevel: values.nearestLevel,\n      nearestLevelName: values.nearestLevelName,\n    };\n\n    return {\n      type: 'FibonacciRetracement',\n      category: 'support_resistance',\n      timestamp: new Date(),\n      value: result,\n      metadata: {\n        parameters: {\n          high: config.high,\n          low: config.low,\n          trend: config.trend,\n        },\n        calculationTime: Date.now() - startTime,\n      },\n    };\n  }\n\n  /**\n   * Generic calculate method that routes to appropriate calculator\n   *\n   * Note: Only supports key indicators. For other indicators,\n   * use calculator-v2 functions directly.\n   */\n  static async calculate(data: OHLCVData[], config: BaseIndicatorConfig): Promise<IndicatorResult<any>> {\n    switch (config.type) {\n      case 'RSI':\n        return this.calculateRSI(data, config as RSIConfig);\n      case 'MACD':\n        return this.calculateMACD(data, config as MACDConfig);\n      case 'BollingerBands':\n        return this.calculateBollingerBands(data, config as BollingerBandsConfig);\n      case 'ATR':\n        return this.calculateATR(data, config as ATRConfig);\n      case 'SMA':\n        return this.calculateSMA(data, config as SMAConfig);\n      case 'EMA':\n        return this.calculateEMA(data, config as EMAConfig);\n      case 'VWAP':\n        return this.calculateVWAP(data, config as VWAPConfig);\n      default:\n        throw new Error(\n          `Indicator type ${config.type} not implemented in factory. ` +\n          `Use calculator-v2 functions directly for ${config.type}.`\n        );\n    }\n  }\n}\n\n/**\n * Export convenience functions (renamed to avoid conflicts with calculator-v2)\n */\nexport const factoryCalculateRSI = IndicatorFactory.calculateRSI.bind(IndicatorFactory);\nexport const factoryCalculateMACD = IndicatorFactory.calculateMACD.bind(IndicatorFactory);\nexport const factoryCalculateBollingerBands = IndicatorFactory.calculateBollingerBands.bind(IndicatorFactory);\nexport const factoryCalculateATR = IndicatorFactory.calculateATR.bind(IndicatorFactory);\nexport const factoryCalculateSMA = IndicatorFactory.calculateSMA.bind(IndicatorFactory);\nexport const factoryCalculateEMA = IndicatorFactory.calculateEMA.bind(IndicatorFactory);\nexport const factoryCalculateVWAP = IndicatorFactory.calculateVWAP.bind(IndicatorFactory);\n\n// Custom indicators\nexport const factoryCalculateSuperTrend = IndicatorFactory.calculateSuperTrend.bind(IndicatorFactory);\nexport const factoryCalculateIchimoku = IndicatorFactory.calculateIchimoku.bind(IndicatorFactory);\nexport const factoryCalculatePivotPoints = IndicatorFactory.calculatePivotPoints.bind(IndicatorFactory);\nexport const factoryCalculateFibonacciRetracement = IndicatorFactory.calculateFibonacciRetracement.bind(IndicatorFactory);\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/services/indicators.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'INDICATOR_CATEGORY_MAP' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":69,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'successfulCalculations' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":499,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":499,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'configuration' is defined but never used. Allowed unused args must match /^_/u.","line":608,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":608,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Indicators Service V2\n * Main service for calculating, caching, and managing technical indicators\n * Refactored to use calculator-v2 (async) and IndicatorFactory\n *\n * @module indicators/services\n */\n\nimport { and, eq, gte, lte, or } from 'drizzle-orm';\nimport { OHLCVService } from '../../market-data/services/ohlcv.service';\nimport type {\n  CalculateIndicatorRequest,\n  BatchCalculateRequest,\n  IndicatorCalculationResponse,\n  BatchCalculationResponse,\n  IIndicatorService,\n  IndicatorPreset,\n  CreatePresetRequest,\n  UpdatePresetRequest,\n  IndicatorStatistics,\n  IndicatorResult,\n  BaseIndicatorConfig,\n  IndicatorType,\n  IndicatorCategory,\n  OHLCVData,\n  Timeframe,\n} from '../types/indicators.types';\nimport {\n  indicatorPresets,\n  indicatorCache,\n  indicatorCalculationLogs,\n} from '../schema/indicators.schema';\nimport { db } from '../../../db';\nimport { IndicatorFactory } from './indicator-factory.service';\n\n/**\n * Simple console logger fallback\n */\nconst logger = {\n  debug: (msg: string, meta?: any) => console.log(`[DEBUG] ${msg}`, meta || ''),\n  info: (msg: string, meta?: any) => console.log(`[INFO] ${msg}`, meta || ''),\n  error: (msg: string, meta?: any) => console.error(`[ERROR] ${msg}`, meta || ''),\n  warn: (msg: string, meta?: any) => console.warn(`[WARN] ${msg}`, meta || ''),\n};\n\n/**\n * Cache TTL configuration by timeframe (in seconds)\n */\nconst CACHE_TTL_MAP: Record<Timeframe, number> = {\n  '1m': 60, // 1 minute\n  '3m': 180, // 3 minutes\n  '5m': 300, // 5 minutes\n  '15m': 900, // 15 minutes\n  '30m': 1800, // 30 minutes\n  '1h': 3600, // 1 hour\n  '2h': 7200, // 2 hours\n  '4h': 14400, // 4 hours\n  '6h': 21600, // 6 hours\n  '12h': 43200, // 12 hours\n  '1d': 86400, // 1 day\n  '1w': 604800, // 1 week\n  '1M': 2592000, // ~30 days\n};\n\n/**\n * Indicator category mapping\n * Extended to include all indicators from indicators-full.types\n */\nconst INDICATOR_CATEGORY_MAP: Record<string, IndicatorCategory> = {\n  // Momentum\n  RSI: 'momentum',\n  MACD: 'momentum',\n  Stochastic: 'momentum',\n  StochasticRSI: 'momentum',\n  StochRSI: 'momentum',\n  CCI: 'momentum',\n  ROC: 'momentum',\n  MFI: 'momentum',\n  Williams_R: 'momentum',\n  AO: 'momentum',\n  TSI: 'momentum',\n  KST: 'momentum',\n  ForceIndex: 'momentum',\n  FI: 'momentum',\n  // Trend\n  SMA: 'trend',\n  EMA: 'trend',\n  WMA: 'trend',\n  WEMA: 'trend',\n  DEMA: 'trend',\n  TEMA: 'trend',\n  HMA: 'trend',\n  ADX: 'trend',\n  Aroon: 'trend',\n  Parabolic_SAR: 'trend',\n  Ichimoku: 'trend',\n  SuperTrend: 'trend',\n  // Volatility\n  BollingerBands: 'volatility',\n  ATR: 'volatility',\n  Keltner: 'volatility',\n  StandardDev: 'volatility',\n  DonchianChannel: 'volatility',\n  DC: 'volatility',\n  // Volume\n  OBV: 'volume',\n  VWAP: 'volume',\n  AD: 'volume',\n  ADL: 'volume',\n  VWMA: 'volume',\n  CMF: 'volume',\n  VolumeOscillator: 'volume',\n  VOSC: 'volume',\n  // Support/Resistance\n  PivotPoints: 'support_resistance',\n  FibonacciRetracement: 'support_resistance',\n};\n\n/**\n * Main Indicators Service Implementation\n */\nexport class IndicatorsService implements IIndicatorService {\n  /**\n   * Calculate a single indicator with caching support\n   */\n  async calculate<T = any>(request: CalculateIndicatorRequest): Promise<IndicatorCalculationResponse<T>> {\n    const startTime = Date.now();\n\n    try {\n      // Check cache first if enabled\n      if (request.useCache !== false) {\n        const cached = await this.getCachedResult<T>(\n          request.exchangeId,\n          request.symbol,\n          request.timeframe,\n          request.indicatorType,\n          request.configuration\n        );\n\n        if (cached) {\n          logger.debug('Cache hit for indicator calculation', {\n            indicator: request.indicatorType,\n            symbol: request.symbol,\n          });\n\n          return {\n            success: true,\n            data: cached,\n            fromCache: true,\n            calculationTime: Date.now() - startTime,\n          };\n        }\n      }\n\n      // Fetch OHLCV data (this should come from market-data module)\n      const ohlcvData = await this.fetchOHLCVData(\n        request.exchangeId,\n        request.symbol,\n        request.timeframe,\n        request.limit || 100\n      );\n\n      if (!ohlcvData || ohlcvData.length === 0) {\n        throw new Error('No market data available for calculation');\n      }\n\n      // Calculate indicator using async IndicatorFactory\n      const result = await this.calculateIndicator<T>(\n        ohlcvData,\n        request.indicatorType,\n        request.configuration\n      );\n\n      // Cache result\n      if (request.useCache !== false) {\n        await this.cacheResult(\n          request.exchangeId,\n          request.symbol,\n          request.timeframe,\n          request.indicatorType,\n          request.configuration,\n          result\n        );\n      }\n\n      // Log calculation\n      await this.logCalculation(\n        request.exchangeId,\n        request.symbol,\n        request.timeframe,\n        request.indicatorType,\n        request.configuration,\n        Date.now() - startTime,\n        true\n      );\n\n      return {\n        success: true,\n        data: result,\n        fromCache: false,\n        calculationTime: Date.now() - startTime,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      logger.error('Indicator calculation failed', {\n        indicator: request.indicatorType,\n        error: errorMessage,\n      });\n\n      // Log failed calculation\n      await this.logCalculation(\n        request.exchangeId,\n        request.symbol,\n        request.timeframe,\n        request.indicatorType,\n        request.configuration,\n        Date.now() - startTime,\n        false,\n        errorMessage\n      );\n\n      return {\n        success: false,\n        error: errorMessage,\n        calculationTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Calculate multiple indicators in batch\n   */\n  async calculateBatch(request: BatchCalculateRequest): Promise<BatchCalculationResponse> {\n    const startTime = Date.now();\n\n    try {\n      const results = await Promise.allSettled(\n        request.indicators.map((config) =>\n          this.calculate({\n            exchangeId: request.exchangeId,\n            symbol: request.symbol,\n            timeframe: request.timeframe,\n            indicatorType: config.type,\n            configuration: config,\n            limit: request.limit,\n            useCache: request.useCache,\n          })\n        )\n      );\n\n      const processedResults = results.map((result, index) => {\n        const indicatorType = request.indicators[index].type;\n\n        if (result.status === 'fulfilled' && result.value.success) {\n          return {\n            indicatorType,\n            data: result.value.data,\n            fromCache: result.value.fromCache,\n          };\n        } else {\n          const error =\n            result.status === 'rejected'\n              ? result.reason?.message || 'Unknown error'\n              : result.value.error || 'Calculation failed';\n\n          return {\n            indicatorType,\n            error,\n          };\n        }\n      });\n\n      return {\n        success: true,\n        results: processedResults,\n        totalCalculationTime: Date.now() - startTime,\n      };\n    } catch (error) {\n      logger.error('Batch calculation failed', { error });\n\n      return {\n        success: false,\n        results: [],\n        totalCalculationTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Create a new indicator preset\n   */\n  async createPreset(\n    userId: string,\n    tenantId: string,\n    request: CreatePresetRequest\n  ): Promise<IndicatorPreset> {\n    try {\n      const [preset] = await db\n        .insert(indicatorPresets)\n        .values({\n          userId,\n          tenantId,\n          name: request.name,\n          description: request.description,\n          category: request.category,\n          indicatorType: request.indicatorType,\n          configuration: request.configuration as any,\n          isPublic: request.isPublic || false,\n          usageCount: 0,\n          tags: request.tags || [],\n        })\n        .returning();\n\n      logger.info('Indicator preset created', { presetId: preset.id, name: preset.name });\n\n      return preset as IndicatorPreset;\n    } catch (error) {\n      logger.error('Failed to create preset', { error });\n      throw new Error('Failed to create indicator preset');\n    }\n  }\n\n  /**\n   * Get a preset by ID\n   */\n  async getPreset(presetId: string): Promise<IndicatorPreset | null> {\n    try {\n      const [preset] = await db\n        .select()\n        .from(indicatorPresets)\n        .where(eq(indicatorPresets.id, presetId))\n        .limit(1);\n\n      if (!preset) return null;\n\n      // Increment usage count\n      await db\n        .update(indicatorPresets)\n        .set({ usageCount: preset.usageCount + 1 })\n        .where(eq(indicatorPresets.id, presetId));\n\n      return preset as IndicatorPreset;\n    } catch (error) {\n      logger.error('Failed to get preset', { presetId, error });\n      return null;\n    }\n  }\n\n  /**\n   * Get presets with optional filters\n   */\n  async getPresets(\n    userId: string,\n    tenantId: string,\n    filters?: { category?: IndicatorCategory; indicatorType?: IndicatorType }\n  ): Promise<IndicatorPreset[]> {\n    try {\n      const conditions = [\n        or(eq(indicatorPresets.userId, userId), eq(indicatorPresets.isPublic, true)),\n        eq(indicatorPresets.tenantId, tenantId),\n      ];\n\n      if (filters?.category) {\n        conditions.push(eq(indicatorPresets.category, filters.category));\n      }\n\n      if (filters?.indicatorType) {\n        conditions.push(eq(indicatorPresets.indicatorType, filters.indicatorType));\n      }\n\n      const presets = await db\n        .select()\n        .from(indicatorPresets)\n        .where(and(...conditions))\n        .orderBy(indicatorPresets.usageCount);\n\n      return presets as IndicatorPreset[];\n    } catch (error) {\n      logger.error('Failed to get presets', { error });\n      return [];\n    }\n  }\n\n  /**\n   * Update a preset\n   */\n  async updatePreset(\n    presetId: string,\n    userId: string,\n    tenantId: string,\n    updates: UpdatePresetRequest\n  ): Promise<IndicatorPreset> {\n    try {\n      // Verify ownership\n      const [existing] = await db\n        .select()\n        .from(indicatorPresets)\n        .where(\n          and(\n            eq(indicatorPresets.id, presetId),\n            eq(indicatorPresets.userId, userId),\n            eq(indicatorPresets.tenantId, tenantId)\n          )\n        )\n        .limit(1);\n\n      if (!existing) {\n        throw new Error('Preset not found or access denied');\n      }\n\n      const [updated] = await db\n        .update(indicatorPresets)\n        .set({\n          ...updates,\n          updatedAt: new Date(),\n        })\n        .where(eq(indicatorPresets.id, presetId))\n        .returning();\n\n      logger.info('Preset updated', { presetId });\n\n      return updated as IndicatorPreset;\n    } catch (error) {\n      logger.error('Failed to update preset', { presetId, error });\n      throw new Error('Failed to update preset');\n    }\n  }\n\n  /**\n   * Delete a preset\n   */\n  async deletePreset(presetId: string, userId: string, tenantId: string): Promise<void> {\n    try {\n      await db\n        .delete(indicatorPresets)\n        .where(\n          and(\n            eq(indicatorPresets.id, presetId),\n            eq(indicatorPresets.userId, userId),\n            eq(indicatorPresets.tenantId, tenantId)\n          )\n        );\n\n      logger.info('Preset deleted', { presetId });\n    } catch (error) {\n      logger.error('Failed to delete preset', { presetId, error });\n      throw new Error('Failed to delete preset');\n    }\n  }\n\n  /**\n   * Clear cache with optional filters\n   */\n  async clearCache(exchangeId?: string, symbol?: string, indicatorType?: IndicatorType): Promise<void> {\n    try {\n      const conditions = [];\n\n      if (exchangeId) {\n        conditions.push(eq(indicatorCache.exchangeId, exchangeId));\n      }\n\n      if (symbol) {\n        conditions.push(eq(indicatorCache.symbol, symbol));\n      }\n\n      if (indicatorType) {\n        conditions.push(eq(indicatorCache.indicatorType, indicatorType));\n      }\n\n      const whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n\n      await db.delete(indicatorCache).where(whereClause);\n\n      logger.info('Cache cleared', { exchangeId, symbol, indicatorType });\n    } catch (error) {\n      logger.error('Failed to clear cache', { error });\n      throw new Error('Failed to clear cache');\n    }\n  }\n\n  /**\n   * Get usage statistics\n   */\n  async getStatistics(userId: string, tenantId: string): Promise<IndicatorStatistics> {\n    try {\n      // Get total calculations from logs\n      const logs = await db\n        .select()\n        .from(indicatorCalculationLogs)\n        .where(\n          and(\n            eq(indicatorCalculationLogs.userId, userId),\n            eq(indicatorCalculationLogs.tenantId, tenantId)\n          )\n        ).catch(() => []); // Return empty array if query fails\n\n      const totalCalculations = logs.length || 0;\n      const successfulCalculations = logs.filter((log) => log.success).length || 0;\n      const cacheHits = logs.filter((log) => log.fromCache).length || 0;\n      const cacheHitRate = totalCalculations > 0 ? (cacheHits / totalCalculations) * 100 : 0;\n\n      const totalTime = logs.reduce((sum, log) => sum + (log.calculationTimeMs || 0), 0);\n      const averageCalculationTime = totalCalculations > 0 ? totalTime / totalCalculations : 0;\n\n      // Get most used indicators\n      const indicatorCounts = logs.reduce(\n        (acc, log) => {\n          const type = log.indicatorType || 'unknown';\n          acc[type] = (acc[type] || 0) + 1;\n          return acc;\n        },\n        {} as Record<string, number>\n      );\n\n      const mostUsedIndicators = Object.entries(indicatorCounts)\n        .map(([type, count]) => ({ type: type as IndicatorType, count }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 10);\n\n      logger.info('Statistics retrieved successfully', {\n        userId,\n        tenantId,\n        totalCalculations,\n        cacheHitRate,\n      });\n\n      return {\n        totalCalculations,\n        cacheHitRate,\n        averageCalculationTime,\n        mostUsedIndicators,\n      };\n    } catch (error) {\n      logger.error('Failed to get statistics', { userId, tenantId, error });\n      // Return default statistics instead of throwing\n      return {\n        totalCalculations: 0,\n        cacheHitRate: 0,\n        averageCalculationTime: 0,\n        mostUsedIndicators: [],\n      };\n    }\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  /**\n   * Calculate indicator based on type using IndicatorFactory (async)\n   */\n  private async calculateIndicator<T>(\n    data: OHLCVData[],\n    type: IndicatorType,\n    config: BaseIndicatorConfig\n  ): Promise<IndicatorResult<T>> {\n    try {\n      // Normalize indicator type to match factory expectations\n      // Factory expects uppercase (SMA, EMA, RSI) but requests may send lowercase\n      const normalizedConfig = {\n        ...config,\n        type: this.normalizeIndicatorType(config.type),\n      };\n\n      // Try using IndicatorFactory for supported indicators\n      const result = await IndicatorFactory.calculate(data, normalizedConfig);\n      return result as IndicatorResult<T>;\n    } catch (error) {\n      // If IndicatorFactory doesn't support it, throw error\n      const message = error instanceof Error ? error.message : `Indicator type ${type} not supported`;\n      throw new Error(message);\n    }\n  }\n\n  /**\n   * Normalize indicator type to uppercase for factory compatibility\n   */\n  private normalizeIndicatorType(type: string): IndicatorType {\n    // Map common lowercase variations to factory-expected uppercase\n    const typeMap: Record<string, string> = {\n      'sma': 'SMA',\n      'ema': 'EMA',\n      'rsi': 'RSI',\n      'macd': 'MACD',\n      'bollingerbands': 'BollingerBands',\n      'atr': 'ATR',\n      'vwap': 'VWAP',\n      'stochastic': 'Stochastic',\n      'stochrsi': 'StochRSI',\n      'cci': 'CCI',\n      'adx': 'ADX',\n      'obv': 'OBV',\n    };\n\n    const normalized = typeMap[type.toLowerCase()];\n    return (normalized || type) as IndicatorType;\n  }\n\n  /**\n   * Get cached result if available and not expired\n   */\n  private async getCachedResult<T>(\n    exchangeId: string,\n    symbol: string,\n    timeframe: Timeframe,\n    indicatorType: IndicatorType,\n    configuration: BaseIndicatorConfig\n  ): Promise<IndicatorResult<T> | null> {\n    try {\n      const [cached] = await db\n        .select()\n        .from(indicatorCache)\n        .where(\n          and(\n            eq(indicatorCache.exchangeId, exchangeId),\n            eq(indicatorCache.symbol, symbol),\n            eq(indicatorCache.timeframe, timeframe),\n            eq(indicatorCache.indicatorType, indicatorType),\n            gte(indicatorCache.expiresAt, new Date())\n          )\n        )\n        .limit(1);\n\n      if (!cached) return null;\n\n      // Increment hit counter\n      await db\n        .update(indicatorCache)\n        .set({ hits: cached.hits + 1 })\n        .where(eq(indicatorCache.id, cached.id));\n\n      return cached.result as IndicatorResult<T>;\n    } catch (error) {\n      logger.error('Cache lookup failed', { error });\n      return null;\n    }\n  }\n\n  /**\n   * Cache calculation result\n   */\n  private async cacheResult(\n    exchangeId: string,\n    symbol: string,\n    timeframe: Timeframe,\n    indicatorType: IndicatorType,\n    configuration: BaseIndicatorConfig,\n    result: IndicatorResult<any>\n  ): Promise<void> {\n    try {\n      const ttl = CACHE_TTL_MAP[timeframe];\n      const expiresAt = new Date(Date.now() + ttl * 1000);\n\n      await db.insert(indicatorCache).values({\n        exchangeId,\n        symbol,\n        timeframe,\n        indicatorType,\n        configuration: configuration as any,\n        result: result as any,\n        expiresAt,\n        calculationTimeMs: result.metadata?.calculationTime || 0,\n      });\n    } catch (error) {\n      logger.error('Failed to cache result', { error });\n      // Don't throw - caching failure shouldn't break calculation\n    }\n  }\n\n  /**\n   * Log calculation for analytics\n   */\n  private async logCalculation(\n    exchangeId: string,\n    symbol: string,\n    timeframe: Timeframe,\n    indicatorType: IndicatorType,\n    configuration: BaseIndicatorConfig,\n    calculationTime: number,\n    success: boolean,\n    errorMessage?: string\n  ): Promise<void> {\n    try {\n      await db.insert(indicatorCalculationLogs).values({\n        userId: 'system', // Public endpoint - no user context\n        tenantId: 'system', // Public endpoint - no tenant context\n        exchangeId,\n        symbol,\n        timeframe,\n        indicatorType,\n        configuration: configuration as any,\n        calculationTimeMs: calculationTime,\n        success,\n        errorMessage: errorMessage || null,\n        fromCache: false,\n      });\n    } catch (error) {\n      logger.error('Failed to log calculation', { error });\n      // Don't throw - logging failure shouldn't break calculation\n    }\n  }\n\n  /**\n   * Fetch OHLCV data from market-data module\n   */\n  private async fetchOHLCVData(\n    exchangeId: string,\n    symbol: string,\n    timeframe: Timeframe,\n    limit: number\n  ): Promise<OHLCVData[]> {\n    try {\n      logger.debug('Fetching OHLCV data for indicator calculation', {\n        exchangeId,\n        symbol,\n        timeframe,\n        limit,\n      });\n\n      // Fetch OHLCV data from market-data service\n      const ohlcvData = await OHLCVService.fetchOHLCV({\n        exchangeId,\n        symbol,\n        timeframe,\n        limit,\n      });\n\n      // Convert to OHLCVData format\n      const converted: OHLCVData[] = ohlcvData.map(candle => ({\n        timestamp: candle.timestamp,\n        open: candle.open,\n        high: candle.high,\n        low: candle.low,\n        close: candle.close,\n        volume: candle.volume,\n      }));\n\n      logger.debug('OHLCV data fetched successfully', {\n        exchangeId,\n        symbol,\n        candlesCount: converted.length,\n      });\n\n      return converted;\n    } catch (error) {\n      logger.error('Failed to fetch OHLCV data for indicator calculation', {\n        exchangeId,\n        symbol,\n        timeframe,\n        limit,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw new Error(\n        `Failed to fetch OHLCV data: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n}\n\n/**\n * Export singleton instance\n */\nexport const indicatorsService = new IndicatorsService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/types/crypto-indicators.types.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IndicatorType' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Crypto-Specific Technical Indicators Types\n * Additional indicators popular in cryptocurrency trading\n *\n * @module indicators/types/crypto-indicators\n */\n\nimport type { BaseIndicatorConfig, IndicatorType } from './indicators-full.types';\n\n// ============================================================================\n// CRYPTO MOMENTUM INDICATORS\n// ============================================================================\n\n/**\n * Stochastic RSI Configuration (Very popular in crypto)\n */\nexport interface StochasticRSIConfig extends BaseIndicatorConfig {\n  type: 'StochRSI';  // Fixed: StochasticRSI → StochRSI\n  rsiPeriod: number;     // Default: 14\n  stochPeriod: number;   // Default: 14\n  kPeriod: number;       // Default: 3\n  dPeriod: number;       // Default: 3\n}\n\n/**\n * Stochastic RSI Result\n */\nexport interface StochasticRSIResult {\n  k: number; // %K (0-100)\n  d: number; // %D (0-100)\n  overbought: boolean; // > 80\n  oversold: boolean; // < 20\n  extremeOverbought: boolean; // > 95\n  extremeOversold: boolean; // < 5\n}\n\n/**\n * Awesome Oscillator Configuration (Bill Williams)\n */\nexport interface AOConfig extends BaseIndicatorConfig {\n  type: 'AO';\n  fastPeriod: number;  // Default: 5\n  slowPeriod: number;  // Default: 34\n}\n\n/**\n * Awesome Oscillator Result\n */\nexport interface AOResult {\n  ao: number;\n  signal: 'bullish' | 'bearish' | 'neutral';\n  momentum: 'increasing' | 'decreasing';\n}\n\n/**\n * True Strength Index Configuration\n */\nexport interface TSIConfig extends BaseIndicatorConfig {\n  type: 'TSI';\n  longPeriod: number;   // Default: 25\n  shortPeriod: number;  // Default: 13\n  signalPeriod: number; // Default: 13\n}\n\n/**\n * TSI Result\n */\nexport interface TSIResult {\n  tsi: number; // -100 to +100\n  signal: number;\n  crossover?: 'bullish' | 'bearish' | null;\n}\n\n/**\n * Know Sure Thing Configuration\n */\nexport interface KSTConfig extends BaseIndicatorConfig {\n  type: 'KST';\n  roc1: number;    // Default: 10\n  roc2: number;    // Default: 15\n  roc3: number;    // Default: 20\n  roc4: number;    // Default: 30\n  sma1: number;    // Default: 10\n  sma2: number;    // Default: 10\n  sma3: number;    // Default: 10\n  sma4: number;    // Default: 15\n  signalPeriod: number; // Default: 9\n}\n\n/**\n * KST Result\n */\nexport interface KSTResult {\n  kst: number;\n  signal: number;\n  crossover?: 'bullish' | 'bearish' | null;\n}\n\n/**\n * Force Index Configuration\n */\nexport interface ForceIndexConfig extends BaseIndicatorConfig {\n  type: 'FI';  // Fixed: ForceIndex → FI\n  period: number; // Default: 13\n}\n\n/**\n * Force Index Result\n */\nexport interface ForceIndexResult {\n  forceIndex: number;\n  trend: 'bullish' | 'bearish' | 'neutral';\n  strength: 'weak' | 'moderate' | 'strong';\n}\n\n// ============================================================================\n// CRYPTO TREND INDICATORS\n// ============================================================================\n\n/**\n * DEMA (Double Exponential Moving Average) Configuration\n */\nexport interface DEMAConfig extends BaseIndicatorConfig {\n  type: 'DEMA';\n  period: number; // Default: 20\n}\n\n/**\n * DEMA Result\n */\nexport interface DEMAResult {\n  dema: number;\n  trend: 'up' | 'down' | 'sideways';\n  distance: number;\n  distancePercent: number;\n}\n\n/**\n * TEMA (Triple Exponential Moving Average) Configuration\n */\nexport interface TEMAConfig extends BaseIndicatorConfig {\n  type: 'TEMA';\n  period: number; // Default: 20\n}\n\n/**\n * TEMA Result\n */\nexport interface TEMAResult {\n  tema: number;\n  trend: 'up' | 'down' | 'sideways';\n  distance: number;\n  distancePercent: number;\n}\n\n/**\n * HMA (Hull Moving Average) Configuration - Very popular in crypto\n */\nexport interface HMAConfig extends BaseIndicatorConfig {\n  type: 'HMA';\n  period: number; // Default: 9\n}\n\n/**\n * HMA Result\n */\nexport interface HMAResult {\n  hma: number;\n  trend: 'up' | 'down' | 'sideways';\n  distance: number;\n  distancePercent: number;\n}\n\n/**\n * Aroon Indicator Configuration\n */\nexport interface AroonConfig extends BaseIndicatorConfig {\n  type: 'Aroon';\n  period: number; // Default: 25\n}\n\n/**\n * Aroon Result\n */\nexport interface AroonResult {\n  aroonUp: number; // 0-100\n  aroonDown: number; // 0-100\n  oscillator: number; // aroonUp - aroonDown\n  trend: 'strong-up' | 'up' | 'sideways' | 'down' | 'strong-down';\n}\n\n/**\n * SuperTrend Configuration (Popular in crypto)\n * NOTE: Not available in @ixjb94/indicators library - needs custom implementation\n */\nexport interface SuperTrendConfig {\n  type: 'SuperTrend';  // Custom indicator - not in IndicatorType enum\n  period: number;      // Default: 10\n  multiplier: number;  // Default: 3\n}\n\n/**\n * SuperTrend Result\n */\nexport interface SuperTrendResult {\n  supertrend: number;\n  direction: 'up' | 'down';\n  signal: 'buy' | 'sell' | 'hold';\n}\n\n/**\n * Ichimoku Cloud Configuration (Very popular in crypto)\n * NOTE: Not available in @ixjb94/indicators library - needs custom implementation\n * Library has IkhTS but it's not implemented yet\n */\nexport interface IchimokuConfig {\n  type: 'Ichimoku';  // Custom indicator - not in IndicatorType enum\n  conversionPeriod: number;  // Tenkan-sen: Default 9\n  basePeriod: number;        // Kijun-sen: Default 26\n  spanBPeriod: number;       // Senkou Span B: Default 52\n  displacement: number;      // Default: 26\n}\n\n/**\n * Ichimoku Result\n */\nexport interface IchimokuResult {\n  tenkanSen: number;      // Conversion Line\n  kijunSen: number;       // Base Line\n  senkouSpanA: number;    // Leading Span A\n  senkouSpanB: number;    // Leading Span B\n  chikouSpan: number;     // Lagging Span\n  cloudColor: 'bullish' | 'bearish';\n  signal: 'strong-buy' | 'buy' | 'neutral' | 'sell' | 'strong-sell';\n}\n\n// ============================================================================\n// CRYPTO VOLATILITY INDICATORS\n// ============================================================================\n\n/**\n * Donchian Channel Configuration (Breakout trading)\n */\nexport interface DonchianChannelConfig extends BaseIndicatorConfig {\n  type: 'DC';  // Fixed: DonchianChannel → DC\n  period: number; // Default: 20\n}\n\n/**\n * Donchian Channel Result\n */\nexport interface DonchianChannelResult {\n  upper: number;  // Highest high\n  middle: number; // Average of upper and lower\n  lower: number;  // Lowest low\n  position: 'breakout-high' | 'upper-third' | 'middle' | 'lower-third' | 'breakout-low';\n  bandwidth: number;\n}\n\n// ============================================================================\n// CRYPTO VOLUME INDICATORS\n// ============================================================================\n\n/**\n * Chaikin Money Flow Configuration\n */\nexport interface CMFConfig extends BaseIndicatorConfig {\n  type: 'CMF';\n  period: number; // Default: 20\n}\n\n/**\n * CMF Result\n */\nexport interface CMFResult {\n  cmf: number; // -1 to +1\n  buyingPressure: boolean; // CMF > 0\n  sellingPressure: boolean; // CMF < 0\n  strength: 'strong' | 'moderate' | 'weak';\n}\n\n/**\n * Volume Oscillator Configuration\n */\nexport interface VolumeOscillatorConfig extends BaseIndicatorConfig {\n  type: 'VOSC';  // Fixed: VolumeOscillator → VOSC\n  shortPeriod: number; // Default: 5\n  longPeriod: number;  // Default: 10\n}\n\n/**\n * Volume Oscillator Result\n */\nexport interface VolumeOscillatorResult {\n  oscillator: number; // Percentage difference\n  trend: 'increasing' | 'decreasing';\n  signal: 'accumulation' | 'distribution' | 'neutral';\n}\n\n// ============================================================================\n// SUPPORT & RESISTANCE INDICATORS\n// ============================================================================\n\n/**\n * Pivot Points Configuration (Classic, Fibonacci, Woodie, Camarilla)\n * NOTE: Not available in @ixjb94/indicators library - needs custom implementation\n */\nexport interface PivotPointsConfig {\n  type: 'PivotPoints';  // Custom indicator - not in IndicatorType enum\n  method: 'classic' | 'fibonacci' | 'woodie' | 'camarilla'; // Default: classic\n}\n\n/**\n * Pivot Points Result\n */\nexport interface PivotPointsResult {\n  pivot: number;      // P\n  resistance1: number; // R1\n  resistance2: number; // R2\n  resistance3: number; // R3\n  support1: number;    // S1\n  support2: number;    // S2\n  support3: number;    // S3\n  currentPosition: 'above-R3' | 'R2-R3' | 'R1-R2' | 'P-R1' | 'S1-P' | 'S2-S1' | 'S3-S2' | 'below-S3';\n}\n\n/**\n * Fibonacci Retracement Configuration\n * NOTE: Not available in @ixjb94/indicators library - needs custom implementation\n */\nexport interface FibonacciRetracementConfig {\n  type: 'FibonacciRetracement';  // Custom indicator - not in IndicatorType enum\n  high: number;  // Swing high\n  low: number;   // Swing low\n  trend: 'uptrend' | 'downtrend';\n}\n\n/**\n * Fibonacci Retracement Result\n */\nexport interface FibonacciRetracementResult {\n  level_0: number;      // 0% (swing low/high)\n  level_236: number;    // 23.6%\n  level_382: number;    // 38.2%\n  level_500: number;    // 50%\n  level_618: number;    // 61.8% (golden ratio)\n  level_786: number;    // 78.6%\n  level_100: number;    // 100% (swing high/low)\n  // Extensions\n  level_1272: number;   // 127.2%\n  level_1618: number;   // 161.8%\n  nearestLevel: number;\n  nearestLevelName: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/types/indicators-full.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/types/indicators.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/utils/__tests__/calculator-v2.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":222,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":222,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":516,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":516,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Calculator V2 - Unit Tests\n * Tests for key technical indicators\n *\n * @module indicators/utils/__tests__/calculator-v2\n */\n\nimport { describe, test, expect, beforeAll } from 'bun:test';\nimport {\n  calculateRSI,\n  calculateMACD,\n  calculateEMA,\n  calculateBBands,\n  calculateATR,\n  calculateSMA,\n  getLatestValue,\n  validateDataLength,\n} from '../calculator-v2';\nimport type { OHLCVData } from '../../types/indicators-full.types';\n\n// ============================================================================\n// MOCK DATA\n// ============================================================================\n\n/**\n * Generate realistic OHLCV mock data\n * Simulates BTC/USDT price movement\n */\nfunction generateMockOHLCV(bars: number = 100, startPrice: number = 50000): OHLCVData[] {\n  const data: OHLCVData[] = [];\n  let currentPrice = startPrice;\n  const baseDate = new Date('2024-01-01T00:00:00Z');\n\n  for (let i = 0; i < bars; i++) {\n    // Simulate realistic price movement (±2% per bar)\n    const change = (Math.random() - 0.5) * 0.04; // -2% to +2%\n    currentPrice = currentPrice * (1 + change);\n\n    const high = currentPrice * (1 + Math.random() * 0.01); // +0-1%\n    const low = currentPrice * (1 - Math.random() * 0.01);  // -0-1%\n    const open = low + Math.random() * (high - low);\n    const close = low + Math.random() * (high - low);\n    const volume = 100 + Math.random() * 1000;\n\n    data.push({\n      timestamp: new Date(baseDate.getTime() + i * 60000), // 1 minute bars\n      open,\n      high,\n      low,\n      close,\n      volume,\n    });\n  }\n\n  return data;\n}\n\n/**\n * Known values test data for RSI\n * Using simple trending data where RSI can be calculated manually\n */\nfunction generateKnownRSIData(): OHLCVData[] {\n  const baseDate = new Date('2024-01-01T00:00:00Z');\n  const prices = [\n    44, 44.34, 44.09, 43.61, 44.33, 44.83, 45.10, 45.42, 45.84, 46.08,\n    45.89, 46.03, 45.61, 46.28, 46.28, 46.00, 46.03, 46.41, 46.22, 45.64,\n  ];\n\n  return prices.map((close, i) => ({\n    timestamp: new Date(baseDate.getTime() + i * 60000),\n    open: close * 0.99,\n    high: close * 1.01,\n    low: close * 0.98,\n    close,\n    volume: 1000,\n  }));\n}\n\n// ============================================================================\n// TEST SUITES\n// ============================================================================\n\ndescribe('Calculator V2 - Helper Functions', () => {\n  test('getLatestValue should return last element', () => {\n    const values = [1, 2, 3, 4, 5];\n    expect(getLatestValue(values)).toBe(5);\n  });\n\n  test('getLatestValue should return null for empty array', () => {\n    expect(getLatestValue([])).toBeNull();\n  });\n\n  test('validateDataLength should not throw for sufficient data', () => {\n    const data = generateMockOHLCV(50);\n    expect(() => validateDataLength(data, 14, 'RSI')).not.toThrow();\n  });\n\n  test('validateDataLength should throw for insufficient data', () => {\n    const data = generateMockOHLCV(10);\n    expect(() => validateDataLength(data, 20, 'RSI')).toThrow('Insufficient data');\n  });\n\n  test('validateDataLength should throw for empty data', () => {\n    expect(() => validateDataLength([], 14, 'RSI')).toThrow('No data provided');\n  });\n});\n\ndescribe('Calculator V2 - SMA (Simple Moving Average)', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate SMA with default period (20)', async () => {\n    const result = await calculateSMA(mockData);\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n    expect(result.length).toBeGreaterThan(0);\n    expect(typeof result[0]).toBe('number');\n  });\n\n  test('should calculate SMA with custom period (50)', async () => {\n    const result = await calculateSMA(mockData, 50);\n\n    expect(result).toBeDefined();\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(10);\n    await expect(calculateSMA(shortData, 50)).rejects.toThrow('Insufficient data');\n  });\n\n  test('SMA values should be reasonable', async () => {\n    const result = await calculateSMA(mockData, 20);\n    const latestSMA = getLatestValue(result);\n    const latestClose = mockData[mockData.length - 1].close;\n\n    // SMA should be within ±20% of current price\n    expect(latestSMA).toBeGreaterThan(latestClose * 0.8);\n    expect(latestSMA).toBeLessThan(latestClose * 1.2);\n  });\n});\n\ndescribe('Calculator V2 - EMA (Exponential Moving Average)', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate EMA with default period (20)', async () => {\n    const result = await calculateEMA(mockData);\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n    expect(result.length).toBeGreaterThan(0);\n    expect(typeof result[0]).toBe('number');\n  });\n\n  test('should calculate EMA with custom period (50)', async () => {\n    const result = await calculateEMA(mockData, 50);\n\n    expect(result).toBeDefined();\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  test('EMA should be more responsive than SMA', async () => {\n    const ema = await calculateEMA(mockData, 20);\n    const sma = await calculateSMA(mockData, 20);\n\n    // Both should have values (EMA returns full array, SMA may be shorter)\n    expect(ema.length).toBeGreaterThan(0);\n    expect(sma.length).toBeGreaterThan(0);\n\n    // EMA typically differs from SMA\n    const latestEMA = getLatestValue(ema);\n    const latestSMA = getLatestValue(sma);\n\n    expect(latestEMA).toBeDefined();\n    expect(latestSMA).toBeDefined();\n\n    // EMA and SMA should be different (EMA is more responsive)\n    expect(latestEMA).not.toBe(latestSMA);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(5);\n    await expect(calculateEMA(shortData, 20)).rejects.toThrow('Insufficient data');\n  });\n});\n\ndescribe('Calculator V2 - RSI (Relative Strength Index)', () => {\n  let mockData: OHLCVData[];\n  let knownData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n    knownData = generateKnownRSIData();\n  });\n\n  test('should calculate RSI with default period (14)', async () => {\n    const result = await calculateRSI(mockData);\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  test('should calculate RSI with custom period (7)', async () => {\n    const result = await calculateRSI(mockData, 7);\n\n    expect(result).toBeDefined();\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  test('RSI values should be between 0 and 100', async () => {\n    const result = await calculateRSI(mockData, 14);\n\n    result.forEach((value, index) => {\n      expect(value).toBeGreaterThanOrEqual(0);\n      expect(value).toBeLessThanOrEqual(100);\n    });\n  });\n\n  test('RSI should identify overbought/oversold conditions', async () => {\n    const result = await calculateRSI(mockData, 14);\n    const latestRSI = getLatestValue(result);\n\n    expect(latestRSI).toBeDefined();\n    expect(typeof latestRSI).toBe('number');\n\n    // RSI typically ranges 30-70 in normal conditions\n    // Extreme values (>80 or <20) are rare but valid\n    expect(latestRSI).toBeGreaterThan(0);\n    expect(latestRSI).toBeLessThan(100);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(10);\n    await expect(calculateRSI(shortData, 14)).rejects.toThrow('Insufficient data');\n  });\n\n  test('should handle known trending data correctly', async () => {\n    const result = await calculateRSI(knownData, 14);\n\n    expect(result.length).toBeGreaterThan(0);\n\n    // For uptrending data, RSI should be > 50\n    const latestRSI = getLatestValue(result);\n    expect(latestRSI).toBeGreaterThan(30); // Should show upward momentum\n  });\n});\n\ndescribe('Calculator V2 - MACD (Moving Average Convergence Divergence)', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate MACD with default periods (12, 26, 9)', async () => {\n    const result = await calculateMACD(mockData);\n\n    expect(result).toBeDefined();\n    expect(result.macd).toBeDefined();\n    expect(result.signal).toBeDefined();\n    expect(result.histogram).toBeDefined();\n\n    expect(Array.isArray(result.macd)).toBe(true);\n    expect(Array.isArray(result.signal)).toBe(true);\n    expect(Array.isArray(result.histogram)).toBe(true);\n  });\n\n  test('should calculate MACD with custom periods', async () => {\n    const result = await calculateMACD(mockData, 8, 17, 9);\n\n    expect(result.macd.length).toBeGreaterThan(0);\n    expect(result.signal.length).toBeGreaterThan(0);\n    expect(result.histogram.length).toBeGreaterThan(0);\n  });\n\n  test('MACD arrays should have same length', async () => {\n    const result = await calculateMACD(mockData);\n\n    expect(result.macd.length).toBe(result.signal.length);\n    expect(result.macd.length).toBe(result.histogram.length);\n  });\n\n  test('MACD histogram should equal macd - signal', async () => {\n    const result = await calculateMACD(mockData);\n\n    const latestMACD = getLatestValue(result.macd);\n    const latestSignal = getLatestValue(result.signal);\n    const latestHistogram = getLatestValue(result.histogram);\n\n    expect(latestMACD).toBeDefined();\n    expect(latestSignal).toBeDefined();\n    expect(latestHistogram).toBeDefined();\n\n    // Histogram = MACD - Signal (with small floating point tolerance)\n    const expectedHistogram = latestMACD! - latestSignal!;\n    expect(Math.abs(latestHistogram! - expectedHistogram)).toBeLessThan(0.0001);\n  });\n\n  test('should detect crossovers', async () => {\n    const result = await calculateMACD(mockData);\n\n    // Check if we can detect a crossover in the data\n    let crossoverFound = false;\n    for (let i = 1; i < result.macd.length; i++) {\n      const prevMacd = result.macd[i - 1];\n      const currMacd = result.macd[i];\n      const prevSignal = result.signal[i - 1];\n      const currSignal = result.signal[i];\n\n      // Bullish crossover: MACD crosses above signal\n      if (prevMacd < prevSignal && currMacd > currSignal) {\n        crossoverFound = true;\n        break;\n      }\n\n      // Bearish crossover: MACD crosses below signal\n      if (prevMacd > prevSignal && currMacd < currSignal) {\n        crossoverFound = true;\n        break;\n      }\n    }\n\n    // With 100 bars of random data, crossovers are common\n    // Just check that the logic works\n    expect(typeof crossoverFound).toBe('boolean');\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(20);\n    await expect(calculateMACD(shortData, 12, 26, 9)).rejects.toThrow('Insufficient data');\n  });\n});\n\ndescribe('Calculator V2 - Bollinger Bands', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate BBands with default parameters (20, 2)', async () => {\n    const result = await calculateBBands(mockData);\n\n    expect(result).toBeDefined();\n    expect(result.upper).toBeDefined();\n    expect(result.middle).toBeDefined();\n    expect(result.lower).toBeDefined();\n\n    expect(Array.isArray(result.upper)).toBe(true);\n    expect(Array.isArray(result.middle)).toBe(true);\n    expect(Array.isArray(result.lower)).toBe(true);\n  });\n\n  test('should calculate BBands with custom parameters', async () => {\n    const result = await calculateBBands(mockData, 10, 1.5);\n\n    expect(result.upper.length).toBeGreaterThan(0);\n    expect(result.middle.length).toBeGreaterThan(0);\n    expect(result.lower.length).toBeGreaterThan(0);\n  });\n\n  test('BBand arrays should have same length', async () => {\n    const result = await calculateBBands(mockData);\n\n    expect(result.upper.length).toBe(result.middle.length);\n    expect(result.upper.length).toBe(result.lower.length);\n  });\n\n  test('upper band should be above middle, middle above lower', async () => {\n    const result = await calculateBBands(mockData);\n\n    const latestUpper = getLatestValue(result.upper);\n    const latestMiddle = getLatestValue(result.middle);\n    const latestLower = getLatestValue(result.lower);\n\n    expect(latestUpper).toBeDefined();\n    expect(latestMiddle).toBeDefined();\n    expect(latestLower).toBeDefined();\n\n    expect(latestUpper!).toBeGreaterThan(latestMiddle!);\n    expect(latestMiddle!).toBeGreaterThan(latestLower!);\n  });\n\n  test('middle band should be SMA', async () => {\n    const bbands = await calculateBBands(mockData, 20, 2);\n    const sma = await calculateSMA(mockData, 20);\n\n    const latestBBMiddle = getLatestValue(bbands.middle);\n    const latestSMA = getLatestValue(sma);\n\n    // Middle band should equal SMA (with floating point tolerance)\n    expect(Math.abs(latestBBMiddle! - latestSMA!)).toBeLessThan(0.0001);\n  });\n\n  test('bandwidth should increase with stdDev multiplier', async () => {\n    const bbands1 = await calculateBBands(mockData, 20, 1);\n    const bbands2 = await calculateBBands(mockData, 20, 2);\n\n    const bandwidth1 = getLatestValue(bbands1.upper)! - getLatestValue(bbands1.lower)!;\n    const bandwidth2 = getLatestValue(bbands2.upper)! - getLatestValue(bbands2.lower)!;\n\n    expect(bandwidth2).toBeGreaterThan(bandwidth1);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(10);\n    await expect(calculateBBands(shortData, 20, 2)).rejects.toThrow('Insufficient data');\n  });\n\n  test('price should generally stay within bands', async () => {\n    const result = await calculateBBands(mockData, 20, 2);\n\n    let withinBands = 0;\n    let totalBars = 0;\n\n    for (let i = result.upper.length - 50; i < result.upper.length; i++) {\n      const price = mockData[mockData.length - (result.upper.length - i)].close;\n      const upper = result.upper[i];\n      const lower = result.lower[i];\n\n      if (price >= lower && price <= upper) {\n        withinBands++;\n      }\n      totalBars++;\n    }\n\n    // Statistically, ~95% of prices should be within 2 std dev bands\n    const percentageWithin = (withinBands / totalBars) * 100;\n    expect(percentageWithin).toBeGreaterThan(70); // Allow some variance\n  });\n});\n\ndescribe('Calculator V2 - ATR (Average True Range)', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate ATR with default period (14)', async () => {\n    const result = await calculateATR(mockData);\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  test('should calculate ATR with custom period (7)', async () => {\n    const result = await calculateATR(mockData, 7);\n\n    expect(result).toBeDefined();\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  test('ATR values should be positive', async () => {\n    const result = await calculateATR(mockData, 14);\n\n    result.forEach((value) => {\n      expect(value).toBeGreaterThan(0);\n    });\n  });\n\n  test('ATR should measure volatility', async () => {\n    const result = await calculateATR(mockData, 14);\n    const latestATR = getLatestValue(result);\n    const latestClose = mockData[mockData.length - 1].close;\n\n    expect(latestATR).toBeDefined();\n\n    // ATR as percentage of price (typically 1-5% for crypto)\n    const atrPercent = (latestATR! / latestClose) * 100;\n\n    expect(atrPercent).toBeGreaterThan(0);\n    expect(atrPercent).toBeLessThan(20); // Reasonable upper bound\n  });\n\n  test('longer period should smooth ATR', async () => {\n    const atr7 = await calculateATR(mockData, 7);\n    const atr21 = await calculateATR(mockData, 21);\n\n    // Both should have values\n    expect(atr7.length).toBeGreaterThan(0);\n    expect(atr21.length).toBeGreaterThan(0);\n\n    // Calculate standard deviation of last 20 values\n    const calcStdDev = (values: number[]) => {\n      const slice = values.slice(-20);\n      const mean = slice.reduce((a, b) => a + b, 0) / slice.length;\n      const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / slice.length;\n      return Math.sqrt(variance);\n    };\n\n    const stdDev7 = calcStdDev(atr7);\n    const stdDev21 = calcStdDev(atr21);\n\n    // Longer period should have lower volatility (more smooth)\n    expect(stdDev21).toBeLessThanOrEqual(stdDev7 * 1.5); // Allow some variance\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(10);\n    await expect(calculateATR(shortData, 14)).rejects.toThrow('Insufficient data');\n  });\n\n  test('ATR should reflect high/low range', async () => {\n    // Create data with known high volatility\n    const volatileData = generateMockOHLCV(50).map((bar, i) => ({\n      ...bar,\n      high: bar.close * 1.05, // 5% above close\n      low: bar.close * 0.95,  // 5% below close\n    }));\n\n    const atr = await calculateATR(volatileData, 14);\n    const latestATR = getLatestValue(atr);\n    const latestClose = volatileData[volatileData.length - 1].close;\n\n    // ATR should reflect the ~10% range\n    const atrPercent = (latestATR! / latestClose) * 100;\n    expect(atrPercent).toBeGreaterThan(2); // Should show significant volatility\n  });\n});\n\ndescribe('Calculator V2 - Integration Tests', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate multiple indicators on same data', async () => {\n    const rsi = await calculateRSI(mockData, 14);\n    const macd = await calculateMACD(mockData, 12, 26, 9);\n    const bbands = await calculateBBands(mockData, 20, 2);\n    const atr = await calculateATR(mockData, 14);\n    const ema = await calculateEMA(mockData, 20);\n\n    expect(rsi.length).toBeGreaterThan(0);\n    expect(macd.macd.length).toBeGreaterThan(0);\n    expect(bbands.upper.length).toBeGreaterThan(0);\n    expect(atr.length).toBeGreaterThan(0);\n    expect(ema.length).toBeGreaterThan(0);\n  });\n\n  test('indicators should handle edge cases', async () => {\n    // Test with minimum data\n    const minData = generateMockOHLCV(30);\n\n    await expect(calculateRSI(minData, 14)).resolves.toBeDefined();\n    await expect(calculateEMA(minData, 20)).resolves.toBeDefined();\n    await expect(calculateATR(minData, 14)).resolves.toBeDefined();\n  });\n\n  test('performance - should calculate indicators quickly', async () => {\n    const largeData = generateMockOHLCV(1000);\n\n    const startTime = Date.now();\n\n    await calculateRSI(largeData, 14);\n    await calculateMACD(largeData, 12, 26, 9);\n    await calculateBBands(largeData, 20, 2);\n    await calculateATR(largeData, 14);\n    await calculateEMA(largeData, 20);\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n\n    // All 5 indicators should calculate in under 1 second\n    expect(duration).toBeLessThan(1000);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/utils/__tests__/custom-indicators.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'diff1' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":171,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":171,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'diff2' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":172,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Custom Indicators - Unit Tests\n * Tests for custom technical indicators\n *\n * @module indicators/utils/__tests__/custom-indicators\n */\n\nimport { describe, test, expect, beforeAll } from 'bun:test';\nimport {\n  calculateSuperTrend,\n  calculateIchimoku,\n  calculatePivotPoints,\n  calculateFibonacciRetracement,\n} from '../custom-indicators';\nimport type { OHLCVData } from '../../types/indicators-full.types';\n\n// ============================================================================\n// MOCK DATA\n// ============================================================================\n\n/**\n * Generate realistic OHLCV mock data\n * Simulates BTC/USDT price movement\n */\nfunction generateMockOHLCV(bars: number = 100, startPrice: number = 50000): OHLCVData[] {\n  const data: OHLCVData[] = [];\n  let currentPrice = startPrice;\n  const baseDate = new Date('2024-01-01T00:00:00Z');\n\n  for (let i = 0; i < bars; i++) {\n    // Simulate realistic price movement (±2% per bar)\n    const change = (Math.random() - 0.5) * 0.04; // -2% to +2%\n    currentPrice = currentPrice * (1 + change);\n\n    const high = currentPrice * (1 + Math.random() * 0.01); // +0-1%\n    const low = currentPrice * (1 - Math.random() * 0.01);  // -0-1%\n    const open = low + Math.random() * (high - low);\n    const close = low + Math.random() * (high - low);\n    const volume = 100 + Math.random() * 1000;\n\n    data.push({\n      timestamp: new Date(baseDate.getTime() + i * 60000), // 1 minute bars\n      open,\n      high,\n      low,\n      close,\n      volume,\n    });\n  }\n\n  return data;\n}\n\n/**\n * Generate uptrending data for SuperTrend/Ichimoku\n */\nfunction generateUptrendData(bars: number = 100): OHLCVData[] {\n  const data: OHLCVData[] = [];\n  let currentPrice = 50000;\n  const baseDate = new Date('2024-01-01T00:00:00Z');\n\n  for (let i = 0; i < bars; i++) {\n    // Consistent uptrend with small pullbacks\n    const change = Math.random() * 0.015 - 0.005; // -0.5% to +1.5%\n    currentPrice = currentPrice * (1 + change);\n\n    const high = currentPrice * 1.005;\n    const low = currentPrice * 0.995;\n    const open = (high + low) / 2;\n    const close = low + Math.random() * (high - low);\n    const volume = 100 + Math.random() * 1000;\n\n    data.push({\n      timestamp: new Date(baseDate.getTime() + i * 60000),\n      open,\n      high,\n      low,\n      close,\n      volume,\n    });\n  }\n\n  return data;\n}\n\n// ============================================================================\n// TEST SUITES\n// ============================================================================\n\ndescribe('Custom Indicators - SuperTrend', () => {\n  let mockData: OHLCVData[];\n  let uptrendData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n    uptrendData = generateUptrendData(100);\n  });\n\n  test('should calculate SuperTrend with default parameters (10, 3)', async () => {\n    const result = await calculateSuperTrend(mockData, 10, 3);\n\n    expect(result).toBeDefined();\n    expect(result.supertrend).toBeDefined();\n    expect(result.direction).toBeDefined();\n    expect(result.signal).toBeDefined();\n\n    expect(Array.isArray(result.supertrend)).toBe(true);\n    expect(Array.isArray(result.direction)).toBe(true);\n    expect(Array.isArray(result.signal)).toBe(true);\n  });\n\n  test('should calculate SuperTrend with custom parameters', async () => {\n    const result = await calculateSuperTrend(mockData, 14, 2);\n\n    expect(result.supertrend.length).toBe(mockData.length);\n    expect(result.direction.length).toBe(mockData.length);\n    expect(result.signal.length).toBe(mockData.length);\n  });\n\n  test('SuperTrend arrays should have same length as input data', async () => {\n    const result = await calculateSuperTrend(mockData, 10, 3);\n\n    expect(result.supertrend.length).toBe(mockData.length);\n    expect(result.direction.length).toBe(mockData.length);\n    expect(result.signal.length).toBe(mockData.length);\n  });\n\n  test('direction should be either \"up\" or \"down\"', async () => {\n    const result = await calculateSuperTrend(mockData, 10, 3);\n\n    result.direction.forEach((dir) => {\n      expect(['up', 'down']).toContain(dir);\n    });\n  });\n\n  test('signal should be \"buy\", \"sell\", or \"hold\"', async () => {\n    const result = await calculateSuperTrend(mockData, 10, 3);\n\n    result.signal.forEach((sig) => {\n      expect(['buy', 'sell', 'hold']).toContain(sig);\n    });\n  });\n\n  test('should detect buy signals in uptrend', async () => {\n    const result = await calculateSuperTrend(uptrendData, 10, 3);\n\n    // Count buy signals\n    const buySignals = result.signal.filter((s) => s === 'buy').length;\n\n    // In an uptrend, there should be at least some buy signals\n    expect(buySignals).toBeGreaterThan(0);\n  });\n\n  test('SuperTrend values should be positive', async () => {\n    const result = await calculateSuperTrend(mockData, 10, 3);\n\n    result.supertrend.forEach((value) => {\n      expect(value).toBeGreaterThan(0);\n    });\n  });\n\n  test('larger multiplier should widen SuperTrend bands', async () => {\n    const result1 = await calculateSuperTrend(mockData, 10, 2);\n    const result2 = await calculateSuperTrend(mockData, 10, 4);\n\n    // With larger multiplier, SuperTrend values should differ more from price\n    const lastPrice = mockData[mockData.length - 1].close;\n    const st1 = result1.supertrend[result1.supertrend.length - 1];\n    const st2 = result2.supertrend[result2.supertrend.length - 1];\n\n    const diff1 = Math.abs(lastPrice - st1);\n    const diff2 = Math.abs(lastPrice - st2);\n\n    // Larger multiplier typically creates wider bands\n    // But direction matters, so just check they're different\n    expect(st1).not.toBe(st2);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(5);\n    await expect(calculateSuperTrend(shortData, 10, 3)).rejects.toThrow('Insufficient data');\n  });\n\n  test('should validate parameters', async () => {\n    await expect(calculateSuperTrend(mockData, 0, 3)).rejects.toThrow();\n    await expect(calculateSuperTrend(mockData, 10, 0)).rejects.toThrow();\n  });\n});\n\ndescribe('Custom Indicators - Ichimoku Cloud', () => {\n  let mockData: OHLCVData[];\n  let uptrendData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n    uptrendData = generateUptrendData(100);\n  });\n\n  test('should calculate Ichimoku with default parameters (9, 26, 52, 26)', async () => {\n    const result = await calculateIchimoku(mockData, 9, 26, 52, 26);\n\n    expect(result).toBeDefined();\n    expect(result.tenkanSen).toBeDefined();\n    expect(result.kijunSen).toBeDefined();\n    expect(result.senkouSpanA).toBeDefined();\n    expect(result.senkouSpanB).toBeDefined();\n    expect(result.chikouSpan).toBeDefined();\n    expect(result.cloudColor).toBeDefined();\n    expect(result.signal).toBeDefined();\n\n    expect(Array.isArray(result.tenkanSen)).toBe(true);\n    expect(Array.isArray(result.kijunSen)).toBe(true);\n    expect(Array.isArray(result.senkouSpanA)).toBe(true);\n    expect(Array.isArray(result.senkouSpanB)).toBe(true);\n    expect(Array.isArray(result.chikouSpan)).toBe(true);\n    expect(Array.isArray(result.cloudColor)).toBe(true);\n    expect(Array.isArray(result.signal)).toBe(true);\n  });\n\n  test('all Ichimoku lines should have same length as input data', async () => {\n    const result = await calculateIchimoku(mockData, 9, 26, 52, 26);\n\n    expect(result.tenkanSen.length).toBe(mockData.length);\n    expect(result.kijunSen.length).toBe(mockData.length);\n    expect(result.senkouSpanA.length).toBe(mockData.length);\n    expect(result.senkouSpanB.length).toBe(mockData.length);\n    expect(result.chikouSpan.length).toBe(mockData.length);\n    expect(result.cloudColor.length).toBe(mockData.length);\n    expect(result.signal.length).toBe(mockData.length);\n  });\n\n  test('cloudColor should be \"bullish\" or \"bearish\"', async () => {\n    const result = await calculateIchimoku(mockData, 9, 26, 52, 26);\n\n    result.cloudColor.forEach((color) => {\n      expect(['bullish', 'bearish']).toContain(color);\n    });\n  });\n\n  test('signal should be valid trading signal', async () => {\n    const result = await calculateIchimoku(mockData, 9, 26, 52, 26);\n\n    result.signal.forEach((sig) => {\n      expect(['strong-buy', 'buy', 'neutral', 'sell', 'strong-sell']).toContain(sig);\n    });\n  });\n\n  test('should detect bullish signals in uptrend', async () => {\n    const result = await calculateIchimoku(uptrendData, 9, 26, 52, 26);\n\n    // Count bullish signals\n    const bullishSignals = result.signal.filter((s) => s === 'strong-buy' || s === 'buy').length;\n\n    // In an uptrend, there should be some bullish signals\n    expect(bullishSignals).toBeGreaterThan(0);\n  });\n\n  test('Tenkan-sen should be more responsive than Kijun-sen', async () => {\n    const result = await calculateIchimoku(mockData, 9, 26, 52, 26);\n\n    // Tenkan-sen (9 period) should change more than Kijun-sen (26 period)\n    // Just verify they're different\n    const lastTenkan = result.tenkanSen[result.tenkanSen.length - 1];\n    const lastKijun = result.kijunSen[result.kijunSen.length - 1];\n\n    expect(typeof lastTenkan).toBe('number');\n    expect(typeof lastKijun).toBe('number');\n  });\n\n  test('Senkou Span A should be average of Tenkan and Kijun', async () => {\n    const result = await calculateIchimoku(mockData, 9, 26, 52, 26);\n\n    // Check last value\n    const lastIdx = result.tenkanSen.length - 1;\n    const expectedSpanA = (result.tenkanSen[lastIdx] + result.kijunSen[lastIdx]) / 2;\n    const actualSpanA = result.senkouSpanA[lastIdx];\n\n    expect(Math.abs(actualSpanA - expectedSpanA)).toBeLessThan(0.0001);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const shortData = generateMockOHLCV(50);\n    await expect(calculateIchimoku(shortData, 9, 26, 52, 26)).rejects.toThrow('Insufficient data');\n  });\n\n  test('should validate parameters', async () => {\n    await expect(calculateIchimoku(mockData, 0, 26, 52, 26)).rejects.toThrow();\n    await expect(calculateIchimoku(mockData, 9, 0, 52, 26)).rejects.toThrow();\n    await expect(calculateIchimoku(mockData, 9, 26, 0, 26)).rejects.toThrow();\n  });\n});\n\ndescribe('Custom Indicators - Pivot Points', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(50);\n  });\n\n  test('should calculate Classic Pivot Points', async () => {\n    const result = await calculatePivotPoints(mockData, 'classic');\n\n    expect(result).toBeDefined();\n    expect(result.pivot).toBeDefined();\n    expect(result.r1).toBeDefined();\n    expect(result.r2).toBeDefined();\n    expect(result.r3).toBeDefined();\n    expect(result.s1).toBeDefined();\n    expect(result.s2).toBeDefined();\n    expect(result.s3).toBeDefined();\n    expect(result.position).toBeDefined();\n\n    expect(typeof result.pivot).toBe('number');\n    expect(typeof result.r1).toBe('number');\n    expect(typeof result.r2).toBe('number');\n    expect(typeof result.r3).toBe('number');\n    expect(typeof result.s1).toBe('number');\n    expect(typeof result.s2).toBe('number');\n    expect(typeof result.s3).toBe('number');\n  });\n\n  test('should calculate Fibonacci Pivot Points', async () => {\n    const result = await calculatePivotPoints(mockData, 'fibonacci');\n\n    expect(result.pivot).toBeDefined();\n    expect(result.r1).toBeGreaterThan(result.pivot);\n    expect(result.s1).toBeLessThan(result.pivot);\n  });\n\n  test('should calculate Woodie Pivot Points', async () => {\n    const result = await calculatePivotPoints(mockData, 'woodie');\n\n    expect(result.pivot).toBeDefined();\n    expect(result.r1).toBeGreaterThan(result.pivot);\n    expect(result.s1).toBeLessThan(result.pivot);\n  });\n\n  test('should calculate Camarilla Pivot Points', async () => {\n    const result = await calculatePivotPoints(mockData, 'camarilla');\n\n    expect(result.pivot).toBeDefined();\n    expect(result.r1).toBeDefined();\n    expect(result.s1).toBeDefined();\n\n    // Camarilla uses close-based calculation, so R1/S1 relationship to pivot may vary\n    // Just verify they're valid numbers\n    expect(typeof result.r1).toBe('number');\n    expect(typeof result.s1).toBe('number');\n  });\n\n  test('resistance levels should be in ascending order', async () => {\n    const result = await calculatePivotPoints(mockData, 'classic');\n\n    expect(result.r1).toBeLessThan(result.r2);\n    expect(result.r2).toBeLessThan(result.r3);\n  });\n\n  test('support levels should be in descending order', async () => {\n    const result = await calculatePivotPoints(mockData, 'classic');\n\n    expect(result.s1).toBeGreaterThan(result.s2);\n    expect(result.s2).toBeGreaterThan(result.s3);\n  });\n\n  test('pivot should be between S1 and R1', async () => {\n    const result = await calculatePivotPoints(mockData, 'classic');\n\n    expect(result.pivot).toBeGreaterThan(result.s1);\n    expect(result.pivot).toBeLessThan(result.r1);\n  });\n\n  test('position should be valid', async () => {\n    const result = await calculatePivotPoints(mockData, 'classic');\n\n    const validPositions = [\n      'above-R3',\n      'R2-R3',\n      'R1-R2',\n      'P-R1',\n      'S1-P',\n      'S2-S1',\n      'S3-S2',\n      'below-S3',\n    ];\n\n    expect(validPositions).toContain(result.position);\n  });\n\n  test('different methods should produce different values', async () => {\n    const classic = await calculatePivotPoints(mockData, 'classic');\n    const fibonacci = await calculatePivotPoints(mockData, 'fibonacci');\n    const woodie = await calculatePivotPoints(mockData, 'woodie');\n    const camarilla = await calculatePivotPoints(mockData, 'camarilla');\n\n    // Classic, Fibonacci, and Camarilla use (H+L+C)/3 for pivot\n    // Woodie uses (H+L+2C)/4 for pivot, so it should be different\n    expect(classic.pivot).toBe(fibonacci.pivot); // Same formula\n    expect(classic.pivot).toBe(camarilla.pivot); // Same formula\n    expect(classic.pivot).not.toBe(woodie.pivot); // Different formula\n\n    // R1/S1 calculations differ between methods\n    expect(classic.r1).not.toBe(fibonacci.r1);\n    expect(classic.s1).not.toBe(fibonacci.s1);\n\n    // At least woodie pivot should be unique\n    const uniquePivots = new Set([classic.pivot, woodie.pivot]);\n    expect(uniquePivots.size).toBe(2);\n  });\n\n  test('should throw error for insufficient data', async () => {\n    const emptyData: OHLCVData[] = [];\n    await expect(calculatePivotPoints(emptyData, 'classic')).rejects.toThrow();\n  });\n});\n\ndescribe('Custom Indicators - Fibonacci Retracement', () => {\n  test('should calculate Fibonacci retracement for uptrend', async () => {\n    const result = await calculateFibonacciRetracement(52000, 48000, 'uptrend');\n\n    expect(result).toBeDefined();\n    expect(result.level_0).toBe(48000); // 0% = low\n    expect(result.level_100).toBe(52000); // 100% = high\n    expect(result.level_236).toBeGreaterThan(result.level_0);\n    expect(result.level_382).toBeGreaterThan(result.level_236);\n    expect(result.level_500).toBeGreaterThan(result.level_382);\n    expect(result.level_618).toBeGreaterThan(result.level_500);\n    expect(result.level_786).toBeGreaterThan(result.level_618);\n  });\n\n  test('should calculate Fibonacci retracement for downtrend', async () => {\n    const result = await calculateFibonacciRetracement(52000, 48000, 'downtrend');\n\n    expect(result).toBeDefined();\n    expect(result.level_0).toBe(52000); // 0% = high\n    expect(result.level_100).toBe(48000); // 100% = low\n    expect(result.level_236).toBeLessThan(result.level_0);\n    expect(result.level_382).toBeLessThan(result.level_236);\n    expect(result.level_500).toBeLessThan(result.level_382);\n    expect(result.level_618).toBeLessThan(result.level_500);\n    expect(result.level_786).toBeLessThan(result.level_618);\n  });\n\n  test('50% level should be midpoint of high and low', async () => {\n    const high = 52000;\n    const low = 48000;\n    const result = await calculateFibonacciRetracement(high, low, 'uptrend');\n\n    const expectedMidpoint = (high + low) / 2;\n    expect(result.level_500).toBe(expectedMidpoint);\n  });\n\n  test('should calculate extension levels beyond 100%', async () => {\n    const result = await calculateFibonacciRetracement(52000, 48000, 'uptrend');\n\n    expect(result.level_1272).toBeGreaterThan(result.level_100);\n    expect(result.level_1618).toBeGreaterThan(result.level_1272);\n  });\n\n  test('should find nearest level to current price', async () => {\n    const high = 52000;\n    const low = 48000;\n    const currentPrice = 50000; // Close to 50% level\n\n    const result = await calculateFibonacciRetracement(high, low, 'uptrend', currentPrice);\n\n    expect(result.nearestLevel).toBeDefined();\n    expect(result.nearestLevelName).toBeDefined();\n    expect(typeof result.nearestLevel).toBe('number');\n    expect(typeof result.nearestLevelName).toBe('string');\n\n    // Nearest should be 50% level\n    expect(result.nearestLevelName).toBe('50%');\n    expect(result.nearestLevel).toBe(result.level_500);\n  });\n\n  test('nearest level should be closest to current price', async () => {\n    const high = 52000;\n    const low = 48000;\n    const currentPrice = 48944; // Very close to 23.6% level\n\n    const result = await calculateFibonacciRetracement(high, low, 'uptrend', currentPrice);\n\n    // Should find 23.6% as nearest\n    expect(result.nearestLevelName).toBe('23.6%');\n  });\n\n  test('golden ratio (61.8%) should be between 50% and 78.6%', async () => {\n    const result = await calculateFibonacciRetracement(52000, 48000, 'uptrend');\n\n    expect(result.level_618).toBeGreaterThan(result.level_500);\n    expect(result.level_618).toBeLessThan(result.level_786);\n  });\n\n  test('should throw error if high <= low', async () => {\n    await expect(calculateFibonacciRetracement(48000, 52000, 'uptrend')).rejects.toThrow(\n      'High must be greater than low'\n    );\n  });\n\n  test('should handle equal high and low gracefully', async () => {\n    await expect(calculateFibonacciRetracement(50000, 50000, 'uptrend')).rejects.toThrow();\n  });\n\n  test('Fibonacci levels should be mathematically correct', async () => {\n    const high = 100;\n    const low = 0;\n    const result = await calculateFibonacciRetracement(high, low, 'uptrend');\n\n    // Test exact percentages\n    expect(result.level_0).toBe(0);\n    expect(result.level_236).toBeCloseTo(23.6, 1);\n    expect(result.level_382).toBeCloseTo(38.2, 1);\n    expect(result.level_500).toBe(50);\n    expect(result.level_618).toBeCloseTo(61.8, 1);\n    expect(result.level_786).toBeCloseTo(78.6, 1);\n    expect(result.level_100).toBe(100);\n    expect(result.level_1272).toBeCloseTo(127.2, 1);\n    expect(result.level_1618).toBeCloseTo(161.8, 1);\n  });\n});\n\ndescribe('Custom Indicators - Integration Tests', () => {\n  let mockData: OHLCVData[];\n\n  beforeAll(() => {\n    mockData = generateMockOHLCV(100);\n  });\n\n  test('should calculate multiple custom indicators on same data', async () => {\n    const supertrend = await calculateSuperTrend(mockData, 10, 3);\n    const ichimoku = await calculateIchimoku(mockData, 9, 26, 52, 26);\n    const pivots = await calculatePivotPoints(mockData, 'classic');\n    const fib = await calculateFibonacciRetracement(52000, 48000, 'uptrend', 50000);\n\n    expect(supertrend.supertrend.length).toBeGreaterThan(0);\n    expect(ichimoku.tenkanSen.length).toBeGreaterThan(0);\n    expect(pivots.pivot).toBeGreaterThan(0);\n    expect(fib.level_618).toBeGreaterThan(0);\n  });\n\n  test('performance - custom indicators should calculate quickly', async () => {\n    const largeData = generateMockOHLCV(1000);\n\n    const startTime = Date.now();\n\n    await calculateSuperTrend(largeData, 10, 3);\n    await calculateIchimoku(largeData, 9, 26, 52, 26);\n    await calculatePivotPoints(largeData, 'classic');\n    await calculateFibonacciRetracement(52000, 48000, 'uptrend', 50000);\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n\n    // All 4 custom indicators should calculate in under 1 second\n    expect(duration).toBeLessThan(1000);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/utils/calculator-v2.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fastLimit' is assigned a value but never used. Allowed unused args must match /^_/u.","line":220,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":220,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'slowLimit' is assigned a value but never used. Allowed unused args must match /^_/u.","line":220,"column":81,"nodeType":null,"messageId":"unusedVar","endLine":220,"endColumn":90},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'period' is assigned a value but never used. Allowed unused args must match /^_/u.","line":1241,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":1241,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'series2' is defined but never used. Allowed unused args must match /^_/u.","line":1264,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":1264,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'conversionPeriod' is assigned a value but never used. Allowed unused args must match /^_/u.","line":1284,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":1284,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'basePeriod' is assigned a value but never used. Allowed unused args must match /^_/u.","line":1285,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":1285,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Complete Indicator Calculator V2\n * All 106 indicators from @ixjb94/indicators library\n * Optimized wrappers with validation and error handling\n *\n * @module indicators/utils/calculator-v2\n */\n\nimport { Indicators } from '@ixjb94/indicators';\nimport type { OHLCVData } from '../types/indicators-full.types';\n// import logger from '../../../utils/logger'; // Commented out - not actively used\n\n// Initialize indicators instance (singleton)\nconst indicators = new Indicators();\n\n// ============================================================================\n// DATA CONVERSION HELPERS\n// ============================================================================\n\n/**\n * Extract specific OHLCV field as number array\n */\nexport function extractField(data: OHLCVData[], field: keyof Omit<OHLCVData, 'timestamp'>): number[] {\n  return data.map((candle) => candle[field]);\n}\n\n/**\n * Get close prices from OHLCV data\n */\nexport function getClosePrices(data: OHLCVData[]): number[] {\n  return extractField(data, 'close');\n}\n\n/**\n * Get high prices from OHLCV data\n */\nexport function getHighPrices(data: OHLCVData[]): number[] {\n  return extractField(data, 'high');\n}\n\n/**\n * Get low prices from OHLCV data\n */\nexport function getLowPrices(data: OHLCVData[]): number[] {\n  return extractField(data, 'low');\n}\n\n/**\n * Get open prices from OHLCV data\n */\nexport function getOpenPrices(data: OHLCVData[]): number[] {\n  return extractField(data, 'open');\n}\n\n/**\n * Get volumes from OHLCV data\n */\nexport function getVolumes(data: OHLCVData[]): number[] {\n  return extractField(data, 'volume');\n}\n\n// ============================================================================\n// VALIDATION HELPERS\n// ============================================================================\n\n/**\n * Validate if we have enough data for calculation\n */\nexport function validateDataLength(data: OHLCVData[], minLength: number, indicatorName: string): void {\n  if (!data || data.length === 0) {\n    throw new Error(`No data provided for ${indicatorName} calculation`);\n  }\n\n  if (data.length < minLength) {\n    throw new Error(`Insufficient data for ${indicatorName}: need at least ${minLength} candles, got ${data.length}`);\n  }\n}\n\n/**\n * Validate parameter value\n */\nexport function validateParameter(value: any, name: string, min: number, max?: number): void {\n  if (value === undefined || value === null) {\n    throw new Error(`Parameter '${name}' is required`);\n  }\n\n  if (typeof value !== 'number') {\n    throw new Error(`Parameter '${name}' must be a number`);\n  }\n\n  if (value < min) {\n    throw new Error(`Parameter '${name}' must be at least ${min}`);\n  }\n\n  if (max !== undefined && value > max) {\n    throw new Error(`Parameter '${name}' must be at most ${max}`);\n  }\n}\n\n// ============================================================================\n// TREND / MOVING AVERAGES (19 indicators)\n// ============================================================================\n\n/**\n * Calculate SMA (Simple Moving Average)\n */\nexport async function calculateSMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'SMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.sma(close, period);\n}\n\n/**\n * Calculate EMA (Exponential Moving Average)\n */\nexport async function calculateEMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'EMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.ema(close, period);\n}\n\n/**\n * Calculate WMA (Weighted Moving Average)\n */\nexport async function calculateWMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'WMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.wma(close, period);\n}\n\n/**\n * Calculate DEMA (Double Exponential Moving Average)\n */\nexport async function calculateDEMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period * 2, 'DEMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.dema(close, period);\n}\n\n/**\n * Calculate TEMA (Triple Exponential Moving Average)\n */\nexport async function calculateTEMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period * 3, 'TEMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.tema(close, period);\n}\n\n/**\n * Calculate HMA (Hull Moving Average)\n * Very popular in crypto trading\n */\nexport async function calculateHMA(data: OHLCVData[], period: number = 9): Promise<number[]> {\n  validateDataLength(data, period * 2, 'HMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.hma(close, period);\n}\n\n/**\n * Calculate KAMA (Kaufman Adaptive Moving Average)\n */\nexport async function calculateKAMA(data: OHLCVData[], period: number = 10): Promise<number[]> {\n  validateDataLength(data, period + 1, 'KAMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.kama(close, period);\n}\n\n/**\n * Calculate ZLEMA (Zero-Lag EMA)\n */\nexport async function calculateZLEMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'ZLEMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.zlema(close, period);\n}\n\n/**\n * Calculate VWMA (Volume Weighted Moving Average)\n */\nexport async function calculateVWMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'VWMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.vwma(close, volume, period);\n}\n\n/**\n * Calculate ALMA (Arnaud Legoux Moving Average)\n */\nexport async function calculateALMA(data: OHLCVData[], period: number = 9, offset: number = 0.85, sigma: number = 6): Promise<number[]> {\n  validateDataLength(data, period, 'ALMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.alma(close, period, offset, sigma);\n}\n\n/**\n * Calculate TRIMA (Triangular Moving Average)\n */\nexport async function calculateTRIMA(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'TRIMA');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.trima(close, period);\n}\n\n/**\n * Calculate MAMA (MESA Adaptive Moving Average)\n * NOTE: Not implemented in @ixjb94/indicators v1.2.4\n */\nexport async function calculateMAMA(data: OHLCVData[], fastLimit: number = 0.5, slowLimit: number = 0.05): Promise<number[]> {\n  throw new Error('MAMA indicator is not yet implemented in @ixjb94/indicators library');\n}\n\n/**\n * Calculate CCI (Commodity Channel Index)\n */\nexport async function calculateCCI(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'CCI');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.cci(high, low, close, period);\n}\n\n/**\n * Calculate MACD (Moving Average Convergence Divergence)\n * Library returns [macd, signal, histogram]\n */\nexport async function calculateMACD(\n  data: OHLCVData[],\n  fastPeriod: number = 12,\n  slowPeriod: number = 26,\n  signalPeriod: number = 9\n): Promise<{ macd: number[]; signal: number[]; histogram: number[] }> {\n  const minLength = Math.max(fastPeriod, slowPeriod) + signalPeriod;\n  validateDataLength(data, minLength, 'MACD');\n  const close = getClosePrices(data);\n  const [macd, signal, histogram] = await indicators.macd(close, fastPeriod, slowPeriod, signalPeriod);\n  return { macd, signal, histogram };\n}\n\n/**\n * Calculate Market Facilitation Index\n */\nexport async function calculateMarketFI(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'MarketFI');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const volume = getVolumes(data);\n  return await indicators.marketfi(high, low, volume);\n}\n\n/**\n * Calculate MASS Index\n */\nexport async function calculateMASS(data: OHLCVData[], period: number = 25): Promise<number[]> {\n  validateDataLength(data, period * 2, 'MASS');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.mass(high, low, period);\n}\n\n/**\n * Calculate MAX (Maximum value over period)\n */\nexport async function calculateMAX(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'MAX');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.max(close, period);\n}\n\n/**\n * Normalize data between 0 and 1\n * Library signature: normalize(originalLength, source, empty?)\n */\nexport async function calculateNormalize(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'Normalize');\n  const close = getClosePrices(data);\n  return await indicators.normalize(data.length, close);\n}\n\n/**\n * Alternative normalization method\n * Library signature: normalize2(source, length)\n */\nexport async function calculateNormalize2(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'Normalize2');\n  const close = getClosePrices(data);\n  return await indicators.normalize2(close, data.length);\n}\n\n// ============================================================================\n// MOMENTUM INDICATORS (9 indicators)\n// ============================================================================\n\n/**\n * Calculate RSI (Relative Strength Index)\n */\nexport async function calculateRSI(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period + 1, 'RSI');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.rsi(close, period);\n}\n\n/**\n * Calculate Stochastic RSI\n * NOTE: Library only accepts 2 parameters (source, period) and returns single array\n */\nexport async function calculateStochRSI(\n  data: OHLCVData[],\n  period: number = 14\n): Promise<number[]> {\n  validateDataLength(data, period * 2, 'StochRSI');\n  const close = getClosePrices(data);\n  return await indicators.stochrsi(close, period);\n}\n\n/**\n * Calculate Stochastic Oscillator\n * Library returns [stoch, stoch_ma]\n */\nexport async function calculateStoch(\n  data: OHLCVData[],\n  kPeriod: number = 14,\n  kSlowing: number = 3,\n  dPeriod: number = 3\n): Promise<{ k: number[]; d: number[] }> {\n  validateDataLength(data, kPeriod + kSlowing + dPeriod, 'Stoch');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const [k, d] = await indicators.stoch(high, low, close, kPeriod, kSlowing, dPeriod);\n  return { k, d };\n}\n\n/**\n * Calculate ROC (Rate of Change)\n */\nexport async function calculateROC(data: OHLCVData[], period: number = 12): Promise<number[]> {\n  validateDataLength(data, period + 1, 'ROC');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.roc(close, period);\n}\n\n/**\n * Calculate ROCR (Rate of Change Ratio)\n */\nexport async function calculateROCR(data: OHLCVData[], period: number = 12): Promise<number[]> {\n  validateDataLength(data, period + 1, 'ROCR');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.rocr(close, period);\n}\n\n/**\n * Calculate MFI (Money Flow Index)\n */\nexport async function calculateMFI(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period + 1, 'MFI');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.mfi(high, low, close, volume, period);\n}\n\n/**\n * Calculate CMO (Chande Momentum Oscillator)\n */\nexport async function calculateCMO(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period + 1, 'CMO');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.cmo(close, period);\n}\n\n/**\n * Calculate TSI (True Strength Index)\n */\nexport async function calculateTSI(data: OHLCVData[], longPeriod: number = 25, shortPeriod: number = 13): Promise<number[]> {\n  validateDataLength(data, longPeriod + shortPeriod, 'TSI');\n  const close = getClosePrices(data);\n  return await indicators.tsi(close, longPeriod, shortPeriod);\n}\n\n/**\n * Calculate Fisher Transform\n * Library returns [fisher, signal]\n */\nexport async function calculateFisher(data: OHLCVData[], period: number = 10): Promise<{ fisher: number[]; signal: number[] }> {\n  validateDataLength(data, period, 'Fisher');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const [fisher, signal] = await indicators.fisher(high, low, period);\n  return { fisher, signal };\n}\n\n// ============================================================================\n// VOLATILITY INDICATORS (4 indicators)\n// ============================================================================\n\n/**\n * Calculate ATR (Average True Range)\n */\nexport async function calculateATR(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period + 1, 'ATR');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.atr(high, low, close, period);\n}\n\n/**\n * Calculate NATR (Normalized ATR)\n */\nexport async function calculateNATR(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period + 1, 'NATR');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.natr(high, low, close, period);\n}\n\n/**\n * Calculate Standard Deviation\n */\nexport async function calculateStdDev(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'StdDev');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.stddev(close, period);\n}\n\n/**\n * Calculate Standard Error\n */\nexport async function calculateStdErr(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'StdErr');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  return await indicators.stderr(close, period);\n}\n\n// ============================================================================\n// VOLUME INDICATORS (9 indicators)\n// ============================================================================\n\n/**\n * Calculate OBV (On Balance Volume)\n */\nexport async function calculateOBV(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 2, 'OBV');\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.obv(close, volume);\n}\n\n/**\n * Calculate VWAP (Volume Weighted Average Price)\n * Library signature: vwap(high, low, close, volume, period)\n */\nexport async function calculateVWAP(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'VWAP');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.vwap(high, low, close, volume, period);\n}\n\n/**\n * Calculate AD (Accumulation/Distribution)\n */\nexport async function calculateAD(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'AD');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.ad(high, low, close, volume);\n}\n\n/**\n * Calculate ADOSC (AD Oscillator)\n */\nexport async function calculateADOSC(data: OHLCVData[], fastPeriod: number = 3, slowPeriod: number = 10): Promise<number[]> {\n  validateDataLength(data, slowPeriod, 'ADOSC');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.adosc(high, low, close, volume, fastPeriod, slowPeriod);\n}\n\n/**\n * Calculate CMF (Chaikin Money Flow)\n */\nexport async function calculateCMF(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'CMF');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.cmf(high, low, close, volume, period);\n}\n\n/**\n * Calculate KVO (Klinger Volume Oscillator)\n */\nexport async function calculateKVO(data: OHLCVData[], fastPeriod: number = 34, slowPeriod: number = 55): Promise<number[]> {\n  validateDataLength(data, slowPeriod, 'KVO');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.kvo(high, low, close, volume, fastPeriod, slowPeriod);\n}\n\n/**\n * Calculate WAD (Williams Accumulation/Distribution)\n */\nexport async function calculateWAD(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 2, 'WAD');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.wad(high, low, close);\n}\n\n/**\n * Calculate ADX (Average Directional Index)\n * Library signature: adx(high, low, period) - NO CLOSE!\n */\nexport async function calculateADX(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period * 2, 'ADX');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.adx(high, low, period);\n}\n\n/**\n * Calculate ADXR (ADX Rating)\n * Library signature: adxr(high, low, period) - NO CLOSE!\n */\nexport async function calculateADXR(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period * 3, 'ADXR');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.adxr(high, low, period);\n}\n\n// ============================================================================\n// SUPPORT/RESISTANCE INDICATORS (3 indicators)\n// ============================================================================\n\n/**\n * Calculate Aroon Indicator\n * Library returns [aroon_down, aroon_up]\n */\nexport async function calculateAroon(data: OHLCVData[], period: number = 25): Promise<{ up: number[]; down: number[] }> {\n  validateDataLength(data, period, 'Aroon');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const [down, up] = await indicators.aroon(high, low, period);\n  return { up, down };\n}\n\n/**\n * Calculate Aroon Oscillator\n */\nexport async function calculateAroonOsc(data: OHLCVData[], period: number = 25): Promise<number[]> {\n  validateDataLength(data, period, 'AroonOsc');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.aroonosc(high, low, period);\n}\n\n/**\n * Calculate PSAR (Parabolic SAR)\n */\nexport async function calculatePSAR(data: OHLCVData[], acceleration: number = 0.02, maximum: number = 0.2): Promise<number[]> {\n  validateDataLength(data, 2, 'PSAR');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.psar(high, low, acceleration, maximum);\n}\n\n// ============================================================================\n// BANDS & CHANNELS (6 indicators)\n// ============================================================================\n\n/**\n * Calculate Bollinger Bands\n * Library returns [lower, middle, upper]\n */\nexport async function calculateBBands(\n  data: OHLCVData[],\n  period: number = 20,\n  stdDev: number = 2\n): Promise<{ upper: number[]; middle: number[]; lower: number[] }> {\n  validateDataLength(data, period, 'BBands');\n  validateParameter(period, 'period', 1, 500);\n  const close = getClosePrices(data);\n  const [lower, middle, upper] = await indicators.bbands(close, period, stdDev);\n  return { upper, middle, lower };\n}\n\n/**\n * Calculate Keltner Channels\n */\nexport async function calculateKC(\n  data: OHLCVData[],\n  period: number = 20,\n  multiplier: number = 2\n): Promise<{ upper: number[]; middle: number[]; lower: number[] }> {\n  validateDataLength(data, period, 'KC');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const [lower, middle, upper] = await indicators.kc(high, low, close, period, multiplier);\n  return { upper, middle, lower };\n}\n\n/**\n * Calculate Donchian Channels\n */\nexport async function calculateDC(data: OHLCVData[], period: number = 20): Promise<{ upper: number[]; middle: number[]; lower: number[] }> {\n  validateDataLength(data, period, 'DC');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const [upper, middle, lower] = await indicators.dc(high, low, period);\n  return { upper, middle, lower };\n}\n\n/**\n * Calculate Acceleration Bands\n */\nexport async function calculateABands(\n  data: OHLCVData[],\n  period: number = 20\n): Promise<{ upper: number[]; middle: number[]; lower: number[] }> {\n  validateDataLength(data, period, 'ABands');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const [upper, lower, middle] = await indicators.abands(high, low, close, period);\n  return { upper, middle, lower };\n}\n\n/**\n * Calculate Price Bands\n */\nexport async function calculatePBands(\n  data: OHLCVData[],\n  period: number = 20\n): Promise<{ upper: number[]; middle: number[]; lower: number[] }> {\n  validateDataLength(data, period, 'PBands');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const [lower, upper] = await indicators.pbands(high, low, close, period);\n  const middle = lower.map((l, i) => (l + upper[i]) / 2);\n  return { upper, middle, lower };\n}\n\n/**\n * Calculate Chandelier Exit\n */\nexport async function calculateCE(\n  data: OHLCVData[],\n  period: number = 22,\n  multiplier: number = 3\n): Promise<{ long: number[]; short: number[] }> {\n  validateDataLength(data, period, 'CE');\n  validateParameter(period, 'period', 1, 500);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const [short, long] = await indicators.ce(high, low, close, period, multiplier);\n  return { long, short };\n}\n\n// ============================================================================\n// OSCILLATORS (15 indicators)\n// ============================================================================\n\n/**\n * Calculate AO (Awesome Oscillator)\n */\nexport async function calculateAO(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 5, 'AO');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.ao(high, low);\n}\n\n/**\n * Calculate APO (Absolute Price Oscillator)\n */\nexport async function calculateAPO(data: OHLCVData[], fastPeriod: number = 12, slowPeriod: number = 26): Promise<number[]> {\n  validateDataLength(data, slowPeriod, 'APO');\n  const close = getClosePrices(data);\n  return await indicators.apo(close, fastPeriod, slowPeriod);\n}\n\n/**\n * Calculate BOP (Balance of Power)\n */\nexport async function calculateBOP(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'BOP');\n  const open = getOpenPrices(data);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.bop(open, high, low, close);\n}\n\n/**\n * Calculate CVI (Chaikin Volatility Index)\n */\nexport async function calculateCVI(data: OHLCVData[], period: number = 10): Promise<number[]> {\n  validateDataLength(data, period * 2, 'CVI');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.cvi(high, low, period);\n}\n\n/**\n * Calculate DPO (Detrended Price Oscillator)\n */\nexport async function calculateDPO(data: OHLCVData[], period: number = 20): Promise<number[]> {\n  validateDataLength(data, period, 'DPO');\n  const close = getClosePrices(data);\n  return await indicators.dpo(close, period);\n}\n\n/**\n * Calculate FOSC (Forecast Oscillator)\n */\nexport async function calculateFOSC(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'FOSC');\n  const close = getClosePrices(data);\n  return await indicators.fosc(close, period);\n}\n\n/**\n * Calculate KST (Know Sure Thing)\n */\nexport async function calculateKST(\n  data: OHLCVData[],\n  roc1: number = 10,\n  roc2: number = 15,\n  roc3: number = 20,\n  roc4: number = 30,\n  sma1: number = 10,\n  sma2: number = 10,\n  sma3: number = 10,\n  sma4: number = 15\n): Promise<{ kst: number[]; signal: number[] }> {\n  const minLength = Math.max(roc4, sma4) + 10;\n  validateDataLength(data, minLength, 'KST');\n  const close = getClosePrices(data);\n  const [kst, signal] = await indicators.kst(close, roc1, roc2, roc3, roc4, sma1, sma2, sma3, sma4);\n  return { kst, signal };\n}\n\n/**\n * Calculate POSC (Price Oscillator)\n */\nexport async function calculatePOSC(data: OHLCVData[], period: number = 12, emaPeriod: number = 26): Promise<number[]> {\n  validateDataLength(data, period, 'POSC');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.posc(high, low, close, period, emaPeriod);\n}\n\n/**\n * Calculate PPO (Percentage Price Oscillator)\n */\nexport async function calculatePPO(data: OHLCVData[], fastPeriod: number = 12, slowPeriod: number = 26): Promise<number[]> {\n  validateDataLength(data, slowPeriod, 'PPO');\n  const close = getClosePrices(data);\n  return await indicators.ppo(close, fastPeriod, slowPeriod);\n}\n\n/**\n * Calculate QStick\n */\nexport async function calculateQStick(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'QStick');\n  const open = getOpenPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.qstick(open, close, period);\n}\n\n/**\n * Calculate RVI (Relative Volatility Index)\n */\nexport async function calculateRVI(data: OHLCVData[], smaPeriod: number = 10, stddevPeriod: number = 10): Promise<number[]> {\n  validateDataLength(data, smaPeriod * 2, 'RVI');\n  const close = getClosePrices(data);\n  return await indicators.rvi(close, smaPeriod, stddevPeriod);\n}\n\n/**\n * Calculate SMI (Stochastic Momentum Index)\n */\nexport async function calculateSMI(\n  data: OHLCVData[],\n  kPeriod: number = 5,\n  dPeriod: number = 3\n): Promise<number[]> {\n  validateDataLength(data, kPeriod + dPeriod, 'SMI');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.smi(high, low, close, kPeriod, kPeriod, dPeriod);\n}\n\n/**\n * Calculate TRIX\n */\nexport async function calculateTRIX(data: OHLCVData[], period: number = 15): Promise<number[]> {\n  validateDataLength(data, period * 3, 'TRIX');\n  const close = getClosePrices(data);\n  return await indicators.trix(close, period);\n}\n\n/**\n * Calculate Ultimate Oscillator\n */\nexport async function calculateUltOsc(\n  data: OHLCVData[],\n  period1: number = 7,\n  period2: number = 14,\n  period3: number = 28\n): Promise<number[]> {\n  validateDataLength(data, period3, 'UltOsc');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.ultosc(high, low, close, period1, period2, period3);\n}\n\n/**\n * Calculate VOSC (Volume Oscillator)\n */\nexport async function calculateVOSC(data: OHLCVData[], fastPeriod: number = 12, slowPeriod: number = 26): Promise<number[]> {\n  validateDataLength(data, slowPeriod, 'VOSC');\n  const volume = getVolumes(data);\n  return await indicators.vosc(volume, fastPeriod, slowPeriod);\n}\n\n// ============================================================================\n// PRICE CALCULATIONS (5 indicators)\n// ============================================================================\n\n/**\n * Calculate Average Price\n */\nexport async function calculateAvgPrice(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'AvgPrice');\n  const open = getOpenPrices(data);\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.avgprice(open, high, low, close);\n}\n\n/**\n * Calculate Median Price\n */\nexport async function calculateMedPrice(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'MedPrice');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.medprice(high, low);\n}\n\n/**\n * Calculate Typical Price\n */\nexport async function calculateTypPrice(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'TypPrice');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.typprice(high, low, close);\n}\n\n/**\n * Calculate Weighted Close Price\n */\nexport async function calculateWCPrice(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 1, 'WCPrice');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.wcprice(high, low, close);\n}\n\n/**\n * Calculate True Range\n */\nexport async function calculateTR(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 2, 'TR');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.tr(high, low, close);\n}\n\n// ============================================================================\n// DIRECTIONAL INDICATORS (3 indicators)\n// ============================================================================\n\n/**\n * Calculate DI (Directional Indicator)\n */\nexport async function calculateDI(data: OHLCVData[], period: number = 14): Promise<{ plus: number[]; minus: number[] }> {\n  validateDataLength(data, period, 'DI');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  const [plus, minus] = await indicators.di(high, low, close, period);\n  return { plus, minus };\n}\n\n/**\n * Calculate DM (Directional Movement)\n */\nexport async function calculateDM(data: OHLCVData[], period: number = 14): Promise<{ plus: number[]; minus: number[] }> {\n  validateDataLength(data, period, 'DM');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const [plus, minus] = await indicators.dm(high, low, period);\n  return { plus, minus };\n}\n\n/**\n * Calculate DX (Directional Movement Index)\n */\nexport async function calculateDX(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period * 2, 'DX');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  return await indicators.dx(high, low, period);\n}\n\n// ============================================================================\n// LINEAR REGRESSION (4 indicators)\n// ============================================================================\n\n/**\n * Calculate Linear Regression\n */\nexport async function calculateLinReg(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'LinReg');\n  const close = getClosePrices(data);\n  return await indicators.linreg(close, period);\n}\n\n/**\n * Calculate Linear Regression Intercept\n */\nexport async function calculateLinRegIntercept(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'LinRegIntercept');\n  const close = getClosePrices(data);\n  return await indicators.linregintercept(close, period);\n}\n\n/**\n * Calculate Linear Regression Slope\n */\nexport async function calculateLinRegSlope(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'LinRegSlope');\n  const close = getClosePrices(data);\n  return await indicators.linregslope(close, period);\n}\n\n/**\n * Calculate Time Series Forecast\n */\nexport async function calculateTSF(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'TSF');\n  const close = getClosePrices(data);\n  return await indicators.tsf(close, period);\n}\n\n// ============================================================================\n// INDEX/COMPOSITE (8 indicators)\n// ============================================================================\n\n/**\n * Calculate Coppock Curve\n */\nexport async function calculateCopp(\n  data: OHLCVData[],\n  period1: number = 14,\n  period2: number = 11\n): Promise<number[]> {\n  validateDataLength(data, Math.max(period1, period2), 'Copp');\n  const close = getClosePrices(data);\n  return await indicators.copp(close, period1, period2);\n}\n\n/**\n * Calculate EMV (Ease of Movement)\n */\nexport async function calculateEMV(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'EMV');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const volume = getVolumes(data);\n  return await indicators.emv(high, low, volume, period);\n}\n\n/**\n * Calculate FI (Force Index)\n */\nexport async function calculateFI(data: OHLCVData[], period: number = 13): Promise<number[]> {\n  validateDataLength(data, period, 'FI');\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.fi(close, volume, period);\n}\n\n/**\n * Calculate MSW (Mesa Sine Wave)\n */\nexport async function calculateMSW(data: OHLCVData[], period: number = 5): Promise<{ sine: number[]; lead: number[] }> {\n  validateDataLength(data, period * 3, 'MSW');\n  const close = getClosePrices(data);\n  const result = await indicators.msw(close, period);\n  if (result.length === 0) return { sine: [], lead: [] };\n  const [sine, lead] = result;\n  return { sine, lead };\n}\n\n/**\n * Calculate NVI (Negative Volume Index)\n */\nexport async function calculateNVI(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 2, 'NVI');\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.nvi(close, volume);\n}\n\n/**\n * Calculate PVI (Positive Volume Index)\n */\nexport async function calculatePVI(data: OHLCVData[]): Promise<number[]> {\n  validateDataLength(data, 2, 'PVI');\n  const close = getClosePrices(data);\n  const volume = getVolumes(data);\n  return await indicators.pvi(close, volume);\n}\n\n/**\n * Calculate PFE (Polarized Fractal Efficiency)\n */\nexport async function calculatePFE(data: OHLCVData[], period: number = 10, emaPeriod: number = 5): Promise<number[]> {\n  validateDataLength(data, period, 'PFE');\n  const close = getClosePrices(data);\n  return await indicators.pfe(close, period, emaPeriod);\n}\n\n/**\n * Calculate VHF (Vertical Horizontal Filter)\n */\nexport async function calculateVHF(data: OHLCVData[], period: number = 28): Promise<number[]> {\n  validateDataLength(data, period, 'VHF');\n  const close = getClosePrices(data);\n  return await indicators.vhf(close, period);\n}\n\n// ============================================================================\n// ADVANCED TECHNICAL (10 indicators)\n// ============================================================================\n\n/**\n * Calculate RMI (Relative Momentum Index)\n */\nexport async function calculateRMI(data: OHLCVData[], period: number = 20, momentumPeriod: number = 5): Promise<number[]> {\n  validateDataLength(data, period + momentumPeriod, 'RMI');\n  const close = getClosePrices(data);\n  return await indicators.rmi(close, period, momentumPeriod);\n}\n\n/**\n * Calculate RMTA (Recursive Moving Trend Average)\n */\nexport async function calculateRMTA(data: OHLCVData[], period: number = 21, beta: number = 0.8): Promise<number[]> {\n  validateDataLength(data, period, 'RMTA');\n  const close = getClosePrices(data);\n  return await indicators.rmta(close, period, beta);\n}\n\n/**\n * Calculate VIDYA (Variable Index Dynamic Average)\n */\nexport async function calculateVIDYA(\n  data: OHLCVData[],\n  shortPeriod: number = 2,\n  longPeriod: number = 12,\n  alpha: number = 0.2\n): Promise<number[]> {\n  validateDataLength(data, longPeriod, 'VIDYA');\n  const close = getClosePrices(data);\n  return await indicators.vidya(close, shortPeriod, longPeriod, alpha);\n}\n\n/**\n * Calculate Wilders Smoothing\n */\nexport async function calculateWilders(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'Wilders');\n  const close = getClosePrices(data);\n  return await indicators.wilders(close, period);\n}\n\n/**\n * Calculate Williams %R\n */\nexport async function calculateWillR(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'WillR');\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n  return await indicators.willr(high, low, close, period);\n}\n\n/**\n * Calculate Lag\n */\nexport async function calculateLag(data: OHLCVData[], period: number = 1): Promise<number[]> {\n  validateDataLength(data, period + 1, 'Lag');\n  const close = getClosePrices(data);\n  return await indicators.lag(close, period);\n}\n\n/**\n * Calculate MD (Mean Deviation)\n */\nexport async function calculateMD(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'MD');\n  const close = getClosePrices(data);\n  return await indicators.md(close, period);\n}\n\n/**\n * Calculate MIN (Minimum)\n */\nexport async function calculateMIN(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'MIN');\n  const close = getClosePrices(data);\n  return await indicators.min(close, period);\n}\n\n/**\n * Calculate SUM\n */\nexport async function calculateSUM(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'SUM');\n  const close = getClosePrices(data);\n  return await indicators.sum(close, period);\n}\n\n/**\n * Calculate VAR (Variance)\n */\nexport async function calculateVAR(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'VAR');\n  const close = getClosePrices(data);\n  return await indicators.var(close, period);\n}\n\n// ============================================================================\n// SPECIAL INDICATORS (8 indicators)\n// ============================================================================\n\n/**\n * Calculate Decay (Linear)\n */\nexport async function calculateDecay(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'Decay');\n  const close = getClosePrices(data);\n  return await indicators.decay(close, period);\n}\n\n/**\n * Calculate EDecay (Exponential)\n */\nexport async function calculateEDecay(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'EDecay');\n  const close = getClosePrices(data);\n  return await indicators.edecay(close, period);\n}\n\n/**\n * Calculate Mom (Momentum)\n */\nexport async function calculateMom(data: OHLCVData[], period: number = 10): Promise<number[]> {\n  validateDataLength(data, period + 1, 'Mom');\n  const close = getClosePrices(data);\n  return await indicators.mom(close, period);\n}\n\n/**\n * Calculate PC (Price Channel)\n */\nexport async function calculatePC(data: OHLCVData[], period: number = 20): Promise<{ upper: number[]; lower: number[] }> {\n  throw new Error('PC indicator is not yet implemented in @ixjb94/indicators library');\n}\n\n/**\n * Calculate Volatility\n */\nexport async function calculateVolatility(data: OHLCVData[], period: number = 14): Promise<number[]> {\n  validateDataLength(data, period, 'Volatility');\n  const close = getClosePrices(data);\n  return await indicators.volatility(close, period);\n}\n\n/**\n * CrossOver detection\n */\nexport async function calculateCrossOver(series1: number[], series2: number[]): Promise<boolean[]> {\n  return await indicators.crossover(series1, series2);\n}\n\n/**\n * CrossUnder detection\n */\nexport async function calculateCrossUnder(series1: number[], series2: number[]): Promise<boolean[]> {\n  return indicators.crossUnderNumber(series1, 0) as any as Promise<boolean[]>;\n}\n\n/**\n * CrossAny detection\n */\nexport async function calculateCrossAny(series1: number[], series2: number[]): Promise<boolean[]> {\n  return await indicators.crossany(series1, series2);\n}\n\n// ============================================================================\n// ICHIMOKU (1 indicator)\n// ============================================================================\n\n/**\n * Calculate Ichimoku Tenkan-Sen and related lines\n */\nexport async function calculateIkhTS(\n  data: OHLCVData[],\n  conversionPeriod: number = 9,\n  basePeriod: number = 26\n): Promise<{ tenkan: number[]; kijun: number[] }> {\n  throw new Error('IkhTS indicator is not yet implemented in @ixjb94/indicators library');\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get the last value from an array of results\n */\nexport function getLatestValue<T>(results: T[]): T | null {\n  if (!results || results.length === 0) {\n    return null;\n  }\n  return results[results.length - 1];\n}\n\n/**\n * Detect crossover between two series\n */\nexport function detectCrossover(\n  series1Current: number,\n  series1Previous: number,\n  series2Current: number,\n  series2Previous: number\n): 'bullish' | 'bearish' | null {\n  if (series1Previous < series2Previous && series1Current > series2Current) {\n    return 'bullish';\n  }\n  if (series1Previous > series2Previous && series1Current < series2Current) {\n    return 'bearish';\n  }\n  return null;\n}\n\n/**\n * Calculate percentage difference\n */\nexport function calculatePercentDiff(current: number, reference: number): number {\n  if (reference === 0) return 0;\n  return ((current - reference) / reference) * 100;\n}\n\n/**\n * Determine trend direction\n */\nexport function determineTrend(values: number[], lookback: number = 3): 'up' | 'down' | 'sideways' {\n  if (!values || values.length < lookback) {\n    return 'sideways';\n  }\n\n  const recent = values.slice(-lookback);\n  let sumUp = 0;\n  let sumDown = 0;\n\n  for (let i = 1; i < recent.length; i++) {\n    const diff = recent[i] - recent[i - 1];\n    if (diff > 0) sumUp += diff;\n    if (diff < 0) sumDown += Math.abs(diff);\n  }\n\n  const avgChange = (sumUp + sumDown) / (recent.length - 1);\n  const threshold = recent[recent.length - 1] * 0.001;\n\n  if (avgChange < threshold) return 'sideways';\n  if (sumUp > sumDown) return 'up';\n  if (sumDown > sumUp) return 'down';\n\n  return 'sideways';\n}\n\n/**\n * Safe calculation wrapper\n */\nexport async function safeCalculate<T>(\n  calculationFn: () => Promise<T>,\n  indicatorName: string\n): Promise<T> {\n  try {\n    const startTime = Date.now();\n    const result = await calculationFn();\n    const calculationTime = Date.now() - startTime;\n\n    // logger.debug(`${indicatorName} calculated successfully`, { calculationTime });\n    console.log(`${indicatorName} calculated in ${calculationTime}ms`);\n\n    return result;\n  } catch (error) {\n    // logger.error(`Error calculating ${indicatorName}`, { error });\n    console.error(`Error calculating ${indicatorName}:`, error);\n    throw new Error(`Failed to calculate ${indicatorName}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n// ============================================================================\n// CUSTOM INDICATORS (4 indicators)\n// ============================================================================\n\n// Re-export custom indicators from separate file\nexport {\n  calculateSuperTrend,\n  calculateIchimoku,\n  calculatePivotPoints,\n  calculateFibonacciRetracement,\n  type SuperTrendResult,\n  type IchimokuResult,\n  type PivotPointsResult,\n  type FibonacciRetracementResult,\n} from './custom-indicators';\n\n// Export all for easy access (110 indicators = 106 from library + 4 custom)\nexport const Calculator = {\n  // ========== TREND / MOVING AVERAGES (19) ==========\n  SMA: calculateSMA,\n  EMA: calculateEMA,\n  WMA: calculateWMA,\n  DEMA: calculateDEMA,\n  TEMA: calculateTEMA,\n  HMA: calculateHMA,\n  KAMA: calculateKAMA,\n  ZLEMA: calculateZLEMA,\n  VWMA: calculateVWMA,\n  ALMA: calculateALMA,\n  TRIMA: calculateTRIMA,\n  MAMA: calculateMAMA,\n  CCI: calculateCCI,\n  MACD: calculateMACD,\n  MarketFI: calculateMarketFI,\n  MASS: calculateMASS,\n  MAX: calculateMAX,\n  Normalize: calculateNormalize,\n  Normalize2: calculateNormalize2,\n\n  // ========== MOMENTUM (9) ==========\n  RSI: calculateRSI,\n  StochRSI: calculateStochRSI,\n  Stoch: calculateStoch,\n  ROC: calculateROC,\n  ROCR: calculateROCR,\n  MFI: calculateMFI,\n  CMO: calculateCMO,\n  TSI: calculateTSI,\n  Fisher: calculateFisher,\n\n  // ========== VOLATILITY (4) ==========\n  ATR: calculateATR,\n  NATR: calculateNATR,\n  StdDev: calculateStdDev,\n  StdErr: calculateStdErr,\n\n  // ========== VOLUME (9) ==========\n  OBV: calculateOBV,\n  VWAP: calculateVWAP,\n  AD: calculateAD,\n  ADOSC: calculateADOSC,\n  CMF: calculateCMF,\n  KVO: calculateKVO,\n  WAD: calculateWAD,\n  ADX: calculateADX,\n  ADXR: calculateADXR,\n\n  // ========== SUPPORT/RESISTANCE (3) ==========\n  Aroon: calculateAroon,\n  AroonOsc: calculateAroonOsc,\n  PSAR: calculatePSAR,\n\n  // ========== BANDS & CHANNELS (6) ==========\n  BBands: calculateBBands,\n  KC: calculateKC,\n  DC: calculateDC,\n  ABands: calculateABands,\n  PBands: calculatePBands,\n  CE: calculateCE,\n\n  // ========== OSCILLATORS (15) ==========\n  AO: calculateAO,\n  APO: calculateAPO,\n  BOP: calculateBOP,\n  CVI: calculateCVI,\n  DPO: calculateDPO,\n  FOSC: calculateFOSC,\n  KST: calculateKST,\n  POSC: calculatePOSC,\n  PPO: calculatePPO,\n  QStick: calculateQStick,\n  RVI: calculateRVI,\n  SMI: calculateSMI,\n  TRIX: calculateTRIX,\n  UltOsc: calculateUltOsc,\n  VOSC: calculateVOSC,\n\n  // ========== PRICE CALCULATIONS (5) ==========\n  AvgPrice: calculateAvgPrice,\n  MedPrice: calculateMedPrice,\n  TypPrice: calculateTypPrice,\n  WCPrice: calculateWCPrice,\n  TR: calculateTR,\n\n  // ========== DIRECTIONAL (3) ==========\n  DI: calculateDI,\n  DM: calculateDM,\n  DX: calculateDX,\n\n  // ========== LINEAR REGRESSION (4) ==========\n  LinReg: calculateLinReg,\n  LinRegIntercept: calculateLinRegIntercept,\n  LinRegSlope: calculateLinRegSlope,\n  TSF: calculateTSF,\n\n  // ========== INDEX/COMPOSITE (8) ==========\n  Copp: calculateCopp,\n  EMV: calculateEMV,\n  FI: calculateFI,\n  MSW: calculateMSW,\n  NVI: calculateNVI,\n  PVI: calculatePVI,\n  PFE: calculatePFE,\n  VHF: calculateVHF,\n\n  // ========== ADVANCED TECHNICAL (10) ==========\n  RMI: calculateRMI,\n  RMTA: calculateRMTA,\n  VIDYA: calculateVIDYA,\n  Wilders: calculateWilders,\n  WillR: calculateWillR,\n  Lag: calculateLag,\n  MD: calculateMD,\n  MIN: calculateMIN,\n  SUM: calculateSUM,\n  VAR: calculateVAR,\n\n  // ========== SPECIAL (8) ==========\n  Decay: calculateDecay,\n  EDecay: calculateEDecay,\n  Mom: calculateMom,\n  PC: calculatePC,\n  Volatility: calculateVolatility,\n  CrossOver: calculateCrossOver,\n  CrossUnder: calculateCrossUnder,\n  CrossAny: calculateCrossAny,\n\n  // ========== ICHIMOKU (1) ==========\n  IkhTS: calculateIkhTS,\n\n  // ========== UTILITIES ==========\n  getLatestValue,\n  detectCrossover,\n  calculatePercentDiff,\n  determineTrend,\n  safeCalculate,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/indicators/utils/custom-indicators.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getOpenPrices' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'open' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":305,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":305,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Custom Technical Indicators\n * Indicators not available in @ixjb94/indicators library\n * Popular in cryptocurrency trading\n *\n * @module indicators/utils/custom-indicators\n */\n\nimport type { OHLCVData } from '../types/indicators-full.types';\nimport {\n  validateDataLength,\n  validateParameter,\n  getHighPrices,\n  getLowPrices,\n  getClosePrices,\n  getOpenPrices,\n} from './calculator-v2';\n\n// ============================================================================\n// SUPERTREND INDICATOR\n// ============================================================================\n\nexport interface SuperTrendResult {\n  supertrend: number[];\n  direction: ('up' | 'down')[];\n  signal: ('buy' | 'sell' | 'hold')[];\n}\n\n/**\n * Calculate SuperTrend Indicator\n * Popular trend-following indicator in crypto\n *\n * @param data - OHLCV candle data\n * @param period - ATR period (default: 10)\n * @param multiplier - ATR multiplier (default: 3)\n * @returns SuperTrend values, direction, and signals\n */\nexport async function calculateSuperTrend(\n  data: OHLCVData[],\n  period: number = 10,\n  multiplier: number = 3\n): Promise<SuperTrendResult> {\n  validateDataLength(data, period + 1, 'SuperTrend');\n  validateParameter(period, 'period', 1, 500);\n  validateParameter(multiplier, 'multiplier', 0.1, 10);\n\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n\n  // Calculate ATR (Average True Range)\n  const atr: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    if (i === 0) {\n      atr.push(high[i] - low[i]);\n    } else {\n      const tr = Math.max(\n        high[i] - low[i],\n        Math.abs(high[i] - close[i - 1]),\n        Math.abs(low[i] - close[i - 1])\n      );\n\n      if (i < period) {\n        atr.push(((atr[i - 1] * i) + tr) / (i + 1));\n      } else {\n        atr.push(((atr[i - 1] * (period - 1)) + tr) / period);\n      }\n    }\n  }\n\n  // Calculate Basic Bands\n  const basicUpperBand: number[] = [];\n  const basicLowerBand: number[] = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const hl2 = (high[i] + low[i]) / 2;\n    basicUpperBand.push(hl2 + (multiplier * atr[i]));\n    basicLowerBand.push(hl2 - (multiplier * atr[i]));\n  }\n\n  // Calculate Final Bands\n  const finalUpperBand: number[] = [basicUpperBand[0]];\n  const finalLowerBand: number[] = [basicLowerBand[0]];\n\n  for (let i = 1; i < data.length; i++) {\n    // Upper band\n    if (basicUpperBand[i] < finalUpperBand[i - 1] || close[i - 1] > finalUpperBand[i - 1]) {\n      finalUpperBand.push(basicUpperBand[i]);\n    } else {\n      finalUpperBand.push(finalUpperBand[i - 1]);\n    }\n\n    // Lower band\n    if (basicLowerBand[i] > finalLowerBand[i - 1] || close[i - 1] < finalLowerBand[i - 1]) {\n      finalLowerBand.push(basicLowerBand[i]);\n    } else {\n      finalLowerBand.push(finalLowerBand[i - 1]);\n    }\n  }\n\n  // Calculate SuperTrend and Direction\n  const supertrend: number[] = [];\n  const direction: ('up' | 'down')[] = [];\n  const signal: ('buy' | 'sell' | 'hold')[] = [];\n\n  let prevDirection: 'up' | 'down' = 'up';\n\n  for (let i = 0; i < data.length; i++) {\n    let currentDirection: 'up' | 'down';\n\n    if (i === 0) {\n      currentDirection = 'up';\n      supertrend.push(finalLowerBand[i]);\n      direction.push(currentDirection);\n      signal.push('hold');\n    } else {\n      // Determine direction\n      if (prevDirection === 'up') {\n        currentDirection = close[i] <= finalUpperBand[i] ? 'down' : 'up';\n      } else {\n        currentDirection = close[i] >= finalLowerBand[i] ? 'up' : 'down';\n      }\n\n      // Set SuperTrend value\n      supertrend.push(currentDirection === 'up' ? finalLowerBand[i] : finalUpperBand[i]);\n\n      // Detect signal\n      let currentSignal: 'buy' | 'sell' | 'hold' = 'hold';\n      if (prevDirection === 'down' && currentDirection === 'up') {\n        currentSignal = 'buy';\n      } else if (prevDirection === 'up' && currentDirection === 'down') {\n        currentSignal = 'sell';\n      }\n\n      direction.push(currentDirection);\n      signal.push(currentSignal);\n      prevDirection = currentDirection;\n    }\n  }\n\n  return { supertrend, direction, signal };\n}\n\n// ============================================================================\n// ICHIMOKU CLOUD INDICATOR\n// ============================================================================\n\nexport interface IchimokuResult {\n  tenkanSen: number[];      // Conversion Line\n  kijunSen: number[];       // Base Line\n  senkouSpanA: number[];    // Leading Span A\n  senkouSpanB: number[];    // Leading Span B\n  chikouSpan: number[];     // Lagging Span\n  cloudColor: ('bullish' | 'bearish')[];\n  signal: ('strong-buy' | 'buy' | 'neutral' | 'sell' | 'strong-sell')[];\n}\n\n/**\n * Calculate Ichimoku Cloud Indicator\n * Complete implementation of all Ichimoku components\n *\n * @param data - OHLCV candle data\n * @param conversionPeriod - Tenkan-sen period (default: 9)\n * @param basePeriod - Kijun-sen period (default: 26)\n * @param spanBPeriod - Senkou Span B period (default: 52)\n * @param displacement - Cloud displacement (default: 26)\n * @returns Complete Ichimoku indicator values\n */\nexport async function calculateIchimoku(\n  data: OHLCVData[],\n  conversionPeriod: number = 9,\n  basePeriod: number = 26,\n  spanBPeriod: number = 52,\n  displacement: number = 26\n): Promise<IchimokuResult> {\n  validateDataLength(data, spanBPeriod + displacement, 'Ichimoku');\n  validateParameter(conversionPeriod, 'conversionPeriod', 1, 100);\n  validateParameter(basePeriod, 'basePeriod', 1, 100);\n  validateParameter(spanBPeriod, 'spanBPeriod', 1, 200);\n  validateParameter(displacement, 'displacement', 1, 100);\n\n  const high = getHighPrices(data);\n  const low = getLowPrices(data);\n  const close = getClosePrices(data);\n\n  /**\n   * Helper: Calculate midpoint of highest high and lowest low over period\n   */\n  function calculateMidpoint(period: number, index: number): number {\n    const start = Math.max(0, index - period + 1);\n    const slice = high.slice(start, index + 1);\n    const sliceLow = low.slice(start, index + 1);\n    const highest = Math.max(...slice);\n    const lowest = Math.min(...sliceLow);\n    return (highest + lowest) / 2;\n  }\n\n  // Calculate Tenkan-sen (Conversion Line)\n  const tenkanSen: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    tenkanSen.push(calculateMidpoint(conversionPeriod, i));\n  }\n\n  // Calculate Kijun-sen (Base Line)\n  const kijunSen: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    kijunSen.push(calculateMidpoint(basePeriod, i));\n  }\n\n  // Calculate Senkou Span A (Leading Span A) - displaced forward\n  const senkouSpanA: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    senkouSpanA.push((tenkanSen[i] + kijunSen[i]) / 2);\n  }\n\n  // Calculate Senkou Span B (Leading Span B) - displaced forward\n  const senkouSpanB: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    senkouSpanB.push(calculateMidpoint(spanBPeriod, i));\n  }\n\n  // Calculate Chikou Span (Lagging Span) - displaced backward\n  const chikouSpan: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    chikouSpan.push(close[i]);\n  }\n\n  // Determine Cloud Color\n  const cloudColor: ('bullish' | 'bearish')[] = [];\n  for (let i = 0; i < data.length; i++) {\n    cloudColor.push(senkouSpanA[i] > senkouSpanB[i] ? 'bullish' : 'bearish');\n  }\n\n  // Generate Trading Signals\n  const signal: ('strong-buy' | 'buy' | 'neutral' | 'sell' | 'strong-sell')[] = [];\n  for (let i = 0; i < data.length; i++) {\n    const price = close[i];\n    const tenkan = tenkanSen[i];\n    const kijun = kijunSen[i];\n    const cloudTop = Math.max(senkouSpanA[i], senkouSpanB[i]);\n    const cloudBottom = Math.min(senkouSpanA[i], senkouSpanB[i]);\n\n    let currentSignal: 'strong-buy' | 'buy' | 'neutral' | 'sell' | 'strong-sell';\n\n    if (price > cloudTop && tenkan > kijun && cloudColor[i] === 'bullish') {\n      currentSignal = 'strong-buy';\n    } else if (price > cloudTop || tenkan > kijun) {\n      currentSignal = 'buy';\n    } else if (price < cloudBottom && tenkan < kijun && cloudColor[i] === 'bearish') {\n      currentSignal = 'strong-sell';\n    } else if (price < cloudBottom || tenkan < kijun) {\n      currentSignal = 'sell';\n    } else {\n      currentSignal = 'neutral';\n    }\n\n    signal.push(currentSignal);\n  }\n\n  return {\n    tenkanSen,\n    kijunSen,\n    senkouSpanA,\n    senkouSpanB,\n    chikouSpan,\n    cloudColor,\n    signal,\n  };\n}\n\n// ============================================================================\n// PIVOT POINTS INDICATOR\n// ============================================================================\n\nexport interface PivotPointsResult {\n  pivot: number;\n  r1: number;\n  r2: number;\n  r3: number;\n  s1: number;\n  s2: number;\n  s3: number;\n  position: 'above-R3' | 'R2-R3' | 'R1-R2' | 'P-R1' | 'S1-P' | 'S2-S1' | 'S3-S2' | 'below-S3';\n}\n\n/**\n * Calculate Pivot Points\n * Supports Classic, Fibonacci, Woodie, and Camarilla methods\n *\n * @param data - OHLCV candle data (uses last candle for calculation)\n * @param method - Pivot calculation method (default: 'classic')\n * @returns Pivot points and support/resistance levels\n */\nexport async function calculatePivotPoints(\n  data: OHLCVData[],\n  method: 'classic' | 'fibonacci' | 'woodie' | 'camarilla' = 'classic'\n): Promise<PivotPointsResult> {\n  validateDataLength(data, 1, 'PivotPoints');\n\n  // Use last candle for calculation\n  const lastCandle = data[data.length - 1];\n  const high = lastCandle.high;\n  const low = lastCandle.low;\n  const close = lastCandle.close;\n  const open = lastCandle.open;\n\n  let pivot: number;\n  let r1: number, r2: number, r3: number;\n  let s1: number, s2: number, s3: number;\n\n  switch (method) {\n    case 'fibonacci':\n      pivot = (high + low + close) / 3;\n      r1 = pivot + 0.382 * (high - low);\n      r2 = pivot + 0.618 * (high - low);\n      r3 = pivot + 1.000 * (high - low);\n      s1 = pivot - 0.382 * (high - low);\n      s2 = pivot - 0.618 * (high - low);\n      s3 = pivot - 1.000 * (high - low);\n      break;\n\n    case 'woodie':\n      pivot = (high + low + 2 * close) / 4;\n      r1 = 2 * pivot - low;\n      r2 = pivot + (high - low);\n      r3 = high + 2 * (pivot - low);\n      s1 = 2 * pivot - high;\n      s2 = pivot - (high - low);\n      s3 = low - 2 * (high - pivot);\n      break;\n\n    case 'camarilla':\n      pivot = (high + low + close) / 3;\n      const range = high - low;\n      r1 = close + range * 1.1 / 12;\n      r2 = close + range * 1.1 / 6;\n      r3 = close + range * 1.1 / 4;\n      s1 = close - range * 1.1 / 12;\n      s2 = close - range * 1.1 / 6;\n      s3 = close - range * 1.1 / 4;\n      break;\n\n    case 'classic':\n    default:\n      pivot = (high + low + close) / 3;\n      r1 = 2 * pivot - low;\n      r2 = pivot + (high - low);\n      r3 = high + 2 * (pivot - low);\n      s1 = 2 * pivot - high;\n      s2 = pivot - (high - low);\n      s3 = low - 2 * (high - pivot);\n      break;\n  }\n\n  // Determine current position\n  let position: PivotPointsResult['position'];\n  if (close > r3) position = 'above-R3';\n  else if (close > r2) position = 'R2-R3';\n  else if (close > r1) position = 'R1-R2';\n  else if (close > pivot) position = 'P-R1';\n  else if (close > s1) position = 'S1-P';\n  else if (close > s2) position = 'S2-S1';\n  else if (close > s3) position = 'S3-S2';\n  else position = 'below-S3';\n\n  return {\n    pivot,\n    r1,\n    r2,\n    r3,\n    s1,\n    s2,\n    s3,\n    position,\n  };\n}\n\n// ============================================================================\n// FIBONACCI RETRACEMENT INDICATOR\n// ============================================================================\n\nexport interface FibonacciRetracementResult {\n  level_0: number;      // 0% (swing low/high)\n  level_236: number;    // 23.6%\n  level_382: number;    // 38.2%\n  level_500: number;    // 50%\n  level_618: number;    // 61.8% (golden ratio)\n  level_786: number;    // 78.6%\n  level_100: number;    // 100% (swing high/low)\n  // Extensions\n  level_1272: number;   // 127.2%\n  level_1618: number;   // 161.8%\n  nearestLevel: number;\n  nearestLevelName: string;\n}\n\n/**\n * Calculate Fibonacci Retracement Levels\n * Calculates retracement and extension levels based on swing high/low\n *\n * @param high - Swing high price\n * @param low - Swing low price\n * @param trend - Market trend direction ('uptrend' or 'downtrend')\n * @param currentPrice - Current price (optional, for nearest level calculation)\n * @returns Fibonacci retracement levels\n */\nexport async function calculateFibonacciRetracement(\n  high: number,\n  low: number,\n  trend: 'uptrend' | 'downtrend',\n  currentPrice?: number\n): Promise<FibonacciRetracementResult> {\n  if (high <= low) {\n    throw new Error('High must be greater than low for Fibonacci calculation');\n  }\n\n  const range = high - low;\n\n  let result: FibonacciRetracementResult;\n\n  if (trend === 'uptrend') {\n    // In uptrend, levels are calculated from low to high\n    result = {\n      level_0: low,\n      level_236: low + range * 0.236,\n      level_382: low + range * 0.382,\n      level_500: low + range * 0.500,\n      level_618: low + range * 0.618,\n      level_786: low + range * 0.786,\n      level_100: high,\n      level_1272: low + range * 1.272,\n      level_1618: low + range * 1.618,\n      nearestLevel: 0,\n      nearestLevelName: '',\n    };\n  } else {\n    // In downtrend, levels are calculated from high to low\n    result = {\n      level_0: high,\n      level_236: high - range * 0.236,\n      level_382: high - range * 0.382,\n      level_500: high - range * 0.500,\n      level_618: high - range * 0.618,\n      level_786: high - range * 0.786,\n      level_100: low,\n      level_1272: high - range * 1.272,\n      level_1618: high - range * 1.618,\n      nearestLevel: 0,\n      nearestLevelName: '',\n    };\n  }\n\n  // Calculate nearest level if current price is provided\n  if (currentPrice !== undefined) {\n    const levels = [\n      { value: result.level_0, name: '0%' },\n      { value: result.level_236, name: '23.6%' },\n      { value: result.level_382, name: '38.2%' },\n      { value: result.level_500, name: '50%' },\n      { value: result.level_618, name: '61.8%' },\n      { value: result.level_786, name: '78.6%' },\n      { value: result.level_100, name: '100%' },\n      { value: result.level_1272, name: '127.2%' },\n      { value: result.level_1618, name: '161.8%' },\n    ];\n\n    let minDistance = Infinity;\n    let nearestLevel = levels[0];\n\n    for (const level of levels) {\n      const distance = Math.abs(currentPrice - level.value);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestLevel = level;\n      }\n    }\n\n    result.nearestLevel = nearestLevel.value;\n    result.nearestLevelName = nearestLevel.name;\n  }\n\n  return result;\n}\n\n// Export all custom indicators\nexport const CustomIndicators = {\n  SuperTrend: calculateSuperTrend,\n  Ichimoku: calculateIchimoku,\n  PivotPoints: calculatePivotPoints,\n  FibonacciRetracement: calculateFibonacciRetracement,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/routes/market-data.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/schema/market-data.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/services/__tests__/exchange-websocket-metadata.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/services/ohlcv.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/services/orderbook.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/services/ticker.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/services/trades.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/types/market-data.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/__tests__/errors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/__tests__/manager.routing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/__tests__/pipeline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/__tests__/reconnection-strategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/base-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/market-data-websocket-manager.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ConnectionConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":49,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":53,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":53,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'wait' is defined but never used. Allowed unused vars must match /^_/u.","line":92,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mockAdapter' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":102,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Data WebSocket Manager Tests\n * Unit tests for WebSocket manager functionality\n */\n\nimport { describe, test, expect, beforeEach, afterEach, mock } from 'bun:test';\nimport { EventEmitter } from 'events';\nimport { MarketDataWebSocketManager } from './market-data-websocket-manager';\nimport type { ExchangeId, Ticker, ConnectionConfig } from './types';\n\n// ============================================================================\n// MOCKS\n// ============================================================================\n\n/**\n * Mock Exchange Adapter\n */\nclass MockExchangeAdapter extends EventEmitter {\n  public exchangeId: ExchangeId;\n  public isConnected: boolean = false;\n  public status: any;\n  private _latency: number | null = null;\n\n  constructor(exchangeId: ExchangeId) {\n    super();\n    this.exchangeId = exchangeId;\n    this.status = {\n      state: 'DISCONNECTED',\n      connectedAt: null,\n      lastPingAt: null,\n      lastPongAt: null,\n      reconnectAttempts: 0,\n    };\n  }\n\n  async connect(): Promise<void> {\n    this.isConnected = true;\n    this.status.state = 'CONNECTED';\n    this.status.connectedAt = new Date();\n    this.emit('connected', { timestamp: Date.now() });\n  }\n\n  async disconnect(): Promise<void> {\n    this.isConnected = false;\n    this.status.state = 'DISCONNECTED';\n    this.emit('disconnected', { timestamp: Date.now() });\n  }\n\n  async subscribe(request: any): Promise<void> {\n    // Simulate subscription\n  }\n\n  async unsubscribe(request: any): Promise<void> {\n    // Simulate unsubscription\n  }\n\n  async ping(): Promise<void> {\n    this._latency = Math.random() * 100;\n  }\n\n  getLatency(): number | null {\n    return this._latency;\n  }\n\n  // Helper to simulate ticker\n  simulateTicker(ticker: Ticker): void {\n    this.emit('ticker', ticker);\n  }\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction createMockTicker(overrides: Partial<Ticker> = {}): Ticker {\n  return {\n    symbol: 'BTC/USDT',\n    exchange: 'binance',\n    timestamp: Date.now(),\n    last: 50000,\n    bid: 49990,\n    ask: 50010,\n    high24h: 51000,\n    low24h: 49000,\n    volume24h: 1000,\n    change24h: 1000,\n    changePercent24h: 2,\n    ...overrides,\n  };\n}\n\nfunction wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// ============================================================================\n// TESTS\n// ============================================================================\n\ndescribe('MarketDataWebSocketManager', () => {\n  let manager: MarketDataWebSocketManager;\n  let mockAdapter: MockExchangeAdapter;\n\n  beforeEach(() => {\n    manager = new MarketDataWebSocketManager({\n      autoReconnect: true,\n      maxConnections: 10,\n      connectionTimeout: 30000,\n      enableMetrics: true,\n    });\n\n    mockAdapter = new MockExchangeAdapter('binance');\n  });\n\n  afterEach(async () => {\n    await manager.disconnectAll();\n  });\n\n  // ==========================================================================\n  // BASIC FUNCTIONALITY\n  // ==========================================================================\n\n  describe('Basic Functionality', () => {\n    test('should create manager with default config', () => {\n      const defaultManager = new MarketDataWebSocketManager();\n      expect(defaultManager).toBeDefined();\n    });\n\n    test('should create manager with custom config', () => {\n      const customManager = new MarketDataWebSocketManager({\n        autoReconnect: false,\n        maxConnections: 5,\n        enableMetrics: false,\n      });\n      expect(customManager).toBeDefined();\n    });\n  });\n\n  // ==========================================================================\n  // CONNECTION MANAGEMENT\n  // ==========================================================================\n\n  describe('Connection Management', () => {\n    test('should check if exchange is connected', () => {\n      expect(manager.isConnected('binance')).toBe(false);\n    });\n\n    test('should get connection status', () => {\n      const status = manager.getConnectionStatus('binance');\n      expect(status).toBeNull();\n    });\n\n    test('should get all connection statuses', () => {\n      const statuses = manager.getAllConnectionStatuses();\n      expect(statuses.size).toBe(0);\n    });\n\n    test('should get health status', () => {\n      const health = manager.getHealthStatus();\n      expect(health.healthy).toEqual([]);\n      expect(health.unhealthy).toEqual([]);\n      expect(health.total).toBe(0);\n    });\n  });\n\n  // ==========================================================================\n  // SUBSCRIPTION MANAGEMENT\n  // ==========================================================================\n\n  describe('Subscription Management', () => {\n    test('should get subscriptions for exchange', () => {\n      const subs = manager.getSubscriptions('binance');\n      expect(subs).toEqual([]);\n    });\n\n    test('should get all subscriptions', () => {\n      const allSubs = manager.getAllSubscriptions();\n      expect(allSubs.size).toBe(0);\n    });\n  });\n\n  // ==========================================================================\n  // METRICS\n  // ==========================================================================\n\n  describe('Metrics', () => {\n    test('should get metrics for exchange', () => {\n      const metrics = manager.getMetrics('binance');\n      expect(metrics).toBeNull();\n    });\n\n    test('should get all metrics', () => {\n      const allMetrics = manager.getAllMetrics();\n      expect(allMetrics.size).toBe(0);\n    });\n  });\n\n  // ==========================================================================\n  // EVENT HANDLING\n  // ==========================================================================\n\n  describe('Event Handling', () => {\n    test('should be an event emitter', () => {\n      expect(manager).toBeInstanceOf(EventEmitter);\n    });\n\n    test('should emit events', (done) => {\n      manager.once('test-event', (data) => {\n        expect(data).toEqual({ test: true });\n        done();\n      });\n\n      manager.emit('test-event', { test: true });\n    });\n  });\n\n  // ==========================================================================\n  // ERROR HANDLING\n  // ==========================================================================\n\n  describe('Error Handling', () => {\n    test('should handle disconnect gracefully when not connected', async () => {\n      // Should not throw\n      try {\n        await manager.disconnect('binance');\n        expect(true).toBe(true);\n      } catch (error) {\n        throw new Error('Should not have thrown');\n      }\n    });\n\n    test('should handle unsubscribe gracefully when not subscribed', async () => {\n      // Should not throw\n      try {\n        await manager.unsubscribe({\n          channel: 'ticker',\n          symbol: 'BTC/USDT',\n        });\n        expect(true).toBe(true);\n      } catch (error) {\n        throw new Error('Should not have thrown');\n      }\n    });\n  });\n});\n\n// ============================================================================\n// PERFORMANCE TESTS\n// ============================================================================\n\ndescribe('MarketDataWebSocketManager Performance', () => {\n  let manager: MarketDataWebSocketManager;\n\n  beforeEach(() => {\n    manager = new MarketDataWebSocketManager({\n      enableMetrics: true,\n    });\n  });\n\n  afterEach(async () => {\n    await manager.disconnectAll();\n  });\n\n  test('should handle rapid event emissions', () => {\n    const events: any[] = [];\n\n    manager.on('ticker', (ticker) => {\n      events.push(ticker);\n    });\n\n    // Emit 1000 ticker events\n    for (let i = 0; i < 1000; i++) {\n      manager.emit('ticker', createMockTicker({ last: 50000 + i }));\n    }\n\n    expect(events.length).toBe(1000);\n    expect(events[999].last).toBe(50999);\n  });\n\n  test('should maintain performance with many listeners', () => {\n    // Increase max listeners to avoid warning\n    manager.setMaxListeners(200);\n\n    const startTime = Date.now();\n\n    // Add 100 listeners\n    for (let i = 0; i < 100; i++) {\n      manager.on('ticker', () => {\n        // Empty listener\n      });\n    }\n\n    // Emit 100 events\n    for (let i = 0; i < 100; i++) {\n      manager.emit('ticker', createMockTicker());\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n\n    // Should complete in less than 100ms\n    expect(duration).toBeLessThan(100);\n  });\n});\n\n// ============================================================================\n// INTEGRATION SCENARIOS\n// ============================================================================\n\ndescribe('MarketDataWebSocketManager Integration Scenarios', () => {\n  let manager: MarketDataWebSocketManager;\n\n  beforeEach(() => {\n    manager = new MarketDataWebSocketManager();\n  });\n\n  afterEach(async () => {\n    await manager.disconnectAll();\n  });\n\n  test('should handle multiple symbol subscriptions', () => {\n    const symbols = ['BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'ADA/USDT', 'SOL/USDT'];\n    const receivedSymbols: string[] = [];\n\n    manager.on('ticker', (ticker: Ticker) => {\n      receivedSymbols.push(ticker.symbol);\n    });\n\n    // Simulate tickers for all symbols\n    symbols.forEach((symbol) => {\n      manager.emit('ticker', createMockTicker({ symbol }));\n    });\n\n    expect(receivedSymbols).toEqual(symbols);\n  });\n\n  test('should filter events by symbol', () => {\n    const btcUpdates: Ticker[] = [];\n    const ethUpdates: Ticker[] = [];\n\n    manager.on('ticker', (ticker: Ticker) => {\n      if (ticker.symbol === 'BTC/USDT') {\n        btcUpdates.push(ticker);\n      } else if (ticker.symbol === 'ETH/USDT') {\n        ethUpdates.push(ticker);\n      }\n    });\n\n    // Emit mixed tickers\n    manager.emit('ticker', createMockTicker({ symbol: 'BTC/USDT', last: 50000 }));\n    manager.emit('ticker', createMockTicker({ symbol: 'ETH/USDT', last: 3000 }));\n    manager.emit('ticker', createMockTicker({ symbol: 'BTC/USDT', last: 51000 }));\n    manager.emit('ticker', createMockTicker({ symbol: 'SOL/USDT', last: 100 }));\n\n    expect(btcUpdates.length).toBe(2);\n    expect(ethUpdates.length).toBe(1);\n    expect(btcUpdates[0].last).toBe(50000);\n    expect(btcUpdates[1].last).toBe(51000);\n    expect(ethUpdates[0].last).toBe(3000);\n  });\n\n  test('should calculate price changes', () => {\n    const prices: number[] = [];\n\n    manager.on('ticker', (ticker: Ticker) => {\n      prices.push(ticker.last);\n    });\n\n    // Simulate price movement\n    const priceSequence = [50000, 50500, 50200, 51000, 50800];\n    priceSequence.forEach((price) => {\n      manager.emit('ticker', createMockTicker({ last: price }));\n    });\n\n    expect(prices).toEqual(priceSequence);\n\n    // Calculate volatility\n    const changes = prices.slice(1).map((price, i) => price - prices[i]);\n    const avgChange = changes.reduce((sum, change) => sum + Math.abs(change), 0) / changes.length;\n\n    expect(avgChange).toBeGreaterThan(0);\n  });\n});\n\n// ============================================================================\n// EDGE CASES\n// ============================================================================\n\ndescribe('MarketDataWebSocketManager Edge Cases', () => {\n  let manager: MarketDataWebSocketManager;\n\n  beforeEach(() => {\n    manager = new MarketDataWebSocketManager();\n  });\n\n  afterEach(async () => {\n    await manager.disconnectAll();\n  });\n\n  test('should handle undefined ticker data', () => {\n    let receivedTicker: any = null;\n\n    manager.on('ticker', (ticker) => {\n      receivedTicker = ticker;\n    });\n\n    // Emit undefined\n    manager.emit('ticker', undefined as any);\n\n    expect(receivedTicker).toBeUndefined();\n  });\n\n  test('should handle null ticker data', () => {\n    let receivedTicker: any = 'not-null';\n\n    manager.on('ticker', (ticker) => {\n      receivedTicker = ticker;\n    });\n\n    // Emit null\n    manager.emit('ticker', null as any);\n\n    expect(receivedTicker).toBeNull();\n  });\n\n  test('should handle invalid ticker data', () => {\n    const invalidTickers: any[] = [];\n\n    manager.on('ticker', (ticker) => {\n      invalidTickers.push(ticker);\n    });\n\n    // Emit invalid data\n    manager.emit('ticker', { invalid: true } as any);\n    manager.emit('ticker', 'string' as any);\n    manager.emit('ticker', 12345 as any);\n    manager.emit('ticker', [] as any);\n\n    expect(invalidTickers.length).toBe(4);\n  });\n\n  test('should handle zero prices', () => {\n    const zeroPrice = createMockTicker({ last: 0, bid: 0, ask: 0 });\n    let receivedTicker: Ticker | null = null;\n\n    manager.on('ticker', (ticker) => {\n      receivedTicker = ticker;\n    });\n\n    manager.emit('ticker', zeroPrice);\n\n    expect(receivedTicker).not.toBeNull();\n    expect(receivedTicker?.last).toBe(0);\n  });\n\n  test('should handle negative prices', () => {\n    const negativePrice = createMockTicker({ last: -1000 });\n    let receivedTicker: Ticker | null = null;\n\n    manager.on('ticker', (ticker) => {\n      receivedTicker = ticker;\n    });\n\n    manager.emit('ticker', negativePrice);\n\n    expect(receivedTicker).not.toBeNull();\n    expect(receivedTicker?.last).toBe(-1000);\n  });\n\n  test('should handle very large prices', () => {\n    const largePrice = createMockTicker({ last: Number.MAX_SAFE_INTEGER });\n    let receivedTicker: Ticker | null = null;\n\n    manager.on('ticker', (ticker) => {\n      receivedTicker = ticker;\n    });\n\n    manager.emit('ticker', largePrice);\n\n    expect(receivedTicker).not.toBeNull();\n    expect(receivedTicker?.last).toBe(Number.MAX_SAFE_INTEGER);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/market-data-websocket-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExchangeEventName' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":106,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":123},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExchangeEventListener' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":125,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":146}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Data WebSocket Manager\n * Manages real-time market data connections using native exchange adapters\n *\n * This replaces the ccxt.pro-dependent WebSocketManager with native WebSocket adapters\n */\n\nimport { EventEmitter } from 'events';\nimport logger from '@/utils/logger';\nimport { createWebSocketAdapter } from '@/modules/exchanges';\nimport { RedisEventBridge, type RedisEventBridgeConfig } from './redis-event-bridge';\nimport type { ConnectionConfig, ExchangeId } from '@/modules/exchanges';\nimport type { IExchangeAdapter, SubscriptionRequest, ConnectionStatus, OrderBook, Trade, Ticker, Candle, ExchangeEventName, ExchangeEventListener, ConnectionMetrics } from './types';\n\n/**\n * Manager Configuration\n */\nexport interface MarketDataManagerConfig {\n  /** Enable automatic reconnection */\n  autoReconnect?: boolean;\n  /** Maximum concurrent connections */\n  maxConnections?: number;\n  /** Connection timeout (ms) */\n  connectionTimeout?: number;\n  /** Enable metrics collection */\n  enableMetrics?: boolean;\n  /** Enable Redis pub/sub for multi-instance scaling */\n  enableRedis?: boolean;\n  /** Redis configuration */\n  redis?: RedisEventBridgeConfig;\n}\n\n/**\n * Default Manager Configuration\n */\nconst DEFAULT_CONFIG: Required<Omit<MarketDataManagerConfig, 'redis'>> = {\n  autoReconnect: true,\n  maxConnections: 10,\n  connectionTimeout: 30000,\n  enableMetrics: true,\n  enableRedis: false,\n};\n\n/**\n * Market Data WebSocket Manager\n * Manages multiple exchange WebSocket connections with native adapters\n */\nexport class MarketDataWebSocketManager extends EventEmitter {\n  private adapters: Map<ExchangeId, IExchangeAdapter> = new Map();\n  private config: Required<Omit<MarketDataManagerConfig, 'redis'>>;\n  private redisConfig?: RedisEventBridgeConfig;\n  private metrics: Map<ExchangeId, ConnectionMetrics> = new Map();\n  private subscriptions: Map<ExchangeId, SubscriptionRequest[]> = new Map();\n  private redisBridge: RedisEventBridge | null = null;\n\n  constructor(config?: MarketDataManagerConfig) {\n    super();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.redisConfig = config?.redis;\n\n    // Initialize Redis bridge if enabled\n    if (this.config.enableRedis) {\n      this.initializeRedis();\n    }\n  }\n\n  /**\n   * Initialize Redis event bridge\n   */\n  private async initializeRedis(): Promise<void> {\n    try {\n      logger.info('Initializing Redis event bridge for multi-instance scaling');\n\n      this.redisBridge = new RedisEventBridge(this.redisConfig);\n\n      // Set up Redis event listeners\n      this.redisBridge.on('ticker', (data: Ticker) => {\n        this.emit('ticker', data);\n      });\n\n      this.redisBridge.on('trade', (data: Trade) => {\n        this.emit('trade', data);\n      });\n\n      this.redisBridge.on('orderbook', (data: OrderBook) => {\n        this.emit('orderbook', data);\n      });\n\n      this.redisBridge.on('candle', (data: Candle) => {\n        this.emit('candle', data);\n      });\n\n      // Connection events\n      this.redisBridge.on('connected', () => {\n        logger.info('Redis event bridge connected');\n      });\n\n      this.redisBridge.on('disconnected', () => {\n        logger.warn('Redis event bridge disconnected');\n      });\n\n      this.redisBridge.on('error', (error: any) => {\n        logger.error('Redis event bridge error', { error });\n      });\n\n      // Connect to Redis\n      await this.redisBridge.connect();\n\n      // Subscribe to all event types\n      await this.redisBridge.subscribeAll();\n\n      logger.info('Redis event bridge initialized successfully');\n    } catch (error) {\n      logger.error('Failed to initialize Redis event bridge', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      // Don't throw - allow manager to work without Redis\n      this.redisBridge = null;\n    }\n  }\n\n  /**\n   * Connect to exchange WebSocket\n   */\n  async connect(exchangeId: ExchangeId, config: ConnectionConfig): Promise<void> {\n    try {\n      // Check if already connected\n      if (this.adapters.has(exchangeId)) {\n        logger.warn('Exchange already connected', { exchangeId });\n        return;\n      }\n\n      // Check max connections\n      if (this.adapters.size >= this.config.maxConnections) {\n        throw new Error(`Maximum connections reached (${this.config.maxConnections})`);\n      }\n\n      logger.info('Connecting to exchange WebSocket', { exchangeId });\n\n      // Create appropriate adapter\n      const adapter = this.createAdapter(exchangeId, config);\n\n      // Set up event forwarding\n      this.setupEventForwarding(adapter);\n\n      // Connect\n      await adapter.connect();\n\n      // Store adapter\n      this.adapters.set(exchangeId, adapter);\n\n      // Initialize metrics\n      if (this.config.enableMetrics) {\n        this.initializeMetrics(exchangeId);\n      }\n\n      logger.info('Exchange WebSocket connected', { exchangeId });\n\n      // Emit connected event\n      this.emit('exchange:connected', { exchangeId, timestamp: Date.now() });\n    } catch (error) {\n      logger.error('Failed to connect to exchange WebSocket', {\n        exchangeId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Disconnect from exchange WebSocket\n   */\n  async disconnect(exchangeId: ExchangeId): Promise<void> {\n    const adapter = this.adapters.get(exchangeId);\n    if (!adapter) {\n      logger.warn('Exchange not connected', { exchangeId });\n      return;\n    }\n\n    try {\n      logger.info('Disconnecting from exchange WebSocket', { exchangeId });\n\n      // Disconnect adapter\n      await adapter.disconnect();\n\n      // Remove from adapters\n      this.adapters.delete(exchangeId);\n\n      // Remove subscriptions\n      this.subscriptions.delete(exchangeId);\n\n      // Remove metrics\n      this.metrics.delete(exchangeId);\n\n      logger.info('Exchange WebSocket disconnected', { exchangeId });\n\n      // Emit disconnected event\n      this.emit('exchange:disconnected', { exchangeId, timestamp: Date.now() });\n    } catch (error) {\n      logger.error('Error disconnecting from exchange WebSocket', {\n        exchangeId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Subscribe to market data channel\n   */\n  async subscribe(request: SubscriptionRequest): Promise<void> {\n    const exchangeId = this.resolveExchangeForSubscribe(request);\n\n    try {\n      // Ensure connection exists\n      const adapter = this.adapters.get(exchangeId);\n      if (!adapter) {\n        throw new Error(`Exchange ${exchangeId} not connected`);\n      }\n\n      logger.info('Subscribing to market data', {\n        exchange: exchangeId,\n        channel: request.channel,\n        symbol: request.symbol,\n      });\n\n      // Subscribe via adapter\n      await adapter.subscribe(request);\n\n      // Store subscription\n      const subs = this.subscriptions.get(exchangeId) || [];\n      subs.push({ ...request, exchangeId });\n      this.subscriptions.set(exchangeId, subs);\n\n      logger.info('Subscribed to market data', {\n        exchange: exchangeId,\n        channel: request.channel,\n        symbol: request.symbol,\n      });\n\n      // Emit subscription event\n      this.emit('subscription:added', { exchangeId, request });\n    } catch (error) {\n      logger.error('Failed to subscribe to market data', {\n        exchange: exchangeId,\n        channel: request.channel,\n        symbol: request.symbol,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Unsubscribe from market data channel\n   */\n  async unsubscribe(request: SubscriptionRequest): Promise<void> {\n    const exchangeId = this.resolveExchangeForUnsubscribe(request);\n    if (!exchangeId) {\n      logger.warn('Unable to resolve exchange for unsubscribe', {\n        channel: request.channel,\n        symbol: request.symbol,\n      });\n      return;\n    }\n    const adapter = this.adapters.get(exchangeId);\n    if (!adapter) {\n      logger.warn('Exchange not connected', { exchangeId });\n      return;\n    }\n\n    try {\n      logger.info('Unsubscribing from market data', {\n        exchange: exchangeId,\n        channel: request.channel,\n        symbol: request.symbol,\n      });\n\n      // Unsubscribe via adapter\n      await adapter.unsubscribe(request);\n\n      // Remove from subscriptions\n      const subs = this.subscriptions.get(exchangeId) || [];\n      const filtered = subs.filter(\n        (s) => s.channel !== request.channel || s.symbol !== request.symbol\n      );\n      this.subscriptions.set(exchangeId, filtered);\n\n      logger.info('Unsubscribed from market data', {\n        exchange: exchangeId,\n        channel: request.channel,\n        symbol: request.symbol,\n      });\n\n      // Emit unsubscription event\n      this.emit('subscription:removed', { exchangeId, request });\n    } catch (error) {\n      logger.error('Failed to unsubscribe from market data', {\n        exchange: exchangeId,\n        channel: request.channel,\n        symbol: request.symbol,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get connection status for exchange\n   */\n  getConnectionStatus(exchangeId: ExchangeId): ConnectionStatus | null {\n    const adapter = this.adapters.get(exchangeId);\n    if (!adapter) return null;\n\n    return adapter.status;\n  }\n\n  /**\n   * Get all connection statuses\n   */\n  getAllConnectionStatuses(): Map<ExchangeId, ConnectionStatus> {\n    const statuses = new Map<ExchangeId, ConnectionStatus>();\n\n    for (const [exchangeId, adapter] of this.adapters) {\n      statuses.set(exchangeId, adapter.status);\n    }\n\n    return statuses;\n  }\n\n  /**\n   * Check if connected to exchange\n   */\n  isConnected(exchangeId: ExchangeId): boolean {\n    const adapter = this.adapters.get(exchangeId);\n    return adapter?.isConnected || false;\n  }\n\n  /**\n   * Get metrics for exchange\n   */\n  getMetrics(exchangeId: ExchangeId): ConnectionMetrics | null {\n    return this.metrics.get(exchangeId) || null;\n  }\n\n  /**\n   * Get all metrics\n   */\n  getAllMetrics(): Map<ExchangeId, ConnectionMetrics> {\n    return new Map(this.metrics);\n  }\n\n  /**\n   * Get Redis metrics\n   */\n  getRedisMetrics() {\n    if (!this.redisBridge) {\n      return null;\n    }\n\n    return this.redisBridge.getMetrics();\n  }\n\n  /**\n   * Get comprehensive system metrics\n   */\n  getSystemMetrics() {\n    return {\n      exchanges: Object.fromEntries(this.metrics),\n      redis: this.getRedisMetrics(),\n      connections: {\n        active: this.adapters.size,\n        max: this.config.maxConnections,\n        available: this.config.maxConnections - this.adapters.size,\n      },\n      subscriptions: {\n        total: Array.from(this.subscriptions.values()).reduce((sum, subs) => sum + subs.length, 0),\n        byExchange: Object.fromEntries(\n          Array.from(this.subscriptions.entries()).map(([exchange, subs]) => [exchange, subs.length])\n        ),\n      },\n      health: this.getHealthStatus(),\n    };\n  }\n\n  /**\n   * Get active subscriptions for exchange\n   */\n  getSubscriptions(exchangeId: ExchangeId): SubscriptionRequest[] {\n    return this.subscriptions.get(exchangeId) || [];\n  }\n\n  /**\n   * Get all active subscriptions\n   */\n  getAllSubscriptions(): Map<ExchangeId, SubscriptionRequest[]> {\n    return new Map(this.subscriptions);\n  }\n\n  /**\n   * Disconnect all exchanges\n   */\n  async disconnectAll(): Promise<void> {\n    logger.info('Disconnecting all exchange WebSockets');\n\n    const promises: Promise<void>[] = [];\n    for (const exchangeId of this.adapters.keys()) {\n      promises.push(this.disconnect(exchangeId));\n    }\n\n    await Promise.all(promises);\n\n    // Disconnect Redis bridge if enabled\n    if (this.redisBridge) {\n      try {\n        await this.redisBridge.disconnect();\n        logger.info('Redis event bridge disconnected');\n      } catch (error) {\n        logger.error('Error disconnecting Redis event bridge', { error });\n      }\n    }\n\n    logger.info('All exchange WebSockets disconnected');\n  }\n\n  /**\n   * Ping all connected exchanges\n   */\n  async pingAll(): Promise<Map<ExchangeId, number | null>> {\n    const latencies = new Map<ExchangeId, number | null>();\n\n    for (const [exchangeId, adapter] of this.adapters) {\n      try {\n        await adapter.ping();\n        const latency = adapter.getLatency();\n        latencies.set(exchangeId, latency);\n      } catch (error) {\n        logger.error('Ping failed', { exchangeId, error });\n        latencies.set(exchangeId, null);\n      }\n    }\n\n    return latencies;\n  }\n\n  /**\n   * Get health status of all connections\n   */\n  getHealthStatus(): {\n    healthy: ExchangeId[];\n    unhealthy: ExchangeId[];\n    total: number;\n  } {\n    const healthy: ExchangeId[] = [];\n    const unhealthy: ExchangeId[] = [];\n\n    for (const [exchangeId, adapter] of this.adapters) {\n      if (adapter.isConnected) {\n        healthy.push(exchangeId);\n      } else {\n        unhealthy.push(exchangeId);\n      }\n    }\n\n    return {\n      healthy,\n      unhealthy,\n      total: this.adapters.size,\n    };\n  }\n\n  /**\n   * Create adapter for exchange\n   */\n  private createAdapter(exchangeId: ExchangeId, config: ConnectionConfig): IExchangeAdapter {\n    // Delegate creation to exchanges module to centralize exchange connectivity\n    return createWebSocketAdapter(exchangeId, config);\n  }\n\n  /**\n   * Set up event forwarding from adapter to manager\n   */\n  private setupEventForwarding(adapter: IExchangeAdapter): void {\n    const exchangeId = adapter.exchangeId;\n\n    // Forward all events with exchange prefix\n    adapter.on('connected', (data) => {\n      this.emit('exchange:connected', data);\n      this.emit('connected', { ...data, exchange: exchangeId });\n    });\n\n    adapter.on('disconnected', (data) => {\n      this.emit('exchange:disconnected', data);\n      this.emit('disconnected', { ...data, exchange: exchangeId });\n\n      // Auto-reconnect if enabled\n      if (this.config.autoReconnect) {\n        logger.info('Auto-reconnecting to exchange', { exchangeId });\n        // Note: Adapter handles its own reconnection via reconnection strategy\n      }\n    });\n\n    adapter.on('reconnecting', (data) => {\n      this.emit('exchange:reconnecting', data);\n      this.emit('reconnecting', { ...data, exchange: exchangeId });\n    });\n\n    adapter.on('error', (error) => {\n      this.emit('exchange:error', error);\n      this.emit('error', { ...error, exchange: exchangeId });\n    });\n\n    // Forward market data events\n    adapter.on('orderbook', (data: OrderBook) => {\n      this.emit('orderbook', data);\n      this.updateMetrics(exchangeId, 'messagesReceived');\n\n      // Publish to Redis if enabled\n      if (this.redisBridge) {\n        this.redisBridge.publish({ type: 'orderbook', data }).catch((error) => {\n          logger.error('Failed to publish orderbook to Redis', { error });\n        });\n      }\n    });\n\n    adapter.on('trade', (data: Trade) => {\n      this.emit('trade', data);\n      this.updateMetrics(exchangeId, 'messagesReceived');\n\n      // Publish to Redis if enabled\n      if (this.redisBridge) {\n        this.redisBridge.publish({ type: 'trade', data }).catch((error) => {\n          logger.error('Failed to publish trade to Redis', { error });\n        });\n      }\n    });\n\n    adapter.on('ticker', (data: Ticker) => {\n      this.emit('ticker', data);\n      this.updateMetrics(exchangeId, 'messagesReceived');\n\n      // Publish to Redis if enabled\n      if (this.redisBridge) {\n        this.redisBridge.publish({ type: 'ticker', data }).catch((error) => {\n          logger.error('Failed to publish ticker to Redis', { error });\n        });\n      }\n    });\n\n    adapter.on('candle', (data: Candle) => {\n      this.emit('candle', data);\n      this.updateMetrics(exchangeId, 'messagesReceived');\n\n      // Publish to Redis if enabled\n      if (this.redisBridge) {\n        this.redisBridge.publish({ type: 'candle', data }).catch((error) => {\n          logger.error('Failed to publish candle to Redis', { error });\n        });\n      }\n    });\n\n    adapter.on('stateChange', (data) => {\n      this.emit('stateChange', data);\n    });\n  }\n\n  /**\n   * Initialize metrics for exchange\n   */\n  private initializeMetrics(exchangeId: ExchangeId): void {\n    this.metrics.set(exchangeId, {\n      exchange: exchangeId,\n      uptime: 0,\n      messagesReceived: 0,\n      messagesSent: 0,\n      reconnections: 0,\n      errors: 0,\n      averageLatency: 0,\n      lastPingTimestamp: 0,\n    });\n  }\n\n  /**\n   * Update metrics\n   */\n  private updateMetrics(\n    exchangeId: ExchangeId,\n    field: keyof ConnectionMetrics,\n    increment: number = 1\n  ): void {\n    if (!this.config.enableMetrics) return;\n\n    const metrics = this.metrics.get(exchangeId);\n    if (!metrics) return;\n\n    if (typeof metrics[field] === 'number') {\n      (metrics[field] as number) += increment;\n    }\n  }\n\n  /**\n   * Get exchange ID from symbol\n   * This is a simplified version - in production you'd maintain a symbol→exchange mapping\n   */\n  private resolveExchangeForSubscribe(request: SubscriptionRequest): ExchangeId {\n    // Prefer explicit exchangeId when provided\n    if (request.exchangeId) {\n      return request.exchangeId;\n    }\n\n    // If only one adapter is connected, default to it for backward compatibility\n    if (this.adapters.size === 1) {\n      return Array.from(this.adapters.keys())[0];\n    }\n\n    // Ambiguous without explicit exchange when multiple exchanges are connected\n    throw new Error(\n      'Ambiguous subscription target: provide request.exchangeId when multiple exchanges are connected'\n    );\n  }\n\n  private resolveExchangeForUnsubscribe(request: SubscriptionRequest): ExchangeId | null {\n    // Prefer explicit exchangeId when provided\n    if (request.exchangeId) {\n      return request.exchangeId;\n    }\n\n    // Look up which exchange holds this subscription\n    const key = `${request.channel}:${request.symbol}`;\n    for (const [ex, subs] of this.subscriptions.entries()) {\n      if (subs.some((s) => `${s.channel}:${s.symbol}` === key)) {\n        return ex;\n      }\n    }\n\n    // If only one adapter exists, use it\n    if (this.adapters.size === 1) {\n      return Array.from(this.adapters.keys())[0];\n    }\n\n    // Not resolvable\n    return null;\n  }\n}\n\n/**\n * Build manager configuration from environment variables\n */\nconst AUTO_RECONNECT_ENV = process.env.MARKET_DATA_WS_AUTO_RECONNECT;\nconst MAX_CONNECTIONS_ENV = process.env.MARKET_DATA_WS_MAX_CONNECTIONS;\nconst CONNECTION_TIMEOUT_ENV = process.env.MARKET_DATA_WS_CONNECTION_TIMEOUT;\nconst ENABLE_METRICS_ENV = process.env.MARKET_DATA_WS_ENABLE_METRICS;\nconst ENABLE_REDIS_ENV = process.env.MARKET_DATA_WS_ENABLE_REDIS;\n\nconst managerConfig: MarketDataManagerConfig = {\n  autoReconnect: AUTO_RECONNECT_ENV\n    ? AUTO_RECONNECT_ENV.toLowerCase() !== 'false'\n    : DEFAULT_CONFIG.autoReconnect,\n  enableMetrics: ENABLE_METRICS_ENV\n    ? ENABLE_METRICS_ENV.toLowerCase() !== 'false'\n    : DEFAULT_CONFIG.enableMetrics,\n  enableRedis: ENABLE_REDIS_ENV ? ENABLE_REDIS_ENV.toLowerCase() === 'true' : false,\n};\n\nconst maxConnections = MAX_CONNECTIONS_ENV ? Number.parseInt(MAX_CONNECTIONS_ENV, 10) : NaN;\nif (!Number.isNaN(maxConnections) && maxConnections > 0) {\n  managerConfig.maxConnections = maxConnections;\n}\n\nconst connectionTimeout = CONNECTION_TIMEOUT_ENV\n  ? Number.parseInt(CONNECTION_TIMEOUT_ENV, 10)\n  : NaN;\nif (!Number.isNaN(connectionTimeout) && connectionTimeout > 0) {\n  managerConfig.connectionTimeout = connectionTimeout;\n}\n\nif (managerConfig.enableRedis) {\n  const redisConfig: RedisEventBridgeConfig = {\n    redisUrl: process.env.MARKET_DATA_REDIS_URL || process.env.REDIS_URL,\n    host: process.env.MARKET_DATA_REDIS_HOST,\n    port: process.env.MARKET_DATA_REDIS_PORT\n      ? Number.parseInt(process.env.MARKET_DATA_REDIS_PORT, 10)\n      : undefined,\n    password: process.env.MARKET_DATA_REDIS_PASSWORD,\n    db: process.env.MARKET_DATA_REDIS_DB\n      ? Number.parseInt(process.env.MARKET_DATA_REDIS_DB, 10)\n      : undefined,\n    keyPrefix: process.env.MARKET_DATA_REDIS_PREFIX,\n    enablePublishing:\n      (process.env.MARKET_DATA_REDIS_PUBLISH ?? 'true').toLowerCase() !== 'false',\n    enableSubscription:\n      (process.env.MARKET_DATA_REDIS_SUBSCRIBE ?? 'true').toLowerCase() !== 'false',\n  };\n\n  // Remove undefined values so defaults remain intact\n  for (const key of Object.keys(redisConfig) as (keyof RedisEventBridgeConfig)[]) {\n    if (redisConfig[key] === undefined) {\n      delete redisConfig[key];\n    }\n  }\n\n  managerConfig.redis = redisConfig;\n}\n\n/**\n * Singleton instance for easy access\n */\nexport const marketDataWebSocketManager = new MarketDataWebSocketManager(managerConfig);\n\n/**\n * Export convenience methods\n */\nexport const connectToExchange = (exchangeId: ExchangeId, config: ConnectionConfig) =>\n  marketDataWebSocketManager.connect(exchangeId, config);\n\nexport const disconnectFromExchange = (exchangeId: ExchangeId) =>\n  marketDataWebSocketManager.disconnect(exchangeId);\n\nexport const subscribeToMarketData = (request: SubscriptionRequest) =>\n  marketDataWebSocketManager.subscribe(request);\n\nexport const unsubscribeFromMarketData = (request: SubscriptionRequest) =>\n  marketDataWebSocketManager.unsubscribe(request);\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/pipeline.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DEFAULT_RECONNECTION' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Data WebSocket Pipeline Bootstrap\n * Connects native exchange adapters and subscribes to default market data feeds.\n */\n\nimport logger from '@/utils/logger';\nimport { marketDataWebSocketManager } from './market-data-websocket-manager';\nimport type { ChannelType, ConnectionConfig, ExchangeId } from './types';\nimport { getDefaultWebSocketConfig } from '@/modules/exchanges';\n\n/**\n * Default reconnection strategy used for all managed exchanges.\n */\nconst DEFAULT_RECONNECTION = {\n  maxAttempts: 5,\n  initialDelay: 1000,\n  maxDelay: 30000,\n  backoffMultiplier: 2,\n  jitterFactor: 0.1,\n} as const;\n\n\n/**\n * Default subscriptions used when no custom configuration is supplied.\n */\nconst DEFAULT_SUBSCRIPTIONS: PipelineSubscription[] = [\n  {\n    exchangeId: 'binance',\n    symbol: 'BTC/USDT',\n    channels: ['ticker', 'trades'],\n  },\n  {\n    exchangeId: 'binance',\n    symbol: 'ETH/USDT',\n    channels: ['ticker'],\n  },\n];\n\ninterface PipelineSubscription {\n  exchangeId: ExchangeId;\n  symbol: string;\n  channels: ChannelType[];\n}\n\nlet initialized = false;\n\n/**\n * Parse MARKET_DATA_WS_SUBSCRIPTIONS env variable.\n * Format: exchange:symbol:channel1,channel2;exchange:symbol:channel\n * Example: binance:BTC/USDT:ticker,trades;kraken:BTC/USD:candles\n */\nfunction parseSubscriptionsFromEnv(): PipelineSubscription[] | null {\n  const raw = process.env.MARKET_DATA_WS_SUBSCRIPTIONS;\n  if (!raw) {\n    return null;\n  }\n\n  const entries = raw\n    .split(/[\\n;]+/)\n    .map((entry) => entry.trim())\n    .filter(Boolean);\n\n  const subscriptions: PipelineSubscription[] = [];\n\n  for (const entry of entries) {\n    const parts = entry.split(':');\n    if (parts.length < 3) {\n      logger.warn('Invalid MARKET_DATA_WS_SUBSCRIPTIONS entry (expected exchange:symbol:channels)', {\n        entry,\n      });\n      continue;\n    }\n\n    const [exchangeRaw, symbolRaw, channelsRaw] = parts;\n    const exchangeId = exchangeRaw.toLowerCase() as ExchangeId;\n\n    // Validar exchange suportada via config centralizado\n    try {\n      getDefaultWebSocketConfig(exchangeId);\n    } catch {\n      logger.warn('Unsupported exchange in MARKET_DATA_WS_SUBSCRIPTIONS entry', {\n        exchange: exchangeRaw,\n      });\n      continue;\n    }\n\n    const channels = channelsRaw\n      .split(',')\n      .map((c) => c.trim().toLowerCase())\n      .filter(Boolean) as ChannelType[];\n\n    const validChannels = channels.filter((channel) =>\n      ['ticker', 'trades', 'orderbook', 'candles'].includes(channel)\n    ) as ChannelType[];\n\n    if (validChannels.length === 0) {\n      logger.warn('No valid channels provided in MARKET_DATA_WS_SUBSCRIPTIONS entry', {\n        entry,\n      });\n      continue;\n    }\n\n    subscriptions.push({\n      exchangeId,\n      symbol: symbolRaw.trim(),\n      channels: validChannels,\n    });\n  }\n\n  return subscriptions;\n}\n\nfunction resolveSubscriptions(): PipelineSubscription[] {\n  const fromEnv = parseSubscriptionsFromEnv();\n  if (fromEnv && fromEnv.length > 0) {\n    return fromEnv;\n  }\n  return DEFAULT_SUBSCRIPTIONS;\n}\n\nfunction resolveConnectionConfig(exchangeId: ExchangeId): ConnectionConfig {\n  const baseConfig = getDefaultWebSocketConfig(exchangeId);\n  const urlOverride = process.env[`MARKET_DATA_WS_${exchangeId.toUpperCase()}_URL`];\n\n  if (!urlOverride) {\n    return baseConfig;\n  }\n\n  return {\n    ...baseConfig,\n    url: urlOverride,\n  };\n}\n\nfunction buildChannelParams(channel: ChannelType): Record<string, unknown> | undefined {\n  if (channel === 'orderbook') {\n    const depthEnv = process.env.MARKET_DATA_WS_ORDERBOOK_DEPTH;\n    const depth = depthEnv ? Number.parseInt(depthEnv, 10) : 20;\n    return { depth: Number.isNaN(depth) ? 20 : depth };\n  }\n\n  if (channel === 'candles') {\n    const timeframe = process.env.MARKET_DATA_WS_CANDLE_TIMEFRAME || '1m';\n    return { interval: timeframe };\n  }\n\n  return undefined;\n}\n\n/**\n * Initialize market data WebSocket pipeline (idempotent).\n */\nexport async function initializeMarketDataPipeline(): Promise<void> {\n  const bootstrapEnabled =\n    (process.env.MARKET_DATA_WS_BOOTSTRAP ?? '').toLowerCase() === 'true';\n\n  if (!bootstrapEnabled) {\n    logger.info(\n      'Market data WebSocket pipeline bootstrap disabled (MARKET_DATA_WS_BOOTSTRAP != true)'\n    );\n    return;\n  }\n\n  if (initialized) {\n    logger.info('Market data WebSocket pipeline already initialized');\n    return;\n  }\n\n  const subscriptions = resolveSubscriptions();\n  if (subscriptions.length === 0) {\n    logger.warn('Market data WebSocket pipeline has no subscriptions configured; skipping');\n    initialized = true;\n    return;\n  }\n\n  const exchangesToConnect = new Set<ExchangeId>(subscriptions.map((s) => s.exchangeId));\n\n  logger.info('Initializing market data WebSocket pipeline', {\n    exchanges: Array.from(exchangesToConnect),\n    totalSubscriptions: subscriptions.length,\n  });\n\n  for (const exchangeId of exchangesToConnect) {\n    if (marketDataWebSocketManager.isConnected(exchangeId)) {\n      logger.info('Exchange already connected, skipping', { exchangeId });\n      continue;\n    }\n\n    try {\n      await marketDataWebSocketManager.connect(\n        exchangeId,\n        resolveConnectionConfig(exchangeId)\n      );\n    } catch (error) {\n      logger.error('Failed to connect exchange WebSocket', {\n        exchange: exchangeId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  for (const { exchangeId, symbol, channels } of subscriptions) {\n    const existingSubscriptions = marketDataWebSocketManager\n      .getSubscriptions(exchangeId)\n      .map((sub) => `${sub.channel}:${sub.symbol}`);\n\n    for (const channel of channels) {\n      const subscriptionKey = `${channel}:${symbol}`;\n      if (existingSubscriptions.includes(subscriptionKey)) {\n        continue;\n      }\n\n      try {\n        await marketDataWebSocketManager.subscribe({\n          exchangeId,\n          channel,\n          symbol,\n          params: buildChannelParams(channel),\n        });\n      } catch (error) {\n        logger.error('Failed to subscribe to market data channel', {\n          exchange: exchangeId,\n          symbol,\n          channel,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n  }\n\n  initialized = true;\n  logger.info('Market data WebSocket pipeline initialized successfully', {\n    activeConnections: Array.from(exchangesToConnect),\n  });\n}\n\n/**\n * Expose initialization status (useful for health checks/tests).\n */\nexport function isMarketDataPipelineInitialized(): boolean {\n  return initialized;\n}\n\n/**\n * Testing utility to reset initialization state between test runs.\n */\nexport function __resetMarketDataPipelineForTests(): void {\n  initialized = false;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/reconnection-strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/redis-event-bridge.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Redis Event Bridge Tests\n * Tests for Redis pub/sub integration for WebSocket event distribution\n */\n\nimport { describe, test, expect, beforeEach, afterEach, mock } from 'bun:test';\nimport { RedisEventBridge } from './redis-event-bridge';\nimport type { WebSocketEvent } from './redis-event-bridge';\nimport type { Ticker, Trade, OrderBook, Candle } from './types';\n\n// Helper to create mock WebSocket events\nconst createMockTicker = (overrides?: Partial<Ticker>): Ticker => ({\n  exchange: 'binance',\n  symbol: 'BTC/USDT',\n  timestamp: Date.now(),\n  datetime: new Date().toISOString(),\n  last: 50000,\n  bid: 49999,\n  ask: 50001,\n  high: 51000,\n  low: 49000,\n  open: 49500,\n  close: 50000,\n  volume: 1000,\n  ...overrides,\n});\n\nconst createMockTrade = (overrides?: Partial<Trade>): Trade => ({\n  exchange: 'binance',\n  symbol: 'BTC/USDT',\n  id: 'trade-1',\n  timestamp: Date.now(),\n  datetime: new Date().toISOString(),\n  side: 'buy',\n  price: 50000,\n  amount: 0.1,\n  cost: 5000,\n  ...overrides,\n});\n\nconst createMockOrderBook = (overrides?: Partial<OrderBook>): OrderBook => ({\n  exchange: 'binance',\n  symbol: 'BTC/USDT',\n  timestamp: Date.now(),\n  datetime: new Date().toISOString(),\n  bids: [[49999, 1.5]],\n  asks: [[50001, 2.0]],\n  ...overrides,\n});\n\nconst createMockCandle = (overrides?: Partial<Candle>): Candle => ({\n  exchange: 'binance',\n  symbol: 'BTC/USDT',\n  timestamp: Date.now(),\n  datetime: new Date().toISOString(),\n  open: 49500,\n  high: 51000,\n  low: 49000,\n  close: 50000,\n  volume: 1000,\n  ...overrides,\n});\n\ndescribe('RedisEventBridge', () => {\n  let bridge: RedisEventBridge;\n\n  beforeEach(() => {\n    // Create a new bridge for each test\n    bridge = new RedisEventBridge({\n      host: 'localhost',\n      port: 6379,\n      keyPrefix: 'test:ws:',\n      enablePublishing: true,\n      enableSubscription: true,\n    });\n  });\n\n  afterEach(async () => {\n    // Clean up after each test\n    if (bridge && bridge.isReady()) {\n      try {\n        await bridge.disconnect();\n      } catch (error) {\n        // Ignore errors during cleanup\n      }\n    }\n  });\n\n  describe('Configuration', () => {\n    test('should create bridge with default config', () => {\n      const defaultBridge = new RedisEventBridge();\n      expect(defaultBridge).toBeDefined();\n      expect(defaultBridge.isReady()).toBe(false);\n    });\n\n    test('should create bridge with custom config', () => {\n      const customBridge = new RedisEventBridge({\n        host: 'custom-redis',\n        port: 6380,\n        keyPrefix: 'custom:',\n        enablePublishing: false,\n        enableSubscription: true,\n      });\n\n      expect(customBridge).toBeDefined();\n      expect(customBridge.isReady()).toBe(false);\n    });\n  });\n\n  describe('Connection Management', () => {\n    test('should report not ready before connection', () => {\n      expect(bridge.isReady()).toBe(false);\n    });\n\n    test('should handle connection without Redis running gracefully', async () => {\n      // This test assumes Redis is NOT running\n      try {\n        await bridge.connect();\n        // If connection succeeds, just disconnect\n        await bridge.disconnect();\n      } catch (error) {\n        // Expected - Redis not running\n        expect(error).toBeDefined();\n      }\n    });\n\n    test('should report ready after successful connection', async () => {\n      // This test requires Redis to be running\n      // Skip if Redis is not available\n      try {\n        await bridge.connect();\n        expect(bridge.isReady()).toBe(true);\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip test if Redis not available\n        console.log('Redis not available, skipping test');\n      }\n    });\n\n    test('should handle disconnect gracefully when not connected', async () => {\n      try {\n        await bridge.disconnect();\n        expect(true).toBe(true); // Should not throw\n      } catch (error) {\n        throw new Error('Should not have thrown');\n      }\n    });\n\n    test('should emit connected event on successful connection', async () => {\n      try {\n        let connectedEmitted = false;\n        bridge.on('connected', () => {\n          connectedEmitted = true;\n        });\n\n        await bridge.connect();\n        expect(connectedEmitted).toBe(true);\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n        console.log('Redis not available, skipping test');\n      }\n    });\n\n    test('should emit disconnected event on disconnect', async () => {\n      try {\n        await bridge.connect();\n\n        let disconnectedEmitted = false;\n        bridge.on('disconnected', () => {\n          disconnectedEmitted = true;\n        });\n\n        await bridge.disconnect();\n        expect(disconnectedEmitted).toBe(true);\n      } catch (error) {\n        // Skip if Redis not available\n        console.log('Redis not available, skipping test');\n      }\n    });\n  });\n\n  describe('Metrics', () => {\n    test('should initialize metrics', () => {\n      const metrics = bridge.getMetrics();\n      expect(metrics).toBeDefined();\n      expect(metrics.connected).toBe(false);\n      expect(metrics.publishedEvents).toBe(0);\n      expect(metrics.receivedEvents).toBe(0);\n      expect(metrics.errors).toBe(0);\n      expect(metrics.subscriptions).toBe(0);\n    });\n\n    test('should track connection state in metrics', async () => {\n      const initialMetrics = bridge.getMetrics();\n      expect(initialMetrics.connected).toBe(false);\n\n      try {\n        await bridge.connect();\n        const connectedMetrics = bridge.getMetrics();\n        expect(connectedMetrics.connected).toBe(true);\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should return metrics after disconnect', async () => {\n      try {\n        await bridge.connect();\n        await bridge.disconnect();\n\n        const metrics = bridge.getMetrics();\n        expect(metrics).toBeDefined();\n        expect(metrics.connected).toBe(false);\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n  });\n\n  describe('Publishing', () => {\n    test('should not throw when publishing without connection', async () => {\n      const event: WebSocketEvent = {\n        type: 'ticker',\n        data: createMockTicker(),\n      };\n\n      try {\n        await bridge.publish(event);\n        expect(true).toBe(true); // Should not throw\n      } catch (error) {\n        throw new Error('Should not have thrown');\n      }\n    });\n\n    test('should publish ticker event when connected', async () => {\n      try {\n        await bridge.connect();\n\n        const event: WebSocketEvent = {\n          type: 'ticker',\n          data: createMockTicker(),\n        };\n\n        await bridge.publish(event);\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n        console.log('Redis not available, skipping test');\n      }\n    });\n\n    test('should publish trade event when connected', async () => {\n      try {\n        await bridge.connect();\n\n        const event: WebSocketEvent = {\n          type: 'trade',\n          data: createMockTrade(),\n        };\n\n        await bridge.publish(event);\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should publish orderbook event when connected', async () => {\n      try {\n        await bridge.connect();\n\n        const event: WebSocketEvent = {\n          type: 'orderbook',\n          data: createMockOrderBook(),\n        };\n\n        await bridge.publish(event);\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should publish candle event when connected', async () => {\n      try {\n        await bridge.connect();\n\n        const event: WebSocketEvent = {\n          type: 'candle',\n          data: createMockCandle(),\n        };\n\n        await bridge.publish(event);\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should publish exchange event when connected', async () => {\n      try {\n        await bridge.connect();\n\n        const event: WebSocketEvent = {\n          type: 'exchange:connected',\n          data: { exchange: 'binance', timestamp: Date.now() },\n        };\n\n        await bridge.publish(event);\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should track published events count', async () => {\n      try {\n        await bridge.connect();\n\n        // Publish multiple events\n        for (let i = 0; i < 5; i++) {\n          await bridge.publish({\n            type: 'ticker',\n            data: createMockTicker({ last: 50000 + i }),\n          });\n        }\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(5);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n  });\n\n  describe('Subscription', () => {\n    test('should not throw when subscribing without connection', async () => {\n      try {\n        await bridge.subscribe('ticker');\n        expect(true).toBe(true); // Should not throw\n      } catch (error) {\n        throw new Error('Should not have thrown');\n      }\n    });\n\n    test('should subscribe to ticker channel when connected', async () => {\n      try {\n        await bridge.connect();\n        await bridge.subscribe('ticker');\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should subscribe to multiple channels', async () => {\n      try {\n        await bridge.connect();\n\n        await bridge.subscribe('ticker');\n        await bridge.subscribe('trade');\n        await bridge.subscribe('orderbook');\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(3);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should not duplicate subscriptions', async () => {\n      try {\n        await bridge.connect();\n\n        await bridge.subscribe('ticker');\n        await bridge.subscribe('ticker'); // Duplicate\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(1);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should subscribe to all event types', async () => {\n      try {\n        await bridge.connect();\n        await bridge.subscribeAll();\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(8); // ticker, trade, orderbook, candle, 4 exchange events\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should emit subscribed event', async () => {\n      try {\n        await bridge.connect();\n\n        let subscribedData: any = null;\n        bridge.on('subscribed', (data) => {\n          subscribedData = data;\n        });\n\n        await bridge.subscribe('ticker');\n\n        expect(subscribedData).toBeDefined();\n        expect(subscribedData.eventType).toBe('ticker');\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should unsubscribe from channel', async () => {\n      try {\n        await bridge.connect();\n\n        await bridge.subscribe('ticker');\n        let metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(1);\n\n        await bridge.unsubscribe('ticker');\n        metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(0);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should unsubscribe from all channels', async () => {\n      try {\n        await bridge.connect();\n\n        await bridge.subscribeAll();\n        let metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBeGreaterThan(0);\n\n        await bridge.unsubscribeAll();\n        metrics = bridge.getMetrics();\n        expect(metrics.subscriptions).toBe(0);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n  });\n\n  describe('Event Handling', () => {\n    test('should emit received events to local listeners', async () => {\n      try {\n        // Create two bridges to simulate two instances\n        const publisher = new RedisEventBridge({\n          host: 'localhost',\n          port: 6379,\n          keyPrefix: 'test:ws:',\n        });\n\n        const subscriber = new RedisEventBridge({\n          host: 'localhost',\n          port: 6379,\n          keyPrefix: 'test:ws:',\n        });\n\n        await publisher.connect();\n        await subscriber.connect();\n        await subscriber.subscribe('ticker');\n\n        // Wait for subscription to be ready\n        await new Promise((resolve) => setTimeout(resolve, 100));\n\n        let receivedTicker: Ticker | null = null;\n        subscriber.on('ticker', (data: Ticker) => {\n          receivedTicker = data;\n        });\n\n        // Publish from first instance\n        const tickerData = createMockTicker();\n        await publisher.publish({\n          type: 'ticker',\n          data: tickerData,\n        });\n\n        // Wait for message to be received\n        await new Promise((resolve) => setTimeout(resolve, 100));\n\n        expect(receivedTicker).toBeDefined();\n        if (receivedTicker) {\n          expect(receivedTicker.symbol).toBe('BTC/USDT');\n          expect(receivedTicker.last).toBe(50000);\n        }\n\n        await publisher.disconnect();\n        await subscriber.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n        console.log('Redis not available, skipping test');\n      }\n    });\n\n    test('should not receive own published events', async () => {\n      try {\n        await bridge.connect();\n        await bridge.subscribe('ticker');\n\n        let receivedCount = 0;\n        bridge.on('ticker', () => {\n          receivedCount++;\n        });\n\n        // Publish event\n        await bridge.publish({\n          type: 'ticker',\n          data: createMockTicker(),\n        });\n\n        // Wait for potential message\n        await new Promise((resolve) => setTimeout(resolve, 100));\n\n        // Should not receive own message (filtered by process.pid)\n        expect(receivedCount).toBe(0);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should track received events count', async () => {\n      try {\n        const publisher = new RedisEventBridge({\n          host: 'localhost',\n          port: 6379,\n          keyPrefix: 'test:ws:',\n        });\n\n        const subscriber = new RedisEventBridge({\n          host: 'localhost',\n          port: 6379,\n          keyPrefix: 'test:ws:',\n        });\n\n        await publisher.connect();\n        await subscriber.connect();\n        await subscriber.subscribe('ticker');\n\n        await new Promise((resolve) => setTimeout(resolve, 100));\n\n        // Publish 3 events\n        for (let i = 0; i < 3; i++) {\n          await publisher.publish({\n            type: 'ticker',\n            data: createMockTicker({ last: 50000 + i }),\n          });\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 200));\n\n        const metrics = subscriber.getMetrics();\n        expect(metrics.receivedEvents).toBe(3);\n\n        await publisher.disconnect();\n        await subscriber.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle invalid Redis configuration', async () => {\n      const invalidBridge = new RedisEventBridge({\n        host: 'invalid-host-that-does-not-exist',\n        port: 6380, // Valid port, invalid host\n      });\n\n      // Suppress error listeners to avoid unhandled errors\n      invalidBridge.on('error', () => {\n        // Ignore\n      });\n\n      try {\n        await invalidBridge.connect();\n        // Should fail\n        expect(true).toBe(false);\n      } catch (error) {\n        expect(error).toBeDefined();\n      }\n    });\n\n    test('should emit error event on connection failure', async () => {\n      const invalidBridge = new RedisEventBridge({\n        host: 'invalid-host',\n        port: 6380, // Valid port, invalid host\n      });\n\n      let errorEmitted = false;\n      invalidBridge.on('error', () => {\n        errorEmitted = true;\n      });\n\n      try {\n        await invalidBridge.connect();\n      } catch (error) {\n        // Expected\n      }\n\n      // Wait for error event\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      expect(errorEmitted).toBe(true);\n    });\n\n    test('should gracefully handle publish errors when disconnected', async () => {\n      try {\n        await bridge.connect();\n      } catch (error) {\n        // Skip if Redis not available\n        console.log('Redis not available, skipping test');\n        return;\n      }\n\n      await bridge.disconnect();\n\n      // Should not throw\n      await bridge.publish({\n        type: 'ticker',\n        data: createMockTicker(),\n      });\n\n      expect(true).toBe(true);\n    });\n  });\n\n  describe('Performance', () => {\n    test('should handle rapid event publishing', async () => {\n      try {\n        await bridge.connect();\n\n        // Publish many events rapidly\n        const promises: Promise<void>[] = [];\n        for (let i = 0; i < 100; i++) {\n          promises.push(\n            bridge.publish({\n              type: 'ticker',\n              data: createMockTicker({ last: 50000 + i }),\n            })\n          );\n        }\n\n        await Promise.all(promises);\n\n        const metrics = bridge.getMetrics();\n        expect(metrics.publishedEvents).toBe(100);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n\n    test('should maintain performance with many subscriptions', async () => {\n      try {\n        await bridge.connect();\n\n        const start = Date.now();\n        await bridge.subscribeAll();\n        const duration = Date.now() - start;\n\n        // Should complete quickly (< 1 second)\n        expect(duration).toBeLessThan(1000);\n\n        await bridge.disconnect();\n      } catch (error) {\n        // Skip if Redis not available\n      }\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/redis-event-bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/market-data/websocket/websocket-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/__tests__/email-validator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/__tests__/scoring.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/__tests__/template-renderer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/routes/marketing.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/analytics.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/campaign-sends.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/campaigns.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/lead-activities.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/leads.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/schema/templates.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/services/leads.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/services/scoring.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/types/marketing.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/utils/csv-parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/utils/email-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/marketing/utils/template-renderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/routes/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/routes/mmn.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/routes/visualization.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/schema/mmn.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/commission.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/genealogy.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/payout.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/rank.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/tree.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/services/volume.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/types/mmn.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/utils/binary-tree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/mmn/utils/spillover-algorithm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/monitoring/metrics/collectors/system.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/monitoring/metrics/registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/__tests__/email-provider.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'provider' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":169,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Email Provider Tests\n * Complete test coverage for SMTP and SendGrid implementations\n */\n\nimport { describe, test, expect, beforeEach, mock } from 'bun:test';\nimport { EmailProvider } from '../providers/email-provider';\n\ndescribe('EmailProvider', () => {\n  describe('SMTP Provider', () => {\n    let provider: EmailProvider;\n\n    beforeEach(() => {\n      provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'smtp',\n          smtp: {\n            host: 'smtp.test.com',\n            port: 587,\n            secure: false,\n            auth: {\n              user: 'test@test.com',\n              pass: 'testpass',\n            },\n          },\n          from: 'noreply@test.com',\n          fromName: 'Test',\n        },\n      });\n    });\n\n    test('should initialize SMTP provider', () => {\n      expect(provider).toBeDefined();\n      expect(provider.isEnabled()).toBe(true);\n    });\n\n    test('should validate email addresses correctly', () => {\n      expect(provider.validateRecipient('test@example.com')).toBe(true);\n      expect(provider.validateRecipient('user+tag@domain.co.uk')).toBe(true);\n      expect(provider.validateRecipient('invalid-email')).toBe(false);\n      expect(provider.validateRecipient('no-at-sign.com')).toBe(false);\n      expect(provider.validateRecipient('')).toBe(false);\n    });\n\n    test('should return provider info', () => {\n      const info = provider.getInfo();\n      expect(info.type).toBe('email');\n      expect(info.providerName).toBe('SMTP');\n      expect(info.enabled).toBe(true);\n    });\n\n    test('should reject invalid recipient', async () => {\n      const result = await provider.send({\n        notificationId: 'test-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        recipient: 'invalid-email',\n        subject: 'Test',\n        content: 'Test content',\n        priority: 'normal',\n      });\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('INVALID_RECIPIENT');\n    });\n\n    test('should handle disabled provider', () => {\n      const disabledProvider = new EmailProvider({\n        enabled: false,\n        credentials: {\n          provider: 'smtp',\n          from: 'test@test.com',\n        },\n      });\n\n      expect(disabledProvider.isEnabled()).toBe(false);\n    });\n  });\n\n  describe('SendGrid Provider', () => {\n    let provider: EmailProvider;\n\n    beforeEach(() => {\n      provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'sendgrid',\n          sendgrid: {\n            apiKey: 'SG.test_api_key_1234567890',\n          },\n          from: 'noreply@test.com',\n          fromName: 'SendGrid Test',\n        },\n      });\n    });\n\n    test('should initialize SendGrid provider', () => {\n      expect(provider).toBeDefined();\n      expect(provider.isEnabled()).toBe(true);\n    });\n\n    test('should return SendGrid provider info', () => {\n      const info = provider.getInfo();\n      expect(info.type).toBe('email');\n      expect(info.providerName).toBe('SendGrid');\n      expect(info.enabled).toBe(true);\n    });\n\n    test('should validate SendGrid API key format', async () => {\n      const testConnection = await provider.testConnection();\n      expect(typeof testConnection).toBe('boolean');\n    });\n  });\n\n  describe('Configuration Validation', () => {\n    test('should reject invalid SMTP configuration', () => {\n      const provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'smtp',\n          smtp: {\n            host: '',\n            port: 0,\n            secure: false,\n            auth: {\n              user: '',\n              pass: '',\n            },\n          },\n          from: 'invalid',\n        },\n      });\n\n      // Provider with invalid config should be disabled\n      expect(provider.isEnabled()).toBe(false);\n    });\n\n    test('should handle missing credentials gracefully', () => {\n      const provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'smtp',\n          from: 'test@test.com',\n        },\n      });\n\n      // Provider with missing SMTP credentials should be disabled\n      expect(provider.isEnabled()).toBe(false);\n    });\n\n    test('should load from environment variables', () => {\n      // Test environment-based configuration\n      process.env.EMAIL_PROVIDER = 'smtp';\n      process.env.EMAIL_FROM = 'env@test.com';\n      process.env.SMTP_HOST = 'smtp.env.com';\n      process.env.SMTP_PORT = '587';\n      process.env.SMTP_USER = 'envuser';\n      process.env.SMTP_PASS = 'envpass';\n\n      // Provider should load these values\n      expect(process.env.EMAIL_PROVIDER).toBe('smtp');\n      expect(process.env.EMAIL_FROM).toBe('env@test.com');\n    });\n  });\n\n  describe('Email Content Handling', () => {\n    test('should handle HTML content', async () => {\n      const provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'smtp',\n          smtp: {\n            host: 'smtp.test.com',\n            port: 587,\n            secure: false,\n            auth: { user: 'test', pass: 'test' },\n          },\n          from: 'test@test.com',\n        },\n      });\n\n      const htmlContent = '<h1>Test</h1><p>This is a <strong>test</strong> email.</p>';\n\n      // Validate that HTML is accepted\n      expect(htmlContent).toContain('<h1>');\n      expect(htmlContent).toContain('<strong>');\n    });\n\n    test('should strip HTML for text version', () => {\n      const htmlContent = '<h1>Title</h1><p>Paragraph</p>';\n      const textContent = htmlContent.replace(/<[^>]*>/g, '').trim();\n\n      expect(textContent).toBe('TitleParagraph');\n      expect(textContent).not.toContain('<');\n      expect(textContent).not.toContain('>');\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle send failures gracefully', async () => {\n      const provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'smtp',\n          smtp: {\n            host: 'nonexistent.smtp.com',\n            port: 587,\n            secure: false,\n            auth: { user: 'test', pass: 'test' },\n          },\n          from: 'test@test.com',\n        },\n      });\n\n      const result = await provider.send({\n        notificationId: 'test-error',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        recipient: 'valid@example.com',\n        subject: 'Test',\n        content: 'Test',\n        priority: 'normal',\n      });\n\n      // Should handle connection errors\n      expect(['EMAIL_SEND_FAILED', 'PROVIDER_NOT_CONFIGURED']).toContain(\n        result.errorCode || ''\n      );\n    });\n  });\n\n  describe('Cleanup', () => {\n    test('should cleanup resources', async () => {\n      const provider = new EmailProvider({\n        enabled: true,\n        credentials: {\n          provider: 'smtp',\n          smtp: {\n            host: 'smtp.test.com',\n            port: 587,\n            secure: false,\n            auth: { user: 'test', pass: 'test' },\n          },\n          from: 'test@test.com',\n        },\n      });\n\n      await provider.cleanup();\n      // Should not throw\n      expect(true).toBe(true);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/__tests__/notification-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'expectedSubject' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":95,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'expectedBody' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":96,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'template' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":104,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'notification' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":132,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'statuses' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":342,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":342,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activeJobs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":487,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":487,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification System Integration Tests\n * End-to-end tests for the complete notification flow\n */\n\nimport { describe, test, expect } from 'bun:test';\nimport type { SendNotificationRequest } from '../types/notification.types';\n\ndescribe('Notification System Integration', () => {\n  describe('End-to-End Notification Flow', () => {\n    test('should process notification request through all stages', () => {\n      const request: SendNotificationRequest = {\n        userId: 'user_123',\n        tenantId: 'tenant_001',\n        type: 'email',\n        category: 'trade',\n        priority: 'high',\n        subject: 'Trade Executed',\n        content: 'Your BTC/USDT trade was executed successfully',\n        metadata: {\n          tradeId: 'trade_456',\n          amount: 0.5,\n        },\n      };\n\n      // Stages:\n      // 1. Check user preferences\n      // 2. Process template (if provided)\n      // 3. Create notification record\n      // 4. Queue for delivery\n      // 5. Deliver via provider\n      // 6. Log delivery attempt\n\n      expect(request.userId).toBe('user_123');\n      expect(request.type).toBe('email');\n      expect(request.priority).toBe('high');\n    });\n\n    test('should handle notification with template', () => {\n      const request: SendNotificationRequest = {\n        userId: 'user_123',\n        tenantId: 'tenant_001',\n        type: 'email',\n        templateId: 'template_trade_alert',\n        variables: {\n          userName: 'John Doe',\n          tradePair: 'BTC/USDT',\n          amount: '0.5',\n          price: '45000',\n          total: '22500',\n        },\n      };\n\n      expect(request.templateId).toBe('template_trade_alert');\n      expect(request.variables).toBeDefined();\n      expect(Object.keys(request.variables!)).toHaveLength(5);\n    });\n\n    test('should respect user notification preferences', () => {\n      const userPreferences = {\n        userId: 'user_123',\n        tenantId: 'tenant_001',\n        notificationType: 'trade',\n        isEnabled: true,\n        channelPreferences: {\n          email: true,\n          push: true,\n          telegram: false,\n          sms: false,\n        },\n      };\n\n      expect(userPreferences.isEnabled).toBe(true);\n      expect(userPreferences.channelPreferences.email).toBe(true);\n      expect(userPreferences.channelPreferences.telegram).toBe(false);\n    });\n  });\n\n  describe('Template Processing Integration', () => {\n    test('should render template with variables', () => {\n      const template = {\n        id: 'template_123',\n        subject: 'Trade Alert: {{tradePair}}',\n        body: 'Hello {{userName}}, your trade of {{amount}} {{tradePair}} at {{price}} has been executed.',\n        variables: ['userName', 'tradePair', 'amount', 'price'],\n      };\n\n      const variables = {\n        userName: 'John Doe',\n        tradePair: 'BTC/USDT',\n        amount: '0.5',\n        price: '45000',\n      };\n\n      const expectedSubject = 'Trade Alert: BTC/USDT';\n      const expectedBody =\n        'Hello John Doe, your trade of 0.5 BTC/USDT at 45000 has been executed.';\n\n      expect(template.variables).toContain('userName');\n      expect(Object.keys(variables)).toHaveLength(4);\n    });\n\n    test('should handle missing template variables gracefully', () => {\n      const template = 'Hello {{userName}}, your balance is {{balance}}';\n      const variables = {\n        userName: 'John Doe',\n        // balance is missing\n      };\n\n      // Should either use default value or keep placeholder\n      expect(variables.userName).toBe('John Doe');\n      expect(variables).not.toHaveProperty('balance');\n    });\n\n    test('should support conditional template sections', () => {\n      const template = {\n        body: 'Trade executed. {{#hasProfit}}You made a profit of {{profit}}!{{/hasProfit}}',\n        variables: {\n          hasProfit: true,\n          profit: '500 USDT',\n        },\n      };\n\n      expect(template.variables).toHaveProperty('hasProfit');\n      expect(template.variables.hasProfit).toBe(true);\n    });\n  });\n\n  describe('Multi-Channel Notification', () => {\n    test('should send same notification via multiple channels', () => {\n      const channels = ['email', 'push', 'telegram', 'in_app'];\n      const notification = {\n        userId: 'user_123',\n        subject: 'Important Alert',\n        content: 'Your account requires attention',\n      };\n\n      channels.forEach((channel) => {\n        expect(['email', 'push', 'telegram', 'sms', 'in_app']).toContain(channel);\n      });\n\n      expect(channels).toHaveLength(4);\n    });\n\n    test('should track delivery status per channel', () => {\n      const deliveryStatuses = {\n        email: { sent: true, deliveredAt: new Date() },\n        push: { sent: true, deliveredAt: new Date() },\n        telegram: { sent: false, error: 'Bot blocked by user' },\n        in_app: { sent: true, deliveredAt: new Date() },\n      };\n\n      expect(deliveryStatuses.email.sent).toBe(true);\n      expect(deliveryStatuses.telegram.sent).toBe(false);\n      expect(deliveryStatuses.telegram.error).toBeDefined();\n    });\n  });\n\n  describe('Queue Integration', () => {\n    test('should add notification to queue with correct priority', () => {\n      const job = {\n        notificationId: 'notif_123',\n        type: 'email' as const,\n        priority: 'urgent' as const,\n        data: {\n          userId: 'user_123',\n          tenantId: 'tenant_001',\n          content: 'Critical security alert',\n        },\n        maxAttempts: 3,\n      };\n\n      expect(job.priority).toBe('urgent');\n      expect(job.maxAttempts).toBe(3);\n    });\n\n    test('should process jobs in priority order', () => {\n      const jobs = [\n        { id: 'job_1', priority: 'normal', value: 3 },\n        { id: 'job_2', priority: 'urgent', value: 1 },\n        { id: 'job_3', priority: 'low', value: 4 },\n        { id: 'job_4', priority: 'high', value: 2 },\n      ];\n\n      const sorted = jobs.sort((a, b) => a.value - b.value);\n\n      expect(sorted[0].priority).toBe('urgent');\n      expect(sorted[1].priority).toBe('high');\n      expect(sorted[2].priority).toBe('normal');\n      expect(sorted[3].priority).toBe('low');\n    });\n\n    test('should retry failed deliveries', () => {\n      const job = {\n        id: 'job_123',\n        attempts: 0,\n        maxAttempts: 3,\n      };\n\n      // Simulate 3 attempts\n      for (let i = 0; i < 3; i++) {\n        job.attempts++;\n      }\n\n      expect(job.attempts).toBe(3);\n      expect(job.attempts).toBe(job.maxAttempts);\n    });\n  });\n\n  describe('Provider Integration', () => {\n    test('should select correct provider for notification type', () => {\n      const providerMap = {\n        email: 'EmailProvider',\n        push: 'PushProvider',\n        telegram: 'TelegramProvider',\n        in_app: 'InAppProvider',\n      };\n\n      expect(providerMap.email).toBe('EmailProvider');\n      expect(providerMap.push).toBe('PushProvider');\n      expect(providerMap.telegram).toBe('TelegramProvider');\n    });\n\n    test('should fallback when provider unavailable', () => {\n      const primaryProvider = { type: 'sendgrid', available: false };\n      const fallbackProvider = { type: 'smtp', available: true };\n\n      const selectedProvider = primaryProvider.available\n        ? primaryProvider\n        : fallbackProvider;\n\n      expect(selectedProvider.type).toBe('smtp');\n      expect(selectedProvider.available).toBe(true);\n    });\n\n    test('should validate recipient before sending', () => {\n      const emailRecipient = 'user@example.com';\n      const telegramRecipient = '@username';\n      const pushRecipient =\n        'fGc1Y2xZ8N0:APA91bF7K_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n      // Email validation\n      expect(emailRecipient).toContain('@');\n      expect(emailRecipient).toContain('.');\n\n      // Telegram validation\n      expect(telegramRecipient).toMatch(/^@[a-zA-Z0-9_]{5,32}$/);\n\n      // Push validation\n      expect(pushRecipient.length).toBeGreaterThan(50);\n    });\n  });\n\n  describe('Delivery Logging', () => {\n    test('should log successful delivery', () => {\n      const log = {\n        notificationId: 'notif_123',\n        attemptNumber: 1,\n        status: 'success',\n        providerName: 'SendGrid',\n        providerMessageId: 'msg_456',\n        deliveredAt: new Date(),\n      };\n\n      expect(log.status).toBe('success');\n      expect(log.providerMessageId).toBeDefined();\n      expect(log.deliveredAt).toBeInstanceOf(Date);\n    });\n\n    test('should log failed delivery with error details', () => {\n      const log = {\n        notificationId: 'notif_123',\n        attemptNumber: 2,\n        status: 'failed',\n        providerName: 'SMTP',\n        errorCode: 'SMTP_CONNECTION_FAILED',\n        errorMessage: 'Connection timeout after 30 seconds',\n      };\n\n      expect(log.status).toBe('failed');\n      expect(log.errorCode).toBe('SMTP_CONNECTION_FAILED');\n      expect(log.errorMessage).toContain('timeout');\n    });\n\n    test('should track multiple delivery attempts', () => {\n      const attempts = [\n        { attemptNumber: 1, status: 'failed', error: 'Network error' },\n        { attemptNumber: 2, status: 'failed', error: 'Timeout' },\n        { attemptNumber: 3, status: 'success', providerId: 'msg_123' },\n      ];\n\n      expect(attempts).toHaveLength(3);\n      expect(attempts[0].status).toBe('failed');\n      expect(attempts[2].status).toBe('success');\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle provider not configured', () => {\n      const result = {\n        success: false,\n        errorCode: 'PROVIDER_NOT_CONFIGURED',\n        errorMessage: 'Email provider is not properly configured',\n      };\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('PROVIDER_NOT_CONFIGURED');\n    });\n\n    test('should handle invalid recipient', () => {\n      const result = {\n        success: false,\n        errorCode: 'INVALID_RECIPIENT',\n        errorMessage: 'Invalid email address format',\n      };\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('INVALID_RECIPIENT');\n    });\n\n    test('should handle user preferences disabled', () => {\n      const result = {\n        success: false,\n        message: 'User has disabled this notification type',\n      };\n\n      expect(result.success).toBe(false);\n      expect(result.message).toContain('disabled');\n    });\n\n    test('should handle no provider available', () => {\n      const notificationType = 'sms';\n      const availableProviders = ['email', 'push', 'telegram', 'in_app'];\n\n      const isAvailable = availableProviders.includes(notificationType);\n      expect(isAvailable).toBe(false);\n    });\n  });\n\n  describe('Notification Status Lifecycle', () => {\n    test('should transition through status states', () => {\n      const statuses = ['pending', 'sent', 'read'];\n\n      let currentStatus = 'pending';\n      expect(currentStatus).toBe('pending');\n\n      currentStatus = 'sent';\n      expect(currentStatus).toBe('sent');\n\n      currentStatus = 'read';\n      expect(currentStatus).toBe('read');\n    });\n\n    test('should track notification timestamps', () => {\n      const notification = {\n        id: 'notif_123',\n        createdAt: new Date('2025-01-01T10:00:00Z'),\n        sentAt: new Date('2025-01-01T10:00:05Z'),\n        readAt: new Date('2025-01-01T10:05:00Z'),\n      };\n\n      expect(notification.sentAt.getTime()).toBeGreaterThan(\n        notification.createdAt.getTime()\n      );\n      expect(notification.readAt!.getTime()).toBeGreaterThan(notification.sentAt!.getTime());\n    });\n\n    test('should handle failed status', () => {\n      const notification = {\n        id: 'notif_123',\n        status: 'failed',\n        failureReason: 'Provider unavailable after 3 attempts',\n      };\n\n      expect(notification.status).toBe('failed');\n      expect(notification.failureReason).toContain('3 attempts');\n    });\n  });\n\n  describe('Bulk Notifications', () => {\n    test('should process multiple notifications efficiently', () => {\n      const users = ['user_1', 'user_2', 'user_3', 'user_4', 'user_5'];\n      const notifications = users.map((userId) => ({\n        userId,\n        tenantId: 'tenant_001',\n        type: 'email' as const,\n        subject: 'System Maintenance',\n        content: 'Scheduled maintenance tonight at 2 AM',\n      }));\n\n      expect(notifications).toHaveLength(5);\n      notifications.forEach((notif) => {\n        expect(notif.type).toBe('email');\n        expect(notif.subject).toBe('System Maintenance');\n      });\n    });\n\n    test('should batch multicast push notifications', () => {\n      const deviceTokens = [\n        'token1_12345678901234567890123456789012345678901234567890123456789012',\n        'token2_12345678901234567890123456789012345678901234567890123456789012',\n        'token3_12345678901234567890123456789012345678901234567890123456789012',\n      ];\n\n      const batchSize = 500; // FCM supports up to 500 tokens per batch\n      expect(deviceTokens.length).toBeLessThanOrEqual(batchSize);\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    test('should handle high-volume notifications', () => {\n      const notificationsPerSecond = 1000;\n      const queueCapacity = 10000;\n      const workerConcurrency = 10;\n\n      // Calculate processing capacity\n      const maxThroughput = workerConcurrency * 10; // 10 notifications per second per worker\n\n      expect(queueCapacity).toBeGreaterThan(notificationsPerSecond);\n      expect(maxThroughput).toBeGreaterThan(0);\n    });\n\n    test('should cleanup old completed jobs', () => {\n      const keepLastN = 100;\n      const totalCompleted = 5000;\n      const shouldCleanup = totalCompleted > keepLastN;\n\n      expect(shouldCleanup).toBe(true);\n      expect(totalCompleted - keepLastN).toBe(4900);\n    });\n  });\n\n  describe('Security and Privacy', () => {\n    test('should not log sensitive data', () => {\n      const log = {\n        notificationId: 'notif_123',\n        userId: 'user_123',\n        type: 'email',\n        // Should NOT include: email content, recipient address, user data\n      };\n\n      expect(log).not.toHaveProperty('content');\n      expect(log).not.toHaveProperty('recipient');\n      expect(log).not.toHaveProperty('personalData');\n    });\n\n    test('should mask device tokens in logs', () => {\n      const fullToken =\n        'fGc1Y2xZ8N0:APA91bF7K_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n      const maskedToken = fullToken.substring(0, 20) + '...';\n\n      expect(maskedToken).toBe('fGc1Y2xZ8N0:APA91bF7...');\n      expect(maskedToken.length).toBeLessThan(fullToken.length);\n    });\n  });\n\n  describe('Monitoring and Observability', () => {\n    test('should track notification metrics', () => {\n      const metrics = {\n        totalSent: 1000,\n        totalFailed: 50,\n        successRate: 0.95,\n        averageDeliveryTime: 2.5, // seconds\n      };\n\n      expect(metrics.successRate).toBeGreaterThan(0.9);\n      expect(metrics.averageDeliveryTime).toBeLessThan(5);\n    });\n\n    test('should track queue health', () => {\n      const queueHealth = {\n        waiting: 10,\n        active: 5,\n        completed: 1000,\n        failed: 20,\n        isHealthy: true,\n      };\n\n      const failureRate = queueHealth.failed / queueHealth.completed;\n      expect(failureRate).toBeLessThan(0.05); // Less than 5% failure rate\n      expect(queueHealth.isHealthy).toBe(true);\n    });\n  });\n\n  describe('Graceful Shutdown', () => {\n    test('should complete active jobs before shutdown', () => {\n      const activeJobs = 3;\n      const shutdownSteps = [\n        'Stop accepting new jobs',\n        'Wait for active jobs to complete',\n        'Close worker',\n        'Close queue',\n        'Disconnect Redis',\n      ];\n\n      expect(shutdownSteps).toHaveLength(5);\n      expect(shutdownSteps[1]).toBe('Wait for active jobs to complete');\n    });\n\n    test('should handle shutdown timeout', () => {\n      const shutdownTimeout = 30000; // 30 seconds\n      const gracePeriod = 25000; // 25 seconds\n\n      expect(gracePeriod).toBeLessThan(shutdownTimeout);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/__tests__/notification-queue.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'beforeEach' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'afterEach' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NotificationQueue' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Queue Tests\n * Complete test coverage for BullMQ-based notification queue\n */\n\nimport { describe, test, expect, beforeEach, afterEach } from 'bun:test';\nimport type { NotificationJob, NotificationQueue } from '../utils/notification-queue';\nimport type { NotificationType, NotificationPriority } from '../types/notification.types';\n\ndescribe('NotificationQueue', () => {\n  describe('Queue Configuration', () => {\n    test('should use default configuration values', () => {\n      const defaultConfig = {\n        redis: {\n          host: 'localhost',\n          port: 6379,\n          db: 0,\n          maxRetriesPerRequest: 3,\n        },\n        queue: {\n          maxConcurrent: 10,\n          retryDelay: 5000,\n          maxRetries: 3,\n          removeOnComplete: 100,\n          removeOnFail: 1000,\n        },\n      };\n\n      expect(defaultConfig.redis.host).toBe('localhost');\n      expect(defaultConfig.redis.port).toBe(6379);\n      expect(defaultConfig.queue.maxConcurrent).toBe(10);\n      expect(defaultConfig.queue.maxRetries).toBe(3);\n    });\n\n    test('should load configuration from environment', () => {\n      process.env.REDIS_HOST = 'redis.test.com';\n      process.env.REDIS_PORT = '6380';\n      process.env.REDIS_PASSWORD = 'test-password';\n      process.env.REDIS_DB = '1';\n\n      expect(process.env.REDIS_HOST).toBe('redis.test.com');\n      expect(parseInt(process.env.REDIS_PORT, 10)).toBe(6380);\n      expect(process.env.REDIS_PASSWORD).toBe('test-password');\n      expect(parseInt(process.env.REDIS_DB, 10)).toBe(1);\n    });\n\n    test('should support custom configuration', () => {\n      const customConfig = {\n        redis: {\n          host: 'custom-redis.com',\n          port: 6380,\n          password: 'secure-password',\n          db: 2,\n        },\n        queue: {\n          maxConcurrent: 20,\n          retryDelay: 10000,\n          maxRetries: 5,\n          removeOnComplete: 200,\n          removeOnFail: 2000,\n        },\n      };\n\n      expect(customConfig.queue.maxConcurrent).toBe(20);\n      expect(customConfig.queue.retryDelay).toBe(10000);\n      expect(customConfig.queue.maxRetries).toBe(5);\n    });\n  });\n\n  describe('Job Structure', () => {\n    test('should create valid notification job', () => {\n      const job: NotificationJob = {\n        id: 'job_123',\n        notificationId: 'notif_456',\n        type: 'email',\n        priority: 'high',\n        data: {\n          userId: 'user_789',\n          tenantId: 'tenant_001',\n          subject: 'Test Email',\n          content: 'This is a test notification',\n          metadata: {\n            category: 'trade',\n          },\n        },\n        attempts: 0,\n        maxAttempts: 3,\n        createdAt: new Date(),\n      };\n\n      expect(job.id).toBe('job_123');\n      expect(job.notificationId).toBe('notif_456');\n      expect(job.type).toBe('email');\n      expect(job.priority).toBe('high');\n      expect(job.attempts).toBe(0);\n    });\n\n    test('should support all notification types', () => {\n      const types: NotificationType[] = ['email', 'push', 'telegram', 'in_app'];\n\n      types.forEach((type) => {\n        expect(['email', 'push', 'telegram', 'sms', 'in_app']).toContain(type);\n      });\n    });\n\n    test('should support all priority levels', () => {\n      const priorities: NotificationPriority[] = ['urgent', 'high', 'normal', 'low'];\n\n      priorities.forEach((priority) => {\n        expect(['urgent', 'high', 'normal', 'low']).toContain(priority);\n      });\n    });\n  });\n\n  describe('Priority Mapping', () => {\n    test('should map priority to BullMQ priority numbers', () => {\n      const priorityMap: Record<NotificationPriority, number> = {\n        urgent: 1,\n        high: 2,\n        normal: 3,\n        low: 4,\n      };\n\n      expect(priorityMap.urgent).toBe(1); // Highest priority\n      expect(priorityMap.high).toBe(2);\n      expect(priorityMap.normal).toBe(3);\n      expect(priorityMap.low).toBe(4); // Lowest priority\n    });\n\n    test('should process urgent jobs first', () => {\n      const urgentJob = { priority: 'urgent' as const, value: 1 };\n      const normalJob = { priority: 'normal' as const, value: 3 };\n      const lowJob = { priority: 'low' as const, value: 4 };\n\n      expect(urgentJob.value).toBeLessThan(normalJob.value);\n      expect(normalJob.value).toBeLessThan(lowJob.value);\n    });\n  });\n\n  describe('Retry Logic', () => {\n    test('should configure exponential backoff', () => {\n      const backoffConfig = {\n        type: 'exponential' as const,\n        delay: 5000, // 5 seconds\n      };\n\n      expect(backoffConfig.type).toBe('exponential');\n      expect(backoffConfig.delay).toBe(5000);\n    });\n\n    test('should calculate retry delays', () => {\n      const baseDelay = 5000;\n      const attempt1 = baseDelay * Math.pow(2, 0); // 5000ms = 5s\n      const attempt2 = baseDelay * Math.pow(2, 1); // 10000ms = 10s\n      const attempt3 = baseDelay * Math.pow(2, 2); // 20000ms = 20s\n\n      expect(attempt1).toBe(5000);\n      expect(attempt2).toBe(10000);\n      expect(attempt3).toBe(20000);\n    });\n\n    test('should respect max retry attempts', () => {\n      const maxAttempts = 3;\n      let currentAttempt = 0;\n\n      for (let i = 0; i < 5; i++) {\n        if (currentAttempt < maxAttempts) {\n          currentAttempt++;\n        }\n      }\n\n      expect(currentAttempt).toBe(maxAttempts);\n    });\n  });\n\n  describe('Job Lifecycle', () => {\n    test('should track job states', () => {\n      const states = ['waiting', 'active', 'completed', 'failed', 'delayed'];\n\n      expect(states).toContain('waiting');\n      expect(states).toContain('active');\n      expect(states).toContain('completed');\n      expect(states).toContain('failed');\n    });\n\n    test('should increment attempt counter', () => {\n      let attempts = 0;\n\n      // Simulate 3 attempts\n      attempts++;\n      expect(attempts).toBe(1);\n\n      attempts++;\n      expect(attempts).toBe(2);\n\n      attempts++;\n      expect(attempts).toBe(3);\n    });\n\n    test('should calculate next retry time', () => {\n      const now = new Date();\n      const retryDelay = 5000; // 5 seconds\n      const nextRetry = new Date(now.getTime() + retryDelay);\n\n      expect(nextRetry.getTime()).toBeGreaterThan(now.getTime());\n      expect(nextRetry.getTime() - now.getTime()).toBe(retryDelay);\n    });\n  });\n\n  describe('Queue Statistics', () => {\n    test('should track queue metrics', () => {\n      const stats = {\n        waiting: 5,\n        active: 2,\n        completed: 100,\n        failed: 3,\n        delayed: 1,\n        total: 111,\n        isRunning: true,\n      };\n\n      expect(stats.waiting).toBe(5);\n      expect(stats.active).toBe(2);\n      expect(stats.completed).toBe(100);\n      expect(stats.failed).toBe(3);\n      expect(stats.total).toBe(111);\n      expect(stats.isRunning).toBe(true);\n    });\n\n    test('should calculate total jobs', () => {\n      const waiting = 5;\n      const active = 2;\n      const completed = 100;\n      const failed = 3;\n      const delayed = 1;\n\n      const total = waiting + active + completed + failed + delayed;\n      expect(total).toBe(111);\n    });\n  });\n\n  describe('Job Cleanup', () => {\n    test('should configure job retention', () => {\n      const retentionConfig = {\n        removeOnComplete: 100, // Keep last 100 completed\n        removeOnFail: 1000, // Keep last 1000 failed\n      };\n\n      expect(retentionConfig.removeOnComplete).toBe(100);\n      expect(retentionConfig.removeOnFail).toBe(1000);\n    });\n\n    test('should calculate cleanup grace period', () => {\n      const oneDayInMs = 24 * 3600 * 1000;\n      const oneWeekInMs = 7 * oneDayInMs;\n\n      expect(oneDayInMs).toBe(86400000);\n      expect(oneWeekInMs).toBe(604800000);\n    });\n\n    test('should support cleanup limits', () => {\n      const cleanupLimit = 1000; // Clean up to 1000 jobs per operation\n\n      expect(cleanupLimit).toBe(1000);\n      expect(cleanupLimit).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Worker Registration', () => {\n    test('should register handlers for notification types', () => {\n      const handlers = new Map<NotificationType, (job: NotificationJob) => Promise<void>>();\n\n      // Register handlers\n      handlers.set('email', async (job) => {\n        console.log('Processing email:', job.notificationId);\n      });\n      handlers.set('push', async (job) => {\n        console.log('Processing push:', job.notificationId);\n      });\n      handlers.set('telegram', async (job) => {\n        console.log('Processing telegram:', job.notificationId);\n      });\n      handlers.set('in_app', async (job) => {\n        console.log('Processing in-app:', job.notificationId);\n      });\n\n      expect(handlers.size).toBe(4);\n      expect(handlers.has('email')).toBe(true);\n      expect(handlers.has('push')).toBe(true);\n      expect(handlers.has('telegram')).toBe(true);\n      expect(handlers.has('in_app')).toBe(true);\n    });\n\n    test('should throw error for unregistered handler', () => {\n      const handlers = new Map<NotificationType, (job: NotificationJob) => Promise<void>>();\n      const type: NotificationType = 'email';\n\n      const handler = handlers.get(type);\n      expect(handler).toBeUndefined();\n    });\n  });\n\n  describe('Event Handling', () => {\n    test('should define worker events', () => {\n      const events = ['completed', 'failed', 'error'];\n\n      expect(events).toContain('completed');\n      expect(events).toContain('failed');\n      expect(events).toContain('error');\n    });\n\n    test('should define queue events', () => {\n      const queueEvents = ['stalled'];\n\n      expect(queueEvents).toContain('stalled');\n    });\n\n    test('should log event data', () => {\n      const eventData = {\n        jobId: 'job_123',\n        notificationId: 'notif_456',\n        error: 'Connection timeout',\n        attemptsMade: 2,\n      };\n\n      expect(eventData.jobId).toBe('job_123');\n      expect(eventData.notificationId).toBe('notif_456');\n      expect(eventData.attemptsMade).toBe(2);\n    });\n  });\n\n  describe('Queue Control', () => {\n    test('should support pause operation', () => {\n      let isPaused = false;\n\n      // Simulate pause\n      isPaused = true;\n      expect(isPaused).toBe(true);\n    });\n\n    test('should support resume operation', () => {\n      let isPaused = true;\n\n      // Simulate resume\n      isPaused = false;\n      expect(isPaused).toBe(false);\n    });\n\n    test('should support graceful shutdown', async () => {\n      const shutdownSteps = [\n        'Close worker',\n        'Close queue events',\n        'Close queue',\n        'Disconnect Redis',\n      ];\n\n      expect(shutdownSteps).toHaveLength(4);\n      expect(shutdownSteps[0]).toBe('Close worker');\n      expect(shutdownSteps[3]).toBe('Disconnect Redis');\n    });\n  });\n\n  describe('Job ID Generation', () => {\n    test('should generate unique job IDs', () => {\n      const generateId = () => `job_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n\n      const id1 = generateId();\n      const id2 = generateId();\n\n      expect(id1).toContain('job_');\n      expect(id2).toContain('job_');\n      // IDs should be different (with very high probability)\n      expect(id1).not.toBe(id2);\n    });\n\n    test('should use timestamp in job ID', () => {\n      const timestamp = Date.now();\n      const jobId = `job_${timestamp}_abc123`;\n\n      expect(jobId).toContain(String(timestamp));\n      expect(jobId).toMatch(/^job_\\d+_[a-z0-9]+$/);\n    });\n  });\n\n  describe('Concurrency Control', () => {\n    test('should limit concurrent workers', () => {\n      const maxConcurrent = 10;\n      let activeWorkers = 0;\n\n      // Simulate adding workers\n      for (let i = 0; i < 15; i++) {\n        if (activeWorkers < maxConcurrent) {\n          activeWorkers++;\n        }\n      }\n\n      expect(activeWorkers).toBe(maxConcurrent);\n    });\n\n    test('should process jobs in parallel', () => {\n      const maxConcurrent = 10;\n      const jobs = Array.from({ length: 25 }, (_, i) => ({ id: `job_${i}` }));\n\n      // First batch\n      const batch1 = jobs.slice(0, maxConcurrent);\n      expect(batch1).toHaveLength(maxConcurrent);\n\n      // Second batch\n      const batch2 = jobs.slice(maxConcurrent, maxConcurrent * 2);\n      expect(batch2).toHaveLength(maxConcurrent);\n\n      // Remaining\n      const batch3 = jobs.slice(maxConcurrent * 2);\n      expect(batch3).toHaveLength(5);\n    });\n  });\n\n  describe('Failed Job Management', () => {\n    test('should retrieve failed jobs', () => {\n      const failedJobs = [\n        { id: 'job_1', error: 'Network timeout' },\n        { id: 'job_2', error: 'Invalid credentials' },\n        { id: 'job_3', error: 'Rate limit exceeded' },\n      ];\n\n      expect(failedJobs).toHaveLength(3);\n      expect(failedJobs[0].error).toBe('Network timeout');\n    });\n\n    test('should support pagination for failed jobs', () => {\n      const start = 0;\n      const end = 10;\n      const pageSize = end - start;\n\n      expect(pageSize).toBe(10);\n    });\n\n    test('should retry failed job', () => {\n      const job = {\n        id: 'job_123',\n        attempts: 2,\n        maxAttempts: 3,\n        status: 'failed',\n      };\n\n      // Can retry if attempts < maxAttempts\n      const canRetry = job.attempts < job.maxAttempts;\n      expect(canRetry).toBe(true);\n\n      // Increment attempts\n      job.attempts++;\n      expect(job.attempts).toBe(3);\n\n      // Cannot retry anymore\n      const canRetryNow = job.attempts < job.maxAttempts;\n      expect(canRetryNow).toBe(false);\n    });\n  });\n\n  describe('Redis Connection', () => {\n    test('should validate Redis connection parameters', () => {\n      const connection = {\n        host: 'localhost',\n        port: 6379,\n        password: undefined,\n        db: 0,\n        maxRetriesPerRequest: 3,\n      };\n\n      expect(connection.host).toBeTruthy();\n      expect(connection.port).toBeGreaterThan(0);\n      expect(connection.db).toBeGreaterThanOrEqual(0);\n      expect(connection.maxRetriesPerRequest).toBeGreaterThan(0);\n    });\n\n    test('should test Redis connectivity', async () => {\n      // Simulate ping command\n      const pingResponse = 'PONG';\n      expect(pingResponse).toBe('PONG');\n    });\n  });\n\n  describe('Integration with Notification Service', () => {\n    test('should initialize queue workers', () => {\n      const types: NotificationType[] = ['email', 'push', 'telegram', 'in_app'];\n\n      // Each type should have a worker\n      types.forEach((type) => {\n        expect(['email', 'push', 'telegram', 'in_app']).toContain(type);\n      });\n\n      expect(types).toHaveLength(4);\n    });\n\n    test('should support graceful shutdown on app termination', () => {\n      const shutdownSignals = ['SIGTERM', 'SIGINT'];\n\n      expect(shutdownSignals).toContain('SIGTERM');\n      expect(shutdownSignals).toContain('SIGINT');\n    });\n  });\n\n  describe('Error Recovery', () => {\n    test('should handle initialization failures', () => {\n      const error = new Error('Redis connection refused');\n\n      expect(error.message).toContain('Redis connection refused');\n      expect(error instanceof Error).toBe(true);\n    });\n\n    test('should recover from temporary failures', () => {\n      const maxRetries = 3;\n      let attempts = 0;\n      let success = false;\n\n      while (attempts < maxRetries && !success) {\n        attempts++;\n        // Simulate success on 3rd attempt\n        if (attempts === 3) {\n          success = true;\n        }\n      }\n\n      expect(success).toBe(true);\n      expect(attempts).toBe(3);\n    });\n  });\n\n  describe('Performance Optimization', () => {\n    test('should remove old completed jobs automatically', () => {\n      const keepLastN = 100;\n      const totalCompleted = 500;\n      const toRemove = totalCompleted - keepLastN;\n\n      expect(toRemove).toBe(400);\n      expect(keepLastN).toBe(100);\n    });\n\n    test('should remove old failed jobs automatically', () => {\n      const keepLastN = 1000;\n      const totalFailed = 2000;\n      const toRemove = totalFailed - keepLastN;\n\n      expect(toRemove).toBe(1000);\n      expect(keepLastN).toBe(1000);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/__tests__/push-provider.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'provider' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":306,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":306,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Push Provider Tests\n * Complete test coverage for Firebase Cloud Messaging implementation\n */\n\nimport { describe, test, expect, beforeEach } from 'bun:test';\nimport { PushProvider } from '../providers/push-provider';\n\n// Mock service account for testing\nconst mockServiceAccount = {\n  type: 'service_account',\n  project_id: 'test-project',\n  private_key_id: 'test-key-id',\n  private_key: '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC\\n-----END PRIVATE KEY-----\\n',\n  client_email: 'test@test-project.iam.gserviceaccount.com',\n  client_id: '123456789',\n  auth_uri: 'https://accounts.google.com/o/oauth2/auth',\n  token_uri: 'https://oauth2.googleapis.com/token',\n  auth_provider_x509_cert_url: 'https://www.googleapis.com/oauth2/v1/certs',\n  client_x509_cert_url: 'https://www.googleapis.com/robot/v1/metadata/x509/test.iam.gserviceaccount.com',\n};\n\ndescribe('PushProvider', () => {\n  describe('Initialization', () => {\n    test('should initialize with valid service account object', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n      });\n\n      expect(provider).toBeDefined();\n      expect(provider.isEnabled()).toBe(true);\n    });\n\n    test('should initialize with service account JSON string', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: JSON.stringify(mockServiceAccount),\n        },\n      });\n\n      expect(provider).toBeDefined();\n      expect(provider.isEnabled()).toBe(true);\n    });\n\n    test('should handle disabled provider', () => {\n      const provider = new PushProvider({\n        enabled: false,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n      });\n\n      expect(provider.isEnabled()).toBe(false);\n    });\n\n    test('should return provider info', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n      });\n\n      const info = provider.getInfo();\n      expect(info.type).toBe('push');\n      expect(info.providerName).toBe('Firebase');\n      expect(info.enabled).toBe(true);\n    });\n  });\n\n  describe('Configuration Validation', () => {\n    test('should detect missing service account', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: '',\n        },\n      });\n\n      // Provider is enabled but not configured, so it should be disabled\n      expect(provider.isEnabled()).toBe(false);\n    });\n\n    test('should validate service account structure', () => {\n      const invalidServiceAccount = {\n        type: 'service_account',\n        // Missing required fields\n      };\n\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: invalidServiceAccount as any,\n        },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should handle JSON parse errors gracefully', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: 'invalid-json',\n        },\n      });\n\n      expect(provider).toBeDefined();\n    });\n  });\n\n  describe('Recipient Validation', () => {\n    let provider: PushProvider;\n\n    beforeEach(() => {\n      provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n      });\n    });\n\n    test('should validate valid FCM tokens', () => {\n      // FCM tokens are alphanumeric with underscores and hyphens, >50 chars\n      const validToken =\n        'fGc1Y2xZ8N0APA91bF7K_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-';\n      expect(provider.validateRecipient(validToken)).toBe(true);\n    });\n\n    test('should reject short tokens', () => {\n      expect(provider.validateRecipient('short-token')).toBe(false);\n    });\n\n    test('should reject tokens with invalid characters', () => {\n      const invalidToken =\n        'invalid@token#with$special%chars&1234567890123456789012345678901234567890';\n      expect(provider.validateRecipient(invalidToken)).toBe(false);\n    });\n\n    test('should reject empty tokens', () => {\n      expect(provider.validateRecipient('')).toBe(false);\n    });\n  });\n\n  describe('Message Sending', () => {\n    let provider: PushProvider;\n\n    beforeEach(() => {\n      provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n        options: {\n          dryRun: true, // Use dry run for tests\n          priority: 'high',\n          timeToLive: 86400,\n        },\n      });\n    });\n\n    test('should reject invalid recipient', async () => {\n      const result = await provider.send({\n        notificationId: 'test-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        recipient: 'invalid-token',\n        subject: 'Test',\n        content: 'Test message',\n        priority: 'normal',\n      });\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('INVALID_RECIPIENT');\n      expect(result.errorMessage).toContain('Invalid FCM device token');\n    });\n\n    test('should format notification with title and body', () => {\n      const title = 'Important Alert';\n      const body = 'This is the notification body';\n\n      expect(title).toBe('Important Alert');\n      expect(body).toBe('This is the notification body');\n    });\n\n    test('should strip HTML tags from content', () => {\n      const htmlContent = '<h1>Title</h1><p>This is <strong>important</strong></p>';\n      const stripped = htmlContent.replace(/<[^>]*>/g, '').trim();\n\n      expect(stripped).toBe('TitleThis is important');\n      expect(stripped).not.toContain('<');\n      expect(stripped).not.toContain('>');\n    });\n  });\n\n  describe('Message Configuration', () => {\n    test('should support high priority', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n        options: {\n          priority: 'high',\n        },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should support normal priority', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n        options: {\n          priority: 'normal',\n        },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should configure time to live', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n        options: {\n          timeToLive: 3600, // 1 hour\n        },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should support dry run mode', () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n        options: {\n          dryRun: true,\n        },\n      });\n\n      expect(provider).toBeDefined();\n    });\n  });\n\n  describe('Platform-Specific Configuration', () => {\n    test('should configure Android-specific options', () => {\n      const androidConfig = {\n        priority: 'high' as const,\n        ttl: 86400 * 1000, // 24 hours in milliseconds\n      };\n\n      expect(androidConfig.priority).toBe('high');\n      expect(androidConfig.ttl).toBe(86400000);\n    });\n\n    test('should configure iOS APNS options', () => {\n      const apnsConfig = {\n        headers: {\n          'apns-priority': '10',\n          'apns-expiration': String(Math.floor(Date.now() / 1000) + 86400),\n        },\n        payload: {\n          aps: {\n            alert: {\n              title: 'Test',\n              body: 'Test body',\n            },\n            sound: 'default',\n            badge: 1,\n          },\n        },\n      };\n\n      expect(apnsConfig.headers['apns-priority']).toBe('10');\n      expect(apnsConfig.payload.aps.sound).toBe('default');\n      expect(apnsConfig.payload.aps.badge).toBe(1);\n    });\n\n    test('should support custom data payload', () => {\n      const dataPayload = {\n        notificationId: 'notif-123',\n        action: 'open_trade',\n        tradeId: 'trade-456',\n      };\n\n      expect(dataPayload.notificationId).toBe('notif-123');\n      expect(dataPayload.action).toBe('open_trade');\n    });\n  });\n\n  describe('Error Handling', () => {\n    let provider: PushProvider;\n\n    beforeEach(() => {\n      provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n      });\n    });\n\n    test('should handle unconfigured provider', async () => {\n      const unconfiguredProvider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: '',\n        },\n      });\n\n      // Use valid token format so it passes validation and reaches provider check\n      const validToken =\n        'fGc1Y2xZ8N0APA91bF7K_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-';\n\n      const result = await unconfiguredProvider.send({\n        notificationId: 'test-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        recipient: validToken,\n        content: 'Test',\n        priority: 'normal',\n      });\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('PROVIDER_NOT_CONFIGURED');\n    });\n\n    test('should identify token not registered errors', () => {\n      const errorMessage = 'registration-token-not-registered';\n      const expectedCode = 'TOKEN_NOT_REGISTERED';\n\n      expect(errorMessage.includes('registration-token-not-registered')).toBe(true);\n      expect(expectedCode).toBe('TOKEN_NOT_REGISTERED');\n    });\n\n    test('should identify invalid token errors', () => {\n      const errorMessage = 'invalid-registration-token';\n      const expectedCode = 'INVALID_TOKEN';\n\n      expect(errorMessage.includes('invalid-registration-token')).toBe(true);\n      expect(expectedCode).toBe('INVALID_TOKEN');\n    });\n\n    test('should identify rate limit errors', () => {\n      const errorMessage = 'message-rate-exceeded';\n      const expectedCode = 'RATE_LIMIT_EXCEEDED';\n\n      expect(errorMessage.includes('message-rate-exceeded')).toBe(true);\n      expect(expectedCode).toBe('RATE_LIMIT_EXCEEDED');\n    });\n  });\n\n  describe('Multicast Notifications', () => {\n    test('should support sending to multiple tokens', () => {\n      const tokens = [\n        'token1_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n        'token2_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n        'token3_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n      ];\n\n      expect(tokens).toHaveLength(3);\n      tokens.forEach((token) => {\n        expect(token.length).toBeGreaterThan(50);\n      });\n    });\n\n    test('should format multicast message correctly', () => {\n      const notification = {\n        title: 'Broadcast Alert',\n        body: 'This is a multicast notification',\n      };\n\n      const data = {\n        type: 'broadcast',\n        timestamp: String(Date.now()),\n      };\n\n      expect(notification.title).toBe('Broadcast Alert');\n      expect(data.type).toBe('broadcast');\n    });\n  });\n\n  describe('Connection Testing', () => {\n    test('should handle connection test when provider not initialized', async () => {\n      const provider = new PushProvider({\n        enabled: false,\n        credentials: {\n          serviceAccount: '',\n        },\n      });\n\n      const isConnected = await provider.testConnection();\n      expect(typeof isConnected).toBe('boolean');\n      expect(isConnected).toBe(false);\n    });\n  });\n\n  describe('Cleanup', () => {\n    test('should cleanup resources', async () => {\n      const provider = new PushProvider({\n        enabled: true,\n        credentials: {\n          serviceAccount: mockServiceAccount,\n        },\n      });\n\n      await provider.cleanup();\n      // Should not throw\n      expect(true).toBe(true);\n    });\n\n    test('should handle cleanup when not initialized', async () => {\n      const provider = new PushProvider({\n        enabled: false,\n        credentials: {\n          serviceAccount: '',\n        },\n      });\n\n      await provider.cleanup();\n      expect(true).toBe(true);\n    });\n  });\n\n  describe('Environment Configuration', () => {\n    test('should load from environment variables', () => {\n      process.env.PUSH_ENABLED = 'true';\n      process.env.FIREBASE_SERVICE_ACCOUNT = JSON.stringify(mockServiceAccount);\n      process.env.FIREBASE_DATABASE_URL = 'https://test.firebaseio.com';\n      process.env.PUSH_DRY_RUN = 'true';\n      process.env.PUSH_PRIORITY = 'high';\n      process.env.PUSH_TTL = '3600';\n\n      expect(process.env.PUSH_ENABLED).toBe('true');\n      expect(process.env.FIREBASE_SERVICE_ACCOUNT).toContain('test-project');\n      expect(process.env.PUSH_PRIORITY).toBe('high');\n      expect(process.env.PUSH_TTL).toBe('3600');\n    });\n\n    test('should parse TTL as integer', () => {\n      const ttl = parseInt(process.env.PUSH_TTL || '86400', 10);\n      expect(typeof ttl).toBe('number');\n      expect(ttl).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Content Processing', () => {\n    test('should strip HTML from notification body', () => {\n      const htmlContent = '<div><h2>Alert</h2><p>Your trade was <strong>executed</strong></p></div>';\n      const plainText = htmlContent.replace(/<[^>]*>/g, '').trim();\n\n      expect(plainText).toBe('AlertYour trade was executed');\n      expect(plainText).not.toContain('<div>');\n      expect(plainText).not.toContain('<strong>');\n    });\n\n    test('should handle empty content', () => {\n      const emptyContent = '';\n      const stripped = emptyContent.replace(/<[^>]*>/g, '').trim();\n\n      expect(stripped).toBe('');\n    });\n\n    test('should preserve plain text', () => {\n      const plainText = 'This is plain text without HTML';\n      const processed = plainText.replace(/<[^>]*>/g, '').trim();\n\n      expect(processed).toBe(plainText);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/__tests__/telegram-provider.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'provider' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":198,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":198,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Telegram Provider Tests\n * Complete test coverage for Telegram Bot API implementation\n */\n\nimport { describe, test, expect, beforeEach } from 'bun:test';\nimport { TelegramProvider } from '../providers/telegram-provider';\n\ndescribe('TelegramProvider', () => {\n  describe('Initialization', () => {\n    test('should initialize with valid config', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: '123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11',\n        },\n      });\n\n      expect(provider).toBeDefined();\n      expect(provider.isEnabled()).toBe(true);\n    });\n\n    test('should handle disabled provider', () => {\n      const provider = new TelegramProvider({\n        enabled: false,\n        credentials: {\n          botToken: 'test-token',\n        },\n      });\n\n      expect(provider.isEnabled()).toBe(false);\n    });\n\n    test('should return provider info', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: 'test-token',\n        },\n      });\n\n      const info = provider.getInfo();\n      expect(info.type).toBe('telegram');\n      expect(info.providerName).toBe('Telegram');\n      expect(info.enabled).toBe(true);\n    });\n  });\n\n  describe('Recipient Validation', () => {\n    let provider: TelegramProvider;\n\n    beforeEach(() => {\n      provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: 'test-token',\n        },\n      });\n    });\n\n    test('should validate numeric chat IDs', () => {\n      expect(provider.validateRecipient('123456789')).toBe(true);\n      expect(provider.validateRecipient('987654321')).toBe(true);\n    });\n\n    test('should validate negative chat IDs (groups)', () => {\n      expect(provider.validateRecipient('-123456789')).toBe(true);\n      expect(provider.validateRecipient('-1001234567890')).toBe(true);\n    });\n\n    test('should validate username format', () => {\n      expect(provider.validateRecipient('@username')).toBe(true);\n      expect(provider.validateRecipient('@test_user')).toBe(true);\n      expect(provider.validateRecipient('@User123')).toBe(true);\n    });\n\n    test('should reject invalid formats', () => {\n      expect(provider.validateRecipient('invalid')).toBe(false);\n      expect(provider.validateRecipient('@ab')).toBe(false); // Too short (min 5)\n      expect(provider.validateRecipient('@user-name')).toBe(false); // Hyphens not allowed\n      expect(provider.validateRecipient('12.34')).toBe(false); // Decimals not allowed\n      expect(provider.validateRecipient('')).toBe(false);\n    });\n  });\n\n  describe('Message Sending', () => {\n    let provider: TelegramProvider;\n\n    beforeEach(() => {\n      provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: '123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11',\n        },\n        options: {\n          parseMode: 'HTML',\n          disableNotification: false,\n        },\n      });\n    });\n\n    test('should reject invalid recipient', async () => {\n      const result = await provider.send({\n        notificationId: 'test-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        recipient: 'invalid',\n        subject: 'Test',\n        content: 'Test message',\n        priority: 'normal',\n      });\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('INVALID_RECIPIENT');\n      expect(result.errorMessage).toContain('Invalid Telegram chat ID');\n    });\n\n    test('should format message with subject', () => {\n      const subject = 'Important Notice';\n      const content = 'This is the message body';\n      const expected = `<b>${subject}</b>\\n\\n${content}`;\n\n      expect(expected).toContain('<b>Important Notice</b>');\n      expect(expected).toContain('This is the message body');\n    });\n\n    test('should handle message without subject', () => {\n      const content = 'Plain message';\n      // When no subject, content is used as-is\n      expect(content).toBe('Plain message');\n    });\n  });\n\n  describe('Parse Mode Configuration', () => {\n    test('should support HTML parse mode', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: { botToken: 'test' },\n        options: { parseMode: 'HTML' },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should support Markdown parse mode', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: { botToken: 'test' },\n        options: { parseMode: 'Markdown' },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should support MarkdownV2 parse mode', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: { botToken: 'test' },\n        options: { parseMode: 'MarkdownV2' },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should default to HTML when not specified', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: { botToken: 'test' },\n      });\n\n      // Default should be HTML\n      expect(provider).toBeDefined();\n    });\n  });\n\n  describe('Notification Settings', () => {\n    test('should support silent notifications', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: { botToken: 'test' },\n        options: { disableNotification: true },\n      });\n\n      expect(provider).toBeDefined();\n    });\n\n    test('should default to notifications enabled', () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: { botToken: 'test' },\n      });\n\n      expect(provider).toBeDefined();\n    });\n  });\n\n  describe('Error Handling', () => {\n    let provider: TelegramProvider;\n\n    beforeEach(() => {\n      provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: 'invalid-token',\n        },\n      });\n    });\n\n    test('should handle unconfigured provider', async () => {\n      const unconfiguredProvider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: '',\n        },\n      });\n\n      const result = await unconfiguredProvider.send({\n        notificationId: 'test-1',\n        userId: 'user-1',\n        tenantId: 'tenant-1',\n        recipient: '123456',\n        content: 'Test',\n        priority: 'normal',\n      });\n\n      expect(result.success).toBe(false);\n      expect(result.errorCode).toBe('PROVIDER_NOT_CONFIGURED');\n    });\n\n    test('should identify chat not found errors', () => {\n      const errorMessage = 'chat not found';\n      const expectedCode = 'CHAT_NOT_FOUND';\n\n      expect(errorMessage.includes('chat not found')).toBe(true);\n      expect(expectedCode).toBe('CHAT_NOT_FOUND');\n    });\n\n    test('should identify bot blocked errors', () => {\n      const errorMessage = 'bot was blocked by the user';\n      const expectedCode = 'BOT_BLOCKED';\n\n      expect(errorMessage.includes('bot was blocked')).toBe(true);\n      expect(expectedCode).toBe('BOT_BLOCKED');\n    });\n\n    test('should identify user deactivated errors', () => {\n      const errorMessage = 'user is deactivated';\n      const expectedCode = 'USER_DEACTIVATED';\n\n      expect(errorMessage.includes('user is deactivated')).toBe(true);\n      expect(expectedCode).toBe('USER_DEACTIVATED');\n    });\n  });\n\n  describe('Bot Information', () => {\n    let provider: TelegramProvider;\n\n    beforeEach(() => {\n      provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: 'test-token',\n        },\n      });\n    });\n\n    test('should handle getBotInfo when bot not initialized', async () => {\n      const info = await provider.getBotInfo();\n      // Should return null when bot not available\n      expect(info === null || typeof info === 'object').toBe(true);\n    });\n  });\n\n  describe('Cleanup', () => {\n    test('should cleanup resources', async () => {\n      const provider = new TelegramProvider({\n        enabled: true,\n        credentials: {\n          botToken: 'test-token',\n        },\n      });\n\n      await provider.cleanup();\n      // Should not throw\n      expect(true).toBe(true);\n    });\n\n    test('should handle cleanup without bot', async () => {\n      const provider = new TelegramProvider({\n        enabled: false,\n        credentials: {\n          botToken: '',\n        },\n      });\n\n      await provider.cleanup();\n      expect(true).toBe(true);\n    });\n  });\n\n  describe('Environment Configuration', () => {\n    test('should load from environment variables', () => {\n      process.env.TELEGRAM_BOT_TOKEN = 'env-token-123';\n      process.env.TELEGRAM_ENABLED = 'true';\n      process.env.TELEGRAM_PARSE_MODE = 'Markdown';\n      process.env.TELEGRAM_DISABLE_NOTIFICATION = 'true';\n\n      expect(process.env.TELEGRAM_BOT_TOKEN).toBe('env-token-123');\n      expect(process.env.TELEGRAM_ENABLED).toBe('true');\n      expect(process.env.TELEGRAM_PARSE_MODE).toBe('Markdown');\n      expect(process.env.TELEGRAM_DISABLE_NOTIFICATION).toBe('true');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/providers/base-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/providers/email-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/providers/in-app-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/providers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/providers/push-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/providers/telegram-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/routes/notification.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/schema/notifications.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/services/notification.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/types/notification.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/utils/notification-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/notifications/utils/template-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/routes/order-book.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/schema/order-book.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/footprint-chart.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'priceRange' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":135,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Footprint Chart Service\n * Nelogica-style order flow and volume analysis\n *\n * Features:\n * - Order flow visualization (footprint charts)\n * - Volume at price analysis\n * - Buy/sell pressure tracking\n * - Delta analysis (buy - sell volume)\n * - Point of Control (POC) identification\n * - Imbalance detection at price levels\n * - Volume profile generation\n * - Absorption detection\n */\n\nimport { db } from '@/db';\nimport { eq, and, gte, lte, sql } from 'drizzle-orm';\nimport { marketTrades } from '../../market-data/schema/market-data.schema';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type {\n  FootprintData,\n  FootprintPriceLevel,\n  VolumeProfileData,\n  VolumeProfileLevel,\n} from '../types/order-book.types';\n\nexport class FootprintChartService {\n  /**\n   * Generate footprint chart data from trades\n   * Aggregates trades into OHLC bars with volume at each price level\n   */\n  static async generateFootprintData(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date,\n    timeframe: string = '5m'\n  ): Promise<FootprintData[]> {\n    try {\n      // Convert timeframe to minutes\n      const timeframeMinutes = this.parseTimeframe(timeframe);\n\n      // Get trades for the period\n      const trades = await db\n        .select()\n        .from(marketTrades)\n        .where(\n          and(\n            eq(marketTrades.exchangeId, exchangeId),\n            eq(marketTrades.symbol, symbol),\n            gte(marketTrades.timestamp, startTime),\n            lte(marketTrades.timestamp, endTime)\n          )\n        )\n        .orderBy(marketTrades.timestamp);\n\n      if (trades.length === 0) {\n        throw new BadRequestError('No trade data found for the specified period');\n      }\n\n      // Group trades into timeframe buckets\n      const buckets = new Map<number, typeof trades>();\n\n      trades.forEach((trade) => {\n        const bucketTime = this.getBucketTime(trade.timestamp, timeframeMinutes);\n        if (!buckets.has(bucketTime)) {\n          buckets.set(bucketTime, []);\n        }\n        buckets.get(bucketTime)!.push(trade);\n      });\n\n      // Generate footprint for each bucket\n      const footprints: FootprintData[] = [];\n\n      for (const [bucketTime, bucketTrades] of buckets.entries()) {\n        const footprint = this.calculateFootprintForBucket(\n          exchangeId,\n          symbol,\n          timeframe,\n          new Date(bucketTime),\n          bucketTrades\n        );\n        footprints.push(footprint);\n      }\n\n      logger.info('Generated footprint chart data', {\n        exchangeId,\n        symbol,\n        timeframe,\n        bars: footprints.length,\n      });\n\n      return footprints;\n    } catch (error) {\n      logger.error('Failed to generate footprint data', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate volume profile for period\n   */\n  static async generateVolumeProfile(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date,\n    priceStepPercent: number = 0.1 // Price level grouping (0.1% = 10 bps)\n  ): Promise<VolumeProfileData> {\n    try {\n      // Get trades for the period\n      const trades = await db\n        .select()\n        .from(marketTrades)\n        .where(\n          and(\n            eq(marketTrades.exchangeId, exchangeId),\n            eq(marketTrades.symbol, symbol),\n            gte(marketTrades.timestamp, startTime),\n            lte(marketTrades.timestamp, endTime)\n          )\n        );\n\n      if (trades.length === 0) {\n        throw new BadRequestError('No trade data found for the specified period');\n      }\n\n      // Find price range\n      const prices = trades.map((t) => parseFloat(t.price));\n      const minPrice = Math.min(...prices);\n      const maxPrice = Math.max(...prices);\n      const priceRange = maxPrice - minPrice;\n\n      // Create price levels\n      const priceStep = (priceStepPercent / 100) * minPrice;\n      const volumeByPrice = new Map<number, VolumeProfileLevel>();\n\n      // Aggregate volume by price level\n      trades.forEach((trade) => {\n        const price = parseFloat(trade.price);\n        const amount = parseFloat(trade.amount);\n        const side = trade.side;\n\n        // Round price to nearest step\n        const priceLevel = Math.round(price / priceStep) * priceStep;\n\n        let level = volumeByPrice.get(priceLevel);\n        if (!level) {\n          level = {\n            price: priceLevel,\n            volume: 0,\n            volumePercent: 0,\n            buyVolume: 0,\n            sellVolume: 0,\n            delta: 0,\n          };\n          volumeByPrice.set(priceLevel, level);\n        }\n\n        level.volume += amount;\n        if (side === 'buy') {\n          level.buyVolume += amount;\n        } else {\n          level.sellVolume += amount;\n        }\n        level.delta = level.buyVolume - level.sellVolume;\n      });\n\n      // Calculate percentages\n      const totalVolume = Array.from(volumeByPrice.values()).reduce(\n        (sum, level) => sum + level.volume,\n        0\n      );\n\n      volumeByPrice.forEach((level) => {\n        level.volumePercent = (level.volume / totalVolume) * 100;\n      });\n\n      // Sort by volume (descending) to find POC\n      const sortedLevels = Array.from(volumeByPrice.values()).sort(\n        (a, b) => b.volume - a.volume\n      );\n\n      // Point of Control (highest volume price)\n      const poc = sortedLevels[0].price;\n\n      // Calculate Value Area (70% of volume)\n      const valueAreaVolume = totalVolume * 0.7;\n      let cumulativeVolume = 0;\n      let vah = poc; // Value Area High\n      let val = poc; // Value Area Low\n\n      // Expand from POC until we have 70% of volume\n      const sortedByPrice = Array.from(volumeByPrice.values()).sort((a, b) => a.price - b.price);\n      const pocIndex = sortedByPrice.findIndex((l) => l.price === poc);\n\n      let upperIndex = pocIndex;\n      let lowerIndex = pocIndex;\n\n      while (cumulativeVolume < valueAreaVolume && (upperIndex < sortedByPrice.length || lowerIndex >= 0)) {\n        const upperVolume = upperIndex < sortedByPrice.length ? sortedByPrice[upperIndex].volume : 0;\n        const lowerVolume = lowerIndex >= 0 ? sortedByPrice[lowerIndex].volume : 0;\n\n        if (upperVolume > lowerVolume) {\n          cumulativeVolume += upperVolume;\n          vah = sortedByPrice[upperIndex].price;\n          upperIndex++;\n        } else {\n          cumulativeVolume += lowerVolume;\n          val = sortedByPrice[lowerIndex].price;\n          lowerIndex--;\n        }\n      }\n\n      const valueAreaPercent = ((vah - val) / val) * 100;\n\n      const profile: VolumeProfileData = {\n        exchangeId,\n        symbol,\n        startTime,\n        endTime,\n        priceLevels: sortedByPrice,\n        poc,\n        vah,\n        val,\n        totalVolume,\n        valueAreaVolume,\n        valueAreaPercent,\n      };\n\n      logger.info('Generated volume profile', {\n        exchangeId,\n        symbol,\n        levels: profile.priceLevels.length,\n        poc: poc.toFixed(2),\n        vah: vah.toFixed(2),\n        val: val.toFixed(2),\n      });\n\n      return profile;\n    } catch (error) {\n      logger.error('Failed to generate volume profile', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Detect absorption (large volume without price movement)\n   */\n  static detectAbsorption(footprint: FootprintData): {\n    hasAbsorption: boolean;\n    side: 'bid' | 'ask' | null;\n    strength: number;\n    priceLevel: number | null;\n  } {\n    // Look for high volume at a price level with minimal price movement\n    const priceMovement = ((footprint.close - footprint.open) / footprint.open) * 100;\n\n    // High volume but low price movement = absorption\n    if (Math.abs(priceMovement) < 0.1 && footprint.totalVolume > 0) {\n      // Find the price level with highest volume\n      const sortedLevels = [...footprint.priceVolumes].sort(\n        (a, b) => b.totalVolume - a.totalVolume\n      );\n\n      if (sortedLevels.length === 0) {\n        return { hasAbsorption: false, side: null, strength: 0, priceLevel: null };\n      }\n\n      const topLevel = sortedLevels[0];\n\n      // Determine if it's bid or ask absorption\n      const side: 'bid' | 'ask' = topLevel.buyVolume > topLevel.sellVolume ? 'bid' : 'ask';\n\n      // Strength based on volume concentration\n      const volumeConcentration = (topLevel.totalVolume / footprint.totalVolume) * 100;\n      const strength = Math.min(100, volumeConcentration * 2);\n\n      return {\n        hasAbsorption: strength > 30,\n        side,\n        strength,\n        priceLevel: topLevel.price,\n      };\n    }\n\n    return { hasAbsorption: false, side: null, strength: 0, priceLevel: null };\n  }\n\n  /**\n   * Calculate footprint for a single time bucket\n   */\n  private static calculateFootprintForBucket(\n    exchangeId: string,\n    symbol: string,\n    timeframe: string,\n    timestamp: Date,\n    trades: any[]\n  ): FootprintData {\n    if (trades.length === 0) {\n      throw new Error('No trades in bucket');\n    }\n\n    // Calculate OHLC\n    const prices = trades.map((t) => parseFloat(t.price));\n    const open = parseFloat(trades[0].price);\n    const high = Math.max(...prices);\n    const low = Math.min(...prices);\n    const close = parseFloat(trades[trades.length - 1].price);\n\n    // Aggregate volume by price level\n    const priceVolumeMap = new Map<number, FootprintPriceLevel>();\n\n    trades.forEach((trade) => {\n      const price = parseFloat(trade.price);\n      const amount = parseFloat(trade.amount);\n      const side = trade.side;\n\n      let level = priceVolumeMap.get(price);\n      if (!level) {\n        level = {\n          price,\n          buyVolume: 0,\n          sellVolume: 0,\n          totalVolume: 0,\n          delta: 0,\n          imbalance: 0,\n        };\n        priceVolumeMap.set(price, level);\n      }\n\n      level.totalVolume += amount;\n      if (side === 'buy') {\n        level.buyVolume += amount;\n      } else {\n        level.sellVolume += amount;\n      }\n      level.delta = level.buyVolume - level.sellVolume;\n      level.imbalance =\n        level.totalVolume > 0\n          ? (level.buyVolume - level.sellVolume) / level.totalVolume\n          : 0;\n    });\n\n    // Convert map to sorted array\n    const priceVolumes = Array.from(priceVolumeMap.values()).sort((a, b) => b.price - a.price);\n\n    // Calculate aggregated metrics\n    const totalVolume = priceVolumes.reduce((sum, level) => sum + level.totalVolume, 0);\n    const buyVolume = priceVolumes.reduce((sum, level) => sum + level.buyVolume, 0);\n    const sellVolume = priceVolumes.reduce((sum, level) => sum + level.sellVolume, 0);\n    const delta = buyVolume - sellVolume;\n\n    // Find imbalance at high and low\n    const highLevel = priceVolumes.find((l) => l.price === high);\n    const lowLevel = priceVolumes.find((l) => l.price === low);\n    const highImbalance = highLevel?.imbalance || 0;\n    const lowImbalance = lowLevel?.imbalance || 0;\n\n    // Find Point of Control (POC) - price with highest volume\n    const poc = priceVolumes.reduce((max, level) =>\n      level.totalVolume > max.totalVolume ? level : max\n    ).price;\n\n    return {\n      exchangeId,\n      symbol,\n      timeframe,\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      priceVolumes,\n      totalVolume,\n      buyVolume,\n      sellVolume,\n      delta,\n      highImbalance,\n      lowImbalance,\n      poc,\n    };\n  }\n\n  /**\n   * Get bucket time for timeframe\n   */\n  private static getBucketTime(timestamp: Date, timeframeMinutes: number): number {\n    const time = timestamp.getTime();\n    const bucketMs = timeframeMinutes * 60 * 1000;\n    return Math.floor(time / bucketMs) * bucketMs;\n  }\n\n  /**\n   * Parse timeframe string to minutes\n   */\n  private static parseTimeframe(timeframe: string): number {\n    const match = timeframe.match(/^(\\d+)([mhd])$/);\n    if (!match) {\n      throw new BadRequestError('Invalid timeframe format. Use: 1m, 5m, 15m, 1h, 4h, 1d');\n    }\n\n    const value = parseInt(match[1]);\n    const unit = match[2];\n\n    switch (unit) {\n      case 'm':\n        return value;\n      case 'h':\n        return value * 60;\n      case 'd':\n        return value * 60 * 24;\n      default:\n        throw new BadRequestError('Invalid timeframe unit');\n    }\n  }\n\n  /**\n   * Detect buying/selling climax\n   */\n  static detectClimax(footprints: FootprintData[]): {\n    hasBuyingClimax: boolean;\n    hasSellingClimax: boolean;\n    climaxBar: FootprintData | null;\n    strength: number;\n  } {\n    if (footprints.length < 3) {\n      return {\n        hasBuyingClimax: false,\n        hasSellingClimax: false,\n        climaxBar: null,\n        strength: 0,\n      };\n    }\n\n    // Look for bars with exceptionally high volume and strong delta\n    const avgVolume =\n      footprints.reduce((sum, fp) => sum + fp.totalVolume, 0) / footprints.length;\n\n    let climaxBar: FootprintData | null = null;\n    let maxStrength = 0;\n\n    footprints.forEach((fp) => {\n      const volumeRatio = fp.totalVolume / avgVolume;\n      const deltaRatio = Math.abs(fp.delta) / fp.totalVolume;\n\n      // Climax criteria: 2x average volume + strong delta\n      if (volumeRatio > 2 && deltaRatio > 0.6) {\n        const strength = volumeRatio * deltaRatio * 50;\n        if (strength > maxStrength) {\n          maxStrength = strength;\n          climaxBar = fp;\n        }\n      }\n    });\n\n    if (!climaxBar) {\n      return {\n        hasBuyingClimax: false,\n        hasSellingClimax: false,\n        climaxBar: null,\n        strength: 0,\n      };\n    }\n\n    // Type assertion: we know climaxBar is not null at this point\n    const bar: FootprintData = climaxBar;\n\n    return {\n      hasBuyingClimax: bar.delta > 0,\n      hasSellingClimax: bar.delta < 0,\n      climaxBar: bar,\n      strength: maxStrength,\n    };\n  }\n\n  /**\n   * Analyze order flow divergence\n   */\n  static analyzeOrderFlowDivergence(footprints: FootprintData[]): {\n    hasDivergence: boolean;\n    type: 'bullish' | 'bearish' | null;\n    description: string;\n  } {\n    if (footprints.length < 5) {\n      return {\n        hasDivergence: false,\n        type: null,\n        description: 'Insufficient data',\n      };\n    }\n\n    // Compare price direction with delta direction\n    const recentBars = footprints.slice(-5);\n    const priceChange = recentBars[recentBars.length - 1].close - recentBars[0].open;\n    const cumulativeDelta = recentBars.reduce((sum, fp) => sum + fp.delta, 0);\n\n    // Bullish divergence: price down but delta positive (buying)\n    if (priceChange < 0 && cumulativeDelta > 0) {\n      return {\n        hasDivergence: true,\n        type: 'bullish',\n        description: 'Price declining but buying pressure increasing',\n      };\n    }\n\n    // Bearish divergence: price up but delta negative (selling)\n    if (priceChange > 0 && cumulativeDelta < 0) {\n      return {\n        hasDivergence: true,\n        type: 'bearish',\n        description: 'Price rising but selling pressure increasing',\n      };\n    }\n\n    return {\n      hasDivergence: false,\n      type: null,\n      description: 'No divergence detected',\n    };\n  }\n\n  /**\n   * Get footprint statistics\n   */\n  static calculateStatistics(footprints: FootprintData[]): {\n    totalBars: number;\n    avgVolume: number;\n    avgDelta: number;\n    buyingBars: number;\n    sellingBars: number;\n    neutralBars: number;\n    strongestBuyBar: FootprintData | null;\n    strongestSellBar: FootprintData | null;\n  } {\n    if (footprints.length === 0) {\n      return {\n        totalBars: 0,\n        avgVolume: 0,\n        avgDelta: 0,\n        buyingBars: 0,\n        sellingBars: 0,\n        neutralBars: 0,\n        strongestBuyBar: null,\n        strongestSellBar: null,\n      };\n    }\n\n    const totalVolume = footprints.reduce((sum, fp) => sum + fp.totalVolume, 0);\n    const totalDelta = footprints.reduce((sum, fp) => sum + fp.delta, 0);\n\n    let buyingBars = 0;\n    let sellingBars = 0;\n    let neutralBars = 0;\n    let strongestBuyBar: FootprintData | null = null;\n    let strongestSellBar: FootprintData | null = null;\n    let maxBuyDelta = 0;\n    let maxSellDelta = 0;\n\n    footprints.forEach((fp) => {\n      const deltaPercent = (fp.delta / fp.totalVolume) * 100;\n\n      if (deltaPercent > 20) {\n        buyingBars++;\n        if (fp.delta > maxBuyDelta) {\n          maxBuyDelta = fp.delta;\n          strongestBuyBar = fp;\n        }\n      } else if (deltaPercent < -20) {\n        sellingBars++;\n        if (fp.delta < maxSellDelta) {\n          maxSellDelta = fp.delta;\n          strongestSellBar = fp;\n        }\n      } else {\n        neutralBars++;\n      }\n    });\n\n    return {\n      totalBars: footprints.length,\n      avgVolume: totalVolume / footprints.length,\n      avgDelta: totalDelta / footprints.length,\n      buyingBars,\n      sellingBars,\n      neutralBars,\n      strongestBuyBar,\n      strongestSellBar,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/large-order-detection.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asks' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":426,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":426,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Large Order Detection Service\n * Detects and analyzes large orders, iceberg orders, whale activity, and spoofing\n *\n * Features:\n * - Iceberg order detection (hidden liquidity)\n * - Whale order identification\n * - Order spoofing detection\n * - Large order clustering\n * - Market manipulation detection\n * - Order renewal tracking\n * - Size-based anomaly detection\n *\n * Detection Methods:\n * - Statistical anomaly detection (>3 std dev)\n * - Pattern recognition (repeated orders)\n * - Time-series analysis (order renewal)\n * - Volume distribution analysis\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte, sql } from 'drizzle-orm';\nimport {\n  orderBookSnapshots,\n  largeOrdersDetected,\n  spoofingEvents,\n} from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type { OrderBookSnapshot, OrderBookLevel } from '../types/order-book.types';\n\n/**\n * Large Order Detection Result\n */\nexport interface LargeOrderDetection {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Order details\n  side: 'bid' | 'ask';\n  price: number;\n  size: number;\n  sizeUSD: number;\n\n  // Statistical analysis\n  zScore: number; // How many std deviations from mean\n  percentileRank: number; // 0-100\n\n  // Classification\n  orderType: 'whale' | 'institutional' | 'large_retail' | 'iceberg';\n  confidence: number; // 0-100\n\n  // Context\n  distanceFromMid: number; // Distance from mid price (%)\n  marketShare: number; // % of total order book liquidity\n}\n\n/**\n * Iceberg Order Detection\n */\nexport interface IcebergDetection {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Order details\n  side: 'bid' | 'ask';\n  price: number;\n  visibleSize: number;\n  estimatedTotalSize: number;\n  hiddenSize: number;\n\n  // Detection metrics\n  renewalCount: number; // How many times order was renewed\n  renewalFrequency: number; // Renewals per minute\n  consistency: number; // How consistent the renewals are (0-100)\n\n  // Confidence\n  confidence: number; // 0-100\n  detectionMethod: 'renewal_pattern' | 'size_anomaly' | 'execution_pattern';\n}\n\n/**\n * Spoofing Detection\n */\nexport interface SpoofingDetection {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n  startTime: Date;\n  endTime: Date;\n\n  // Spoofing details\n  side: 'bid' | 'ask';\n  price: number;\n  maxSize: number;\n  avgLifetime: number; // Average time order stays in book (seconds)\n\n  // Pattern analysis\n  placementCount: number; // How many times placed\n  cancellationCount: number; // How many times cancelled\n  executionRate: number; // % that got executed (low = likely spoofing)\n\n  // Classification\n  spoofingType: 'layering' | 'spoofing' | 'quote_stuffing';\n  severity: 'low' | 'medium' | 'high' | 'extreme';\n  confidence: number; // 0-100\n}\n\n/**\n * Order Cluster (multiple large orders at similar prices)\n */\nexport interface OrderCluster {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  side: 'bid' | 'ask';\n  priceRange: { min: number; max: number };\n  centerPrice: number;\n  totalSize: number;\n  orderCount: number;\n\n  // Analysis\n  clusterStrength: number; // 0-100\n  supportResistanceLevel: boolean;\n  intention: 'accumulation' | 'distribution' | 'defense' | 'unknown';\n}\n\n/**\n * Whale Activity Summary\n */\nexport interface WhaleActivitySummary {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n  timeRange: { start: Date; end: Date };\n\n  // Whale metrics\n  totalWhaleOrders: number;\n  totalWhaleVolume: number;\n  totalWhaleVolumeUSD: number;\n\n  // Distribution\n  bidWhaleOrders: number;\n  askWhaleOrders: number;\n  bidWhaleVolume: number;\n  askWhaleVolume: number;\n\n  // Sentiment\n  whaleSentiment: 'bullish' | 'bearish' | 'neutral';\n  confidenceScore: number;\n\n  // Largest orders\n  largestBid?: LargeOrderDetection;\n  largestAsk?: LargeOrderDetection;\n}\n\nexport class LargeOrderDetectionService {\n  /**\n   * Detect large orders in current order book\n   */\n  static async detectLargeOrders(\n    exchangeId: string,\n    symbol: string,\n    thresholdMultiplier: number = 3.0 // How many std deviations\n  ): Promise<LargeOrderDetection[]> {\n    try {\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n      if (!snapshot) {\n        throw new BadRequestError('No order book data available');\n      }\n\n      // Calculate statistics for order sizes\n      const allOrders = [...snapshot.bids, ...snapshot.asks];\n      const sizes = allOrders.map(order => order.price * order.amount);\n\n      const stats = this.calculateStatistics(sizes);\n      const threshold = stats.mean + thresholdMultiplier * stats.stdDev;\n\n      const detections: LargeOrderDetection[] = [];\n\n      // Check bids\n      snapshot.bids.forEach(bid => {\n        const sizeUSD = bid.price * bid.amount;\n\n        if (sizeUSD >= threshold) {\n          const detection = this.analyzeLargeOrder(\n            exchangeId,\n            symbol,\n            snapshot.timestamp,\n            'bid',\n            bid,\n            sizeUSD,\n            stats,\n            snapshot\n          );\n          detections.push(detection);\n        }\n      });\n\n      // Check asks\n      snapshot.asks.forEach(ask => {\n        const sizeUSD = ask.price * ask.amount;\n\n        if (sizeUSD >= threshold) {\n          const detection = this.analyzeLargeOrder(\n            exchangeId,\n            symbol,\n            snapshot.timestamp,\n            'ask',\n            ask,\n            sizeUSD,\n            stats,\n            snapshot\n          );\n          detections.push(detection);\n        }\n      });\n\n      logger.debug('Detected large orders', {\n        exchangeId,\n        symbol,\n        count: detections.length,\n        threshold: threshold.toFixed(2),\n      });\n\n      return detections.sort((a, b) => b.sizeUSD - a.sizeUSD);\n    } catch (error) {\n      logger.error('Failed to detect large orders', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate statistics for order sizes\n   */\n  private static calculateStatistics(values: number[]): {\n    mean: number;\n    stdDev: number;\n    median: number;\n    percentiles: { p50: number; p75: number; p90: number; p95: number; p99: number };\n  } {\n    const sorted = [...values].sort((a, b) => a - b);\n    const n = sorted.length;\n\n    const mean = values.reduce((sum, val) => sum + val, 0) / n;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n\n    const percentile = (p: number) => sorted[Math.floor(n * p)];\n\n    return {\n      mean,\n      stdDev,\n      median: percentile(0.5),\n      percentiles: {\n        p50: percentile(0.5),\n        p75: percentile(0.75),\n        p90: percentile(0.90),\n        p95: percentile(0.95),\n        p99: percentile(0.99),\n      },\n    };\n  }\n\n  /**\n   * Analyze a large order\n   */\n  private static analyzeLargeOrder(\n    exchangeId: string,\n    symbol: string,\n    timestamp: Date,\n    side: 'bid' | 'ask',\n    order: OrderBookLevel,\n    sizeUSD: number,\n    stats: ReturnType<typeof this.calculateStatistics>,\n    snapshot: OrderBookSnapshot\n  ): LargeOrderDetection {\n    // Calculate z-score\n    const zScore = (sizeUSD - stats.mean) / stats.stdDev;\n\n    // Calculate percentile rank\n    let percentileRank = 50;\n    if (sizeUSD >= stats.percentiles.p99) percentileRank = 99;\n    else if (sizeUSD >= stats.percentiles.p95) percentileRank = 95;\n    else if (sizeUSD >= stats.percentiles.p90) percentileRank = 90;\n    else if (sizeUSD >= stats.percentiles.p75) percentileRank = 75;\n\n    // Classify order type\n    let orderType: 'whale' | 'institutional' | 'large_retail' | 'iceberg';\n    let confidence = 70;\n\n    if (zScore > 5) {\n      orderType = 'whale';\n      confidence = 95;\n    } else if (zScore > 4) {\n      orderType = 'institutional';\n      confidence = 85;\n    } else if (zScore > 3) {\n      orderType = 'large_retail';\n      confidence = 75;\n    } else {\n      orderType = 'iceberg'; // Potential iceberg\n      confidence = 60;\n    }\n\n    // Distance from mid price\n    const midPrice = snapshot.midPrice || ((snapshot.bestBid || 0) + (snapshot.bestAsk || 0)) / 2;\n    const distanceFromMid = ((order.price - midPrice) / midPrice) * 100;\n\n    // Market share\n    const totalLiquidity = side === 'bid'\n      ? snapshot.bids.reduce((sum, b) => sum + b.price * b.amount, 0)\n      : snapshot.asks.reduce((sum, a) => sum + a.price * a.amount, 0);\n\n    const marketShare = (sizeUSD / totalLiquidity) * 100;\n\n    return {\n      exchangeId,\n      symbol,\n      timestamp,\n      side,\n      price: order.price,\n      size: order.amount,\n      sizeUSD,\n      zScore,\n      percentileRank,\n      orderType,\n      confidence,\n      distanceFromMid,\n      marketShare,\n    };\n  }\n\n  /**\n   * Detect iceberg orders (hidden liquidity)\n   */\n  static async detectIcebergOrders(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<IcebergDetection[]> {\n    try {\n      const startTime = new Date(Date.now() - lookbackMinutes * 60 * 1000);\n\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      if (snapshots.length < 10) {\n        throw new BadRequestError('Insufficient data for iceberg detection');\n      }\n\n      // Track orders at each price level\n      const priceTracking = new Map<string, {\n        appearances: number;\n        totalSize: number;\n        sizes: number[];\n        timestamps: Date[];\n      }>();\n\n      snapshots.forEach(snapshot => {\n        const bids = snapshot.bids as any as OrderBookLevel[];\n        const asks = snapshot.asks as any as OrderBookLevel[];\n\n        [...bids, ...asks].forEach(order => {\n          const key = `${order.price}`;\n          const existing = priceTracking.get(key);\n\n          if (existing) {\n            existing.appearances++;\n            existing.totalSize += order.amount;\n            existing.sizes.push(order.amount);\n            existing.timestamps.push(snapshot.timestamp);\n          } else {\n            priceTracking.set(key, {\n              appearances: 1,\n              totalSize: order.amount,\n              sizes: [order.amount],\n              timestamps: [snapshot.timestamp],\n            });\n          }\n        });\n      });\n\n      // Analyze for iceberg patterns\n      const icebergDetections: IcebergDetection[] = [];\n\n      priceTracking.forEach((data, priceStr) => {\n        const price = parseFloat(priceStr);\n\n        // Iceberg indicator: order appears multiple times with consistent size\n        if (data.appearances >= 5) {\n          const avgSize = data.totalSize / data.appearances;\n          const sizeStdDev = this.calculateStdDev(data.sizes);\n          const consistency = Math.max(0, 100 - (sizeStdDev / avgSize) * 100);\n\n          // High consistency = likely iceberg\n          if (consistency > 70) {\n            // Calculate renewal frequency\n            const timeSpan = data.timestamps[data.timestamps.length - 1].getTime() -\n                           data.timestamps[0].getTime();\n            const renewalFrequency = (data.appearances / (timeSpan / 60000)); // Per minute\n\n            // Estimate hidden size (conservative)\n            const estimatedTotalSize = avgSize * data.appearances * 2;\n            const hiddenSize = estimatedTotalSize - avgSize;\n\n            // Determine side from last snapshot\n            const lastSnapshot = snapshots[snapshots.length - 1];\n            const bids = lastSnapshot.bids as any as OrderBookLevel[];\n            const asks = lastSnapshot.asks as any as OrderBookLevel[];\n\n            const isBid = bids.some(b => b.price === price);\n            const side: 'bid' | 'ask' = isBid ? 'bid' : 'ask';\n\n            const detection: IcebergDetection = {\n              exchangeId,\n              symbol,\n              timestamp: data.timestamps[data.timestamps.length - 1],\n              side,\n              price,\n              visibleSize: avgSize,\n              estimatedTotalSize,\n              hiddenSize,\n              renewalCount: data.appearances,\n              renewalFrequency,\n              consistency,\n              confidence: Math.min(95, consistency + renewalFrequency * 5),\n              detectionMethod: 'renewal_pattern',\n            };\n\n            icebergDetections.push(detection);\n          }\n        }\n      });\n\n      logger.info('Detected iceberg orders', {\n        exchangeId,\n        symbol,\n        count: icebergDetections.length,\n      });\n\n      return icebergDetections.sort((a, b) => b.confidence - a.confidence);\n    } catch (error) {\n      logger.error('Failed to detect iceberg orders', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate standard deviation\n   */\n  private static calculateStdDev(values: number[]): number {\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    return Math.sqrt(variance);\n  }\n\n  /**\n   * Detect spoofing activity\n   */\n  static async detectSpoofing(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<SpoofingDetection[]> {\n    try {\n      const startTime = new Date(Date.now() - lookbackMinutes * 60 * 1000);\n\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      if (snapshots.length < 20) {\n        throw new BadRequestError('Insufficient data for spoofing detection');\n      }\n\n      // Track order lifecycles\n      const orderLifecycles = new Map<string, {\n        placements: number;\n        cancellations: number;\n        lifetimes: number[]; // in seconds\n        sizes: number[];\n        maxSize: number;\n        firstSeen: Date;\n        lastSeen: Date;\n      }>();\n\n      // Analyze order book changes\n      for (let i = 1; i < snapshots.length; i++) {\n        const current = snapshots[i];\n        const previous = snapshots[i - 1];\n\n        const currentBids = current.bids as any as OrderBookLevel[];\n        const currentAsks = current.asks as any as OrderBookLevel[];\n        const previousBids = previous.bids as any as OrderBookLevel[];\n        const previousAsks = previous.asks as any as OrderBookLevel[];\n\n        // Check for orders that appeared and disappeared\n        this.trackOrderChanges(\n          currentBids,\n          previousBids,\n          'bid',\n          current.timestamp,\n          previous.timestamp,\n          orderLifecycles\n        );\n\n        this.trackOrderChanges(\n          currentAsks,\n          previousAsks,\n          'ask',\n          current.timestamp,\n          previous.timestamp,\n          orderLifecycles\n        );\n      }\n\n      // Analyze for spoofing patterns\n      const spoofingDetections: SpoofingDetection[] = [];\n\n      orderLifecycles.forEach((data, key) => {\n        const [side, priceStr] = key.split(':');\n        const price = parseFloat(priceStr);\n\n        // Spoofing indicators:\n        // 1. Many placements/cancellations\n        // 2. Short average lifetime\n        // 3. Low execution rate (not executed, just cancelled)\n\n        if (data.placements >= 5 && data.cancellations >= 3) {\n          const avgLifetime = data.lifetimes.reduce((sum, val) => sum + val, 0) / data.lifetimes.length;\n          const executionRate = ((data.placements - data.cancellations) / data.placements) * 100;\n\n          // Short-lived orders with low execution = likely spoofing\n          if (avgLifetime < 30 && executionRate < 20) {\n            let spoofingType: 'layering' | 'spoofing' | 'quote_stuffing';\n            let severity: 'low' | 'medium' | 'high' | 'extreme';\n\n            // Classification\n            if (data.placements > 20) {\n              spoofingType = 'quote_stuffing'; // Many rapid orders\n              severity = 'extreme';\n            } else if (data.cancellations > data.placements * 0.8) {\n              spoofingType = 'spoofing'; // Most orders cancelled\n              severity = 'high';\n            } else {\n              spoofingType = 'layering'; // Multiple layers\n              severity = 'medium';\n            }\n\n            // Confidence based on pattern strength\n            const confidence = Math.min(95,\n              (data.placements / 20) * 30 +\n              (100 - executionRate) * 0.4 +\n              (30 / avgLifetime) * 30\n            );\n\n            const detection: SpoofingDetection = {\n              exchangeId,\n              symbol,\n              timestamp: data.lastSeen,\n              startTime: data.firstSeen,\n              endTime: data.lastSeen,\n              side: side as 'bid' | 'ask',\n              price,\n              maxSize: data.maxSize,\n              avgLifetime,\n              placementCount: data.placements,\n              cancellationCount: data.cancellations,\n              executionRate,\n              spoofingType,\n              severity,\n              confidence,\n            };\n\n            spoofingDetections.push(detection);\n          }\n        }\n      });\n\n      logger.warn('Detected spoofing activity', {\n        exchangeId,\n        symbol,\n        count: spoofingDetections.length,\n      });\n\n      return spoofingDetections.sort((a, b) => b.confidence - a.confidence);\n    } catch (error) {\n      logger.error('Failed to detect spoofing', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Track order changes between snapshots\n   */\n  private static trackOrderChanges(\n    current: OrderBookLevel[],\n    previous: OrderBookLevel[],\n    side: 'bid' | 'ask',\n    currentTime: Date,\n    previousTime: Date,\n    tracking: Map<string, any>\n  ): void {\n    const currentMap = new Map(current.map(o => [o.price, o.amount]));\n    const previousMap = new Map(previous.map(o => [o.price, o.amount]));\n\n    // Find orders that disappeared (cancelled)\n    previousMap.forEach((amount, price) => {\n      const key = `${side}:${price}`;\n\n      if (!currentMap.has(price)) {\n        // Order was cancelled\n        const existing = tracking.get(key);\n\n        if (existing) {\n          existing.cancellations++;\n          const lifetime = (currentTime.getTime() - previousTime.getTime()) / 1000;\n          existing.lifetimes.push(lifetime);\n          existing.lastSeen = currentTime;\n        }\n      }\n    });\n\n    // Find new orders (placements)\n    currentMap.forEach((amount, price) => {\n      const key = `${side}:${price}`;\n\n      if (!previousMap.has(price)) {\n        // New order placement\n        const existing = tracking.get(key);\n\n        if (existing) {\n          existing.placements++;\n          existing.sizes.push(amount);\n          existing.maxSize = Math.max(existing.maxSize, amount);\n          existing.lastSeen = currentTime;\n        } else {\n          tracking.set(key, {\n            placements: 1,\n            cancellations: 0,\n            lifetimes: [],\n            sizes: [amount],\n            maxSize: amount,\n            firstSeen: currentTime,\n            lastSeen: currentTime,\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Detect order clusters\n   */\n  static async detectOrderClusters(\n    exchangeId: string,\n    symbol: string,\n    priceRangePercent: number = 0.5 // Cluster within 0.5% price range\n  ): Promise<OrderCluster[]> {\n    try {\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n      if (!snapshot) {\n        throw new BadRequestError('No order book data available');\n      }\n\n      const clusters: OrderCluster[] = [];\n\n      // Analyze bids\n      const bidClusters = this.findClusters(\n        snapshot.bids,\n        'bid',\n        priceRangePercent,\n        exchangeId,\n        symbol,\n        snapshot.timestamp\n      );\n      clusters.push(...bidClusters);\n\n      // Analyze asks\n      const askClusters = this.findClusters(\n        snapshot.asks,\n        'ask',\n        priceRangePercent,\n        exchangeId,\n        symbol,\n        snapshot.timestamp\n      );\n      clusters.push(...askClusters);\n\n      logger.debug('Detected order clusters', {\n        exchangeId,\n        symbol,\n        count: clusters.length,\n      });\n\n      return clusters.sort((a, b) => b.clusterStrength - a.clusterStrength);\n    } catch (error) {\n      logger.error('Failed to detect order clusters', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Find clusters in order book side\n   */\n  private static findClusters(\n    orders: OrderBookLevel[],\n    side: 'bid' | 'ask',\n    rangePercent: number,\n    exchangeId: string,\n    symbol: string,\n    timestamp: Date\n  ): OrderCluster[] {\n    const clusters: OrderCluster[] = [];\n    const processed = new Set<number>();\n\n    orders.forEach((order, index) => {\n      if (processed.has(index)) return;\n\n      const priceRange = order.price * (rangePercent / 100);\n      const minPrice = order.price - priceRange;\n      const maxPrice = order.price + priceRange;\n\n      // Find all orders in this price range\n      const clusterOrders = orders.filter((o, i) => {\n        if (processed.has(i)) return false;\n        return o.price >= minPrice && o.price <= maxPrice;\n      });\n\n      if (clusterOrders.length >= 3) {\n        // Mark as processed\n        clusterOrders.forEach((o) => {\n          const idx = orders.indexOf(o);\n          if (idx >= 0) processed.add(idx);\n        });\n\n        const totalSize = clusterOrders.reduce((sum, o) => sum + o.price * o.amount, 0);\n        const avgPrice = clusterOrders.reduce((sum, o) => sum + o.price, 0) / clusterOrders.length;\n\n        // Cluster strength based on size and density\n        const clusterStrength = Math.min(100,\n          (clusterOrders.length / orders.length) * 50 +\n          (totalSize / 1000000) * 50\n        );\n\n        // Determine intention\n        let intention: 'accumulation' | 'distribution' | 'defense' | 'unknown' = 'unknown';\n        if (side === 'bid' && clusterStrength > 70) intention = 'accumulation';\n        else if (side === 'ask' && clusterStrength > 70) intention = 'distribution';\n        else if (clusterStrength > 50) intention = 'defense';\n\n        clusters.push({\n          exchangeId,\n          symbol,\n          timestamp,\n          side,\n          priceRange: {\n            min: Math.min(...clusterOrders.map(o => o.price)),\n            max: Math.max(...clusterOrders.map(o => o.price)),\n          },\n          centerPrice: avgPrice,\n          totalSize,\n          orderCount: clusterOrders.length,\n          clusterStrength,\n          supportResistanceLevel: clusterStrength > 60,\n          intention,\n        });\n      }\n    });\n\n    return clusters;\n  }\n\n  /**\n   * Get whale activity summary\n   */\n  static async getWhaleActivitySummary(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<WhaleActivitySummary> {\n    try {\n      const endTime = new Date();\n      const startTime = new Date(endTime.getTime() - lookbackMinutes * 60 * 1000);\n\n      // Get all large orders in time range\n      const largeOrders = await this.detectLargeOrders(exchangeId, symbol, 3.0);\n\n      // Filter to whale orders only\n      const whaleOrders = largeOrders.filter(o => o.orderType === 'whale' || o.zScore > 4);\n\n      // Calculate metrics\n      const bidWhaleOrders = whaleOrders.filter(o => o.side === 'bid');\n      const askWhaleOrders = whaleOrders.filter(o => o.side === 'ask');\n\n      const bidWhaleVolume = bidWhaleOrders.reduce((sum, o) => sum + o.sizeUSD, 0);\n      const askWhaleVolume = askWhaleOrders.reduce((sum, o) => sum + o.sizeUSD, 0);\n\n      // Sentiment analysis\n      let whaleSentiment: 'bullish' | 'bearish' | 'neutral';\n      const sentimentRatio = bidWhaleVolume / (askWhaleVolume || 1);\n\n      if (sentimentRatio > 1.5) whaleSentiment = 'bullish';\n      else if (sentimentRatio < 0.67) whaleSentiment = 'bearish';\n      else whaleSentiment = 'neutral';\n\n      // Confidence based on volume\n      const totalVolume = bidWhaleVolume + askWhaleVolume;\n      const confidenceScore = Math.min(100, (totalVolume / 10000000) * 100);\n\n      const result: WhaleActivitySummary = {\n        exchangeId,\n        symbol,\n        timestamp: new Date(),\n        timeRange: { start: startTime, end: endTime },\n        totalWhaleOrders: whaleOrders.length,\n        totalWhaleVolume: bidWhaleVolume + askWhaleVolume,\n        totalWhaleVolumeUSD: bidWhaleVolume + askWhaleVolume,\n        bidWhaleOrders: bidWhaleOrders.length,\n        askWhaleOrders: askWhaleOrders.length,\n        bidWhaleVolume,\n        askWhaleVolume,\n        whaleSentiment,\n        confidenceScore,\n        largestBid: bidWhaleOrders.length > 0 ? bidWhaleOrders[0] : undefined,\n        largestAsk: askWhaleOrders.length > 0 ? askWhaleOrders[0] : undefined,\n      };\n\n      logger.info('Generated whale activity summary', {\n        exchangeId,\n        symbol,\n        whaleOrders: whaleOrders.length,\n        sentiment: whaleSentiment,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to get whale activity summary', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Store large order detection in database\n   */\n  static async storeLargeOrderDetection(\n    detection: LargeOrderDetection\n  ): Promise<void> {\n    try {\n      await db.insert(largeOrdersDetected).values({\n        exchangeId: detection.exchangeId,\n        symbol: detection.symbol,\n        timestamp: detection.timestamp,\n        side: detection.side,\n        priceLevel: detection.price.toString(),\n        visibleSize: detection.size.toString(),\n        orderType: detection.orderType,\n        icebergProbability: detection.confidence.toString(),\n      });\n\n      logger.debug('Stored large order detection', {\n        exchangeId: detection.exchangeId,\n        symbol: detection.symbol,\n        orderType: detection.orderType,\n      });\n    } catch (error) {\n      logger.error('Failed to store large order detection', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Store spoofing detection in database\n   */\n  static async storeSpoofingDetection(\n    detection: SpoofingDetection\n  ): Promise<void> {\n    try {\n      await db.insert(spoofingEvents).values({\n        exchangeId: detection.exchangeId,\n        symbol: detection.symbol,\n        detectedAt: detection.timestamp,\n        side: detection.side,\n        priceLevel: detection.price.toString(),\n        orderSize: detection.maxSize.toString(),\n        spoofingType: detection.spoofingType,\n        confidenceScore: detection.confidence.toString(),\n      });\n\n      logger.warn('Stored spoofing detection', {\n        exchangeId: detection.exchangeId,\n        symbol: detection.symbol,\n        spoofingType: detection.spoofingType,\n        severity: detection.severity,\n      });\n    } catch (error) {\n      logger.error('Failed to store spoofing detection', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/liquidity-heatmap.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Liquidity Heatmap Service\n * Bookmap-style liquidity heatmap visualization\n *\n * Features:\n * - 2D heatmap generation (price x time)\n * - Intensity calculation for color mapping\n * - Historical liquidity tracking\n * - Liquidity concentration detection\n * - Support/resistance zone identification\n * - Heatmap data aggregation\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte, sql } from 'drizzle-orm';\nimport { liquidityHeatmapData, liquidityZones } from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type {\n  OrderBookSnapshot,\n  LiquidityHeatmapPoint,\n  LiquidityHeatmap,\n  LiquidityZone,\n} from '../types/order-book.types';\n\nexport class LiquidityHeatmapService {\n  /**\n   * Generate heatmap data points from order book snapshot\n   */\n  static generateHeatmapPoints(snapshot: OrderBookSnapshot): LiquidityHeatmapPoint[] {\n    const points: LiquidityHeatmapPoint[] = [];\n\n    // Calculate max volume for intensity normalization\n    const allVolumes = [\n      ...snapshot.bids.map((l) => l.price * l.amount),\n      ...snapshot.asks.map((l) => l.price * l.amount),\n    ];\n    const maxVolume = Math.max(...allVolumes, 0);\n\n    // Process bids\n    snapshot.bids.forEach((level) => {\n      const volume = level.price * level.amount; // USD value\n      const intensity = maxVolume > 0 ? (volume / maxVolume) * 100 : 0;\n\n      points.push({\n        exchangeId: snapshot.exchangeId,\n        symbol: snapshot.symbol,\n        timestamp: snapshot.timestamp,\n        priceLevel: level.price,\n        bidVolume: volume,\n        askVolume: 0,\n        totalVolume: volume,\n        intensity,\n      });\n    });\n\n    // Process asks\n    snapshot.asks.forEach((level) => {\n      const volume = level.price * level.amount; // USD value\n      const intensity = maxVolume > 0 ? (volume / maxVolume) * 100 : 0;\n\n      // Check if price level already exists (from bids)\n      const existingPoint = points.find((p) => p.priceLevel === level.price);\n\n      if (existingPoint) {\n        existingPoint.askVolume = volume;\n        existingPoint.totalVolume += volume;\n        existingPoint.intensity = maxVolume > 0 ? (existingPoint.totalVolume / maxVolume) * 100 : 0;\n      } else {\n        points.push({\n          exchangeId: snapshot.exchangeId,\n          symbol: snapshot.symbol,\n          timestamp: snapshot.timestamp,\n          priceLevel: level.price,\n          bidVolume: 0,\n          askVolume: volume,\n          totalVolume: volume,\n          intensity,\n        });\n      }\n    });\n\n    return points;\n  }\n\n  /**\n   * Store heatmap data points\n   */\n  static async storeHeatmapPoints(points: LiquidityHeatmapPoint[]): Promise<void> {\n    if (points.length === 0) return;\n\n    try {\n      await db.insert(liquidityHeatmapData).values(\n        points.map((point) => ({\n          exchangeId: point.exchangeId,\n          symbol: point.symbol,\n          timestamp: point.timestamp,\n          priceLevel: point.priceLevel.toString(),\n          bidVolume: point.bidVolume.toString(),\n          askVolume: point.askVolume.toString(),\n          totalVolume: point.totalVolume.toString(),\n          intensity: point.intensity.toString(),\n        }))\n      );\n\n      logger.debug('Stored liquidity heatmap points', {\n        exchangeId: points[0].exchangeId,\n        symbol: points[0].symbol,\n        count: points.length,\n      });\n    } catch (error) {\n      logger.error('Failed to store liquidity heatmap points', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get heatmap data for time range\n   */\n  static async getHeatmapData(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date,\n    priceMin?: number,\n    priceMax?: number\n  ): Promise<LiquidityHeatmap> {\n    try {\n      // Build where conditions\n      const conditions = [\n        eq(liquidityHeatmapData.exchangeId, exchangeId),\n        eq(liquidityHeatmapData.symbol, symbol),\n        gte(liquidityHeatmapData.timestamp, startTime),\n        lte(liquidityHeatmapData.timestamp, endTime),\n      ];\n\n      // Add price range filters if provided\n      if (priceMin !== undefined) {\n        conditions.push(gte(liquidityHeatmapData.priceLevel, priceMin.toString()));\n      }\n      if (priceMax !== undefined) {\n        conditions.push(lte(liquidityHeatmapData.priceLevel, priceMax.toString()));\n      }\n\n      // Query heatmap data\n      const results = await db\n        .select()\n        .from(liquidityHeatmapData)\n        .where(and(...conditions))\n        .orderBy(\n          liquidityHeatmapData.timestamp,\n          liquidityHeatmapData.priceLevel\n        );\n\n      if (results.length === 0) {\n        throw new BadRequestError('No heatmap data found for the specified time range');\n      }\n\n      // Convert to points\n      const points: LiquidityHeatmapPoint[] = results.map((row) => ({\n        id: row.id,\n        exchangeId: row.exchangeId,\n        symbol: row.symbol,\n        timestamp: row.timestamp,\n        priceLevel: parseFloat(row.priceLevel ?? '0'),\n        bidVolume: parseFloat(row.bidVolume ?? '0'),\n        askVolume: parseFloat(row.askVolume ?? '0'),\n        totalVolume: parseFloat(row.totalVolume ?? '0'),\n        intensity: parseFloat(row.intensity ?? '0'),\n        createdAt: row.createdAt,\n      }));\n\n      // Group by timestamp\n      const dataByTimestamp = new Map<number, LiquidityHeatmapPoint[]>();\n      points.forEach((point) => {\n        const timestamp = point.timestamp.getTime();\n        if (!dataByTimestamp.has(timestamp)) {\n          dataByTimestamp.set(timestamp, []);\n        }\n        dataByTimestamp.get(timestamp)!.push(point);\n      });\n\n      // Convert to 2D array\n      const data = Array.from(dataByTimestamp.values());\n\n      // Calculate bounds\n      const minPrice = Math.min(...points.map((p) => p.priceLevel));\n      const maxPrice = Math.max(...points.map((p) => p.priceLevel));\n      const minIntensity = Math.min(...points.map((p) => p.intensity));\n      const maxIntensity = Math.max(...points.map((p) => p.intensity));\n\n      return {\n        exchangeId,\n        symbol,\n        startTime,\n        endTime,\n        data,\n        minPrice,\n        maxPrice,\n        minIntensity,\n        maxIntensity,\n      };\n    } catch (error) {\n      logger.error('Failed to get heatmap data', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Detect liquidity zones (support/resistance) from heatmap\n   */\n  static detectLiquidityZones(\n    heatmapData: LiquidityHeatmap,\n    minIntensityThreshold: number = 70,\n    minDuration: number = 3 // Number of snapshots\n  ): LiquidityZone[] {\n    const zones: LiquidityZone[] = [];\n\n    // Aggregate volume by price level across time\n    const volumeByPrice = new Map<number, { total: number; count: number; timestamps: Date[] }>();\n\n    heatmapData.data.forEach((snapshot) => {\n      snapshot.forEach((point) => {\n        if (point.intensity >= minIntensityThreshold) {\n          const existing = volumeByPrice.get(point.priceLevel);\n          if (existing) {\n            existing.total += point.totalVolume;\n            existing.count++;\n            existing.timestamps.push(point.timestamp);\n          } else {\n            volumeByPrice.set(point.priceLevel, {\n              total: point.totalVolume,\n              count: 1,\n              timestamps: [point.timestamp],\n            });\n          }\n        }\n      });\n    });\n\n    // Find zones that appear frequently enough\n    volumeByPrice.forEach((data, priceLevel) => {\n      if (data.count >= minDuration) {\n        const averageVolume = data.total / data.count;\n        const firstSeen = new Date(Math.min(...data.timestamps.map((t) => t.getTime())));\n        const lastSeen = new Date(Math.max(...data.timestamps.map((t) => t.getTime())));\n\n        // Determine zone type based on price position\n        const midPrice = (heatmapData.minPrice + heatmapData.maxPrice) / 2;\n        const zoneType = priceLevel < midPrice ? 'support' : 'resistance';\n\n        // Calculate strength based on frequency and volume\n        const frequencyScore = Math.min(100, (data.count / heatmapData.data.length) * 100);\n        const volumeScore = Math.min(100, (averageVolume / 1000000) * 100); // Normalized to $1M\n        const strength = (frequencyScore * 0.6 + volumeScore * 0.4);\n\n        // Confidence based on duration and consistency\n        const durationMinutes = (lastSeen.getTime() - firstSeen.getTime()) / 1000 / 60;\n        const confidenceScore = Math.min(100, (durationMinutes / 60) * 100); // Normalized to 1 hour\n\n        zones.push({\n          exchangeId: heatmapData.exchangeId,\n          symbol: heatmapData.symbol,\n          priceLevel,\n          side: 'both', // Detected from heatmap, could be either\n          totalLiquidity: data.total,\n          averageSize: averageVolume,\n          orderCount: data.count,\n          zoneType,\n          strength,\n          detectedAt: firstSeen,\n          lastSeenAt: lastSeen,\n          confidenceScore,\n          isActive: true,\n        });\n      }\n    });\n\n    // Sort by strength (strongest first)\n    zones.sort((a, b) => b.strength - a.strength);\n\n    logger.info('Detected liquidity zones from heatmap', {\n      exchangeId: heatmapData.exchangeId,\n      symbol: heatmapData.symbol,\n      zonesFound: zones.length,\n    });\n\n    return zones;\n  }\n\n  /**\n   * Store liquidity zones\n   */\n  static async storeLiquidityZones(zones: LiquidityZone[]): Promise<void> {\n    if (zones.length === 0) return;\n\n    try {\n      await db.insert(liquidityZones).values(\n        zones.map((zone) => ({\n          exchangeId: zone.exchangeId,\n          symbol: zone.symbol,\n          priceLevel: zone.priceLevel.toString(),\n          priceRange: zone.priceRange?.toString(),\n          side: zone.side,\n          totalLiquidity: zone.totalLiquidity.toString(),\n          averageSize: zone.averageSize?.toString(),\n          orderCount: zone.orderCount,\n          zoneType: zone.zoneType,\n          strength: zone.strength.toString(),\n          detectedAt: zone.detectedAt,\n          lastSeenAt: zone.lastSeenAt,\n          confidenceScore: zone.confidenceScore?.toString(),\n          isActive: zone.isActive,\n        }))\n      );\n\n      logger.info('Stored liquidity zones', {\n        exchangeId: zones[0].exchangeId,\n        symbol: zones[0].symbol,\n        count: zones.length,\n      });\n    } catch (error) {\n      logger.error('Failed to store liquidity zones', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get active liquidity zones\n   */\n  static async getActiveLiquidityZones(\n    exchangeId: string,\n    symbol: string,\n    minStrength: number = 50\n  ): Promise<LiquidityZone[]> {\n    try {\n      const results = await db\n        .select()\n        .from(liquidityZones)\n        .where(\n          and(\n            eq(liquidityZones.exchangeId, exchangeId),\n            eq(liquidityZones.symbol, symbol),\n            eq(liquidityZones.isActive, true),\n            gte(liquidityZones.strength, minStrength.toString())\n          )\n        )\n        .orderBy(desc(liquidityZones.strength))\n        .limit(20);\n\n      return results.map((row) => ({\n        id: row.id,\n        exchangeId: row.exchangeId,\n        symbol: row.symbol,\n        priceLevel: parseFloat(row.priceLevel ?? '0'),\n        priceRange: row.priceRange ? parseFloat(row.priceRange) : undefined,\n        side: row.side as 'bid' | 'ask' | 'both',\n        totalLiquidity: parseFloat(row.totalLiquidity ?? '0'),\n        averageSize: row.averageSize ? parseFloat(row.averageSize) : undefined,\n        orderCount: row.orderCount || undefined,\n        zoneType: row.zoneType as 'support' | 'resistance' | 'accumulation' | 'distribution',\n        strength: parseFloat(row.strength ?? '0'),\n        detectedAt: row.detectedAt,\n        lastSeenAt: row.lastSeenAt,\n        confidenceScore: row.confidenceScore ? parseFloat(row.confidenceScore) : undefined,\n        isActive: row.isActive ?? true,\n        createdAt: row.createdAt,\n        updatedAt: row.updatedAt,\n      }));\n    } catch (error) {\n      logger.error('Failed to get active liquidity zones', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Deactivate old liquidity zones (cleanup)\n   */\n  static async deactivateOldZones(olderThan: Date): Promise<number> {\n    try {\n      const result = await db\n        .update(liquidityZones)\n        .set({ isActive: false, updatedAt: new Date() })\n        .where(lte(liquidityZones.lastSeenAt, olderThan));\n\n      logger.info('Deactivated old liquidity zones', {\n        olderThan,\n        count: result.rowCount || 0,\n      });\n\n      return result.rowCount || 0;\n    } catch (error) {\n      logger.error('Failed to deactivate old liquidity zones', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate and store heatmap from snapshot (convenience method)\n   */\n  static async generateAndStore(\n    exchangeId: string,\n    symbol: string\n  ): Promise<LiquidityHeatmapPoint[]> {\n    // Get latest snapshot\n    const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n    if (!snapshot) {\n      throw new BadRequestError('No order book snapshot found');\n    }\n\n    // Generate heatmap points\n    const points = this.generateHeatmapPoints(snapshot);\n\n    // Store points\n    await this.storeHeatmapPoints(points);\n\n    logger.info('Generated and stored liquidity heatmap', {\n      exchangeId,\n      symbol,\n      points: points.length,\n    });\n\n    return points;\n  }\n\n  /**\n   * Analyze heatmap and detect zones (full workflow)\n   */\n  static async analyzeAndDetectZones(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date,\n    minIntensityThreshold: number = 70,\n    minDuration: number = 3\n  ): Promise<{\n    heatmap: LiquidityHeatmap;\n    zones: LiquidityZone[];\n  }> {\n    // Get heatmap data\n    const heatmap = await this.getHeatmapData(exchangeId, symbol, startTime, endTime);\n\n    // Detect zones\n    const zones = this.detectLiquidityZones(heatmap, minIntensityThreshold, minDuration);\n\n    // Store zones\n    if (zones.length > 0) {\n      await this.storeLiquidityZones(zones);\n    }\n\n    logger.info('Analyzed heatmap and detected zones', {\n      exchangeId,\n      symbol,\n      dataPoints: heatmap.data.flat().length,\n      zonesDetected: zones.length,\n    });\n\n    return { heatmap, zones };\n  }\n\n  /**\n   * Get heatmap intensity distribution (for visualization)\n   */\n  static getIntensityDistribution(heatmap: LiquidityHeatmap): {\n    buckets: { min: number; max: number; count: number }[];\n    mean: number;\n    median: number;\n    stdDev: number;\n  } {\n    const allIntensities = heatmap.data.flat().map((p) => p.intensity);\n\n    // Create 10 buckets\n    const bucketSize = (heatmap.maxIntensity - heatmap.minIntensity) / 10;\n    const buckets = Array.from({ length: 10 }, (_, i) => ({\n      min: heatmap.minIntensity + i * bucketSize,\n      max: heatmap.minIntensity + (i + 1) * bucketSize,\n      count: 0,\n    }));\n\n    allIntensities.forEach((intensity) => {\n      const bucketIndex = Math.min(\n        Math.floor((intensity - heatmap.minIntensity) / bucketSize),\n        9\n      );\n      buckets[bucketIndex].count++;\n    });\n\n    // Calculate statistics\n    const mean = allIntensities.reduce((sum, val) => sum + val, 0) / allIntensities.length;\n    const sortedIntensities = [...allIntensities].sort((a, b) => a - b);\n    const median = sortedIntensities[Math.floor(sortedIntensities.length / 2)];\n    const variance =\n      allIntensities.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /\n      allIntensities.length;\n    const stdDev = Math.sqrt(variance);\n\n    return { buckets, mean, median, stdDev };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/microstructure.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OrderBookSnapshotService' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OrderBookSnapshot' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Market Microstructure Service\n * Advanced market microstructure analysis and metrics\n *\n * Implements:\n * - VPIN (Volume-Synchronized Probability of Informed Trading)\n * - Order Flow Toxicity\n * - Market Noise Ratio\n * - Bid-Ask Bounce\n * - Price Discovery Efficiency\n * - Informed Trading Detection\n * - Kyle's Lambda (Price Impact Coefficient)\n * - Adverse Selection Risk\n *\n * References:\n * - Easley, D., López de Prado, M., & O'Hara, M. (2012). \"Flow Toxicity and Liquidity in a High-frequency World\"\n * - Kyle, A. S. (1985). \"Continuous Auctions and Insider Trading\"\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte, sql } from 'drizzle-orm';\nimport {\n  orderBookSnapshots,\n  orderFlowToxicity,\n  microstructureMetrics\n} from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type { OrderBookSnapshot, OrderBookLevel } from '../types/order-book.types';\n\n/**\n * VPIN (Volume-Synchronized Probability of Informed Trading)\n * Measures the probability of informed trading based on order flow imbalance\n */\nexport interface VPINMetrics {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // VPIN calculation\n  vpin: number; // 0-100, higher = more informed trading\n  volumeBucketSize: number; // Volume per bucket\n  numberOfBuckets: number; // Lookback window in buckets\n\n  // Volume classification\n  buyVolume: number; // Estimated buy volume\n  sellVolume: number; // Estimated sell volume\n  totalVolume: number;\n\n  // Toxicity indicators\n  toxicityLevel: 'low' | 'medium' | 'high' | 'extreme';\n  informedTradingProbability: number; // 0-1\n\n  // Confidence\n  confidence: number; // Based on sample size and consistency\n}\n\n/**\n * Order Flow Toxicity Metrics\n */\nexport interface OrderFlowToxicityMetrics {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Toxicity score (0-100)\n  toxicityScore: number;\n  toxicityLevel: 'low' | 'medium' | 'high' | 'extreme';\n\n  // Components\n  adverseSelectionCost: number; // Cost of being picked off\n  priceReversal: number; // Tendency for prices to reverse\n  informedTradingRatio: number; // Ratio of informed to uninformed\n\n  // Market quality\n  effectiveSpread: number;\n  realizedSpread: number;\n  priceImpact: number;\n\n  // Risk indicators\n  adverseSelectionRisk: 'low' | 'medium' | 'high';\n  marketMakerRisk: number; // Risk score for market makers\n}\n\n/**\n * Market Noise Metrics\n */\nexport interface MarketNoiseMetrics {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Noise ratio (0-1, higher = more noise)\n  noiseRatio: number;\n  signalToNoise: number;\n\n  // Price efficiency\n  efficiencyRatio: number; // How efficiently price discovers information\n  autocorrelation: number; // Price autocorrelation\n\n  // Microstructure noise\n  bidAskBounce: number; // Variance from bid-ask bounce\n  tickNoise: number; // Noise from minimum tick size\n\n  // Quality assessment\n  priceQuality: 'excellent' | 'good' | 'fair' | 'poor';\n}\n\n/**\n * Kyle's Lambda (Price Impact Coefficient)\n */\nexport interface KyleLambda {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Lambda coefficient\n  lambda: number; // Price impact per unit of volume\n\n  // Interpretation\n  marketDepth: 'deep' | 'moderate' | 'shallow';\n  liquidityLevel: number; // Inverse of lambda\n\n  // Components\n  priceChange: number;\n  volumeTraded: number;\n\n  // Confidence\n  rSquared: number; // Goodness of fit\n  sampleSize: number;\n}\n\n/**\n * Comprehensive Microstructure Metrics\n */\nexport interface MicrostructureMetricsComplete {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // All metric sets\n  vpin: VPINMetrics;\n  toxicity: OrderFlowToxicityMetrics;\n  noise: MarketNoiseMetrics;\n  kyle: KyleLambda;\n\n  // Overall assessment\n  overallQuality: 'excellent' | 'good' | 'fair' | 'poor';\n  tradingRecommendation: 'favorable' | 'neutral' | 'caution' | 'avoid';\n}\n\nexport class MicrostructureService {\n  /**\n   * Calculate VPIN (Volume-Synchronized Probability of Informed Trading)\n   */\n  static async calculateVPIN(\n    exchangeId: string,\n    symbol: string,\n    volumeBucketSize: number = 1000000, // $1M per bucket\n    numberOfBuckets: number = 50\n  ): Promise<VPINMetrics> {\n    try {\n      // Get recent snapshots\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol)\n          )\n        )\n        .orderBy(desc(orderBookSnapshots.timestamp))\n        .limit(numberOfBuckets * 10); // Get enough data\n\n      if (snapshots.length < numberOfBuckets) {\n        throw new BadRequestError('Insufficient data for VPIN calculation');\n      }\n\n      // Create volume buckets\n      const buckets: Array<{ buyVolume: number; sellVolume: number }> = [];\n      let currentBucket = { buyVolume: 0, sellVolume: 0 };\n      let currentVolume = 0;\n\n      for (let i = 0; i < snapshots.length - 1; i++) {\n        const current = snapshots[i];\n        const previous = snapshots[i + 1];\n\n        // Calculate volume traded and classify as buy/sell\n        const { buyVolume, sellVolume } = this.classifyVolume(current, previous);\n\n        currentBucket.buyVolume += buyVolume;\n        currentBucket.sellVolume += sellVolume;\n        currentVolume += buyVolume + sellVolume;\n\n        // If bucket is full, start new bucket\n        if (currentVolume >= volumeBucketSize) {\n          buckets.push({ ...currentBucket });\n          currentBucket = { buyVolume: 0, sellVolume: 0 };\n          currentVolume = 0;\n\n          if (buckets.length >= numberOfBuckets) break;\n        }\n      }\n\n      if (buckets.length < numberOfBuckets) {\n        throw new BadRequestError('Could not create enough volume buckets');\n      }\n\n      // Calculate VPIN\n      let totalImbalance = 0;\n      let totalVolume = 0;\n\n      buckets.forEach(bucket => {\n        const imbalance = Math.abs(bucket.buyVolume - bucket.sellVolume);\n        const volume = bucket.buyVolume + bucket.sellVolume;\n\n        totalImbalance += imbalance;\n        totalVolume += volume;\n      });\n\n      const vpin = (totalImbalance / totalVolume) * 100;\n\n      // Determine toxicity level\n      let toxicityLevel: 'low' | 'medium' | 'high' | 'extreme';\n      if (vpin < 30) toxicityLevel = 'low';\n      else if (vpin < 50) toxicityLevel = 'medium';\n      else if (vpin < 70) toxicityLevel = 'high';\n      else toxicityLevel = 'extreme';\n\n      // Calculate total buy/sell volume\n      const totalBuyVolume = buckets.reduce((sum, b) => sum + b.buyVolume, 0);\n      const totalSellVolume = buckets.reduce((sum, b) => sum + b.sellVolume, 0);\n\n      // Confidence based on consistency\n      const vpinVariance = this.calculateVPINVariance(buckets);\n      const confidence = Math.max(0, 100 - vpinVariance * 100);\n\n      const result: VPINMetrics = {\n        exchangeId,\n        symbol,\n        timestamp: snapshots[0].timestamp,\n        vpin,\n        volumeBucketSize,\n        numberOfBuckets,\n        buyVolume: totalBuyVolume,\n        sellVolume: totalSellVolume,\n        totalVolume: totalBuyVolume + totalSellVolume,\n        toxicityLevel,\n        informedTradingProbability: vpin / 100,\n        confidence,\n      };\n\n      logger.debug('Calculated VPIN', {\n        exchangeId,\n        symbol,\n        vpin: vpin.toFixed(2),\n        toxicityLevel,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate VPIN', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Classify volume as buy or sell using trade classification algorithm\n   */\n  private static classifyVolume(\n    current: typeof orderBookSnapshots.$inferSelect,\n    previous: typeof orderBookSnapshots.$inferSelect\n  ): { buyVolume: number; sellVolume: number } {\n    const currentBids = current.bids as any as OrderBookLevel[];\n    const currentAsks = current.asks as any as OrderBookLevel[];\n    const previousBids = previous.bids as any as OrderBookLevel[];\n    const previousAsks = previous.asks as any as OrderBookLevel[];\n\n    // Calculate mid-price change\n    const currentMid = (parseFloat(current.bestBid || '0') + parseFloat(current.bestAsk || '0')) / 2;\n    const previousMid = (parseFloat(previous.bestBid || '0') + parseFloat(previous.bestAsk || '0')) / 2;\n\n    // Calculate volume changes\n    const bidVolumeChange = this.calculateVolumeChange(currentBids, previousBids);\n    const askVolumeChange = this.calculateVolumeChange(currentAsks, previousAsks);\n\n    // Tick rule: if price moved up, it's a buy; if down, it's a sell\n    let buyVolume = 0;\n    let sellVolume = 0;\n\n    if (currentMid > previousMid) {\n      // Price increased = aggressive buy\n      buyVolume = Math.abs(askVolumeChange);\n    } else if (currentMid < previousMid) {\n      // Price decreased = aggressive sell\n      sellVolume = Math.abs(bidVolumeChange);\n    } else {\n      // No price change, use volume changes\n      buyVolume = Math.max(0, -askVolumeChange);\n      sellVolume = Math.max(0, -bidVolumeChange);\n    }\n\n    return { buyVolume, sellVolume };\n  }\n\n  /**\n   * Calculate volume change between snapshots\n   */\n  private static calculateVolumeChange(\n    current: OrderBookLevel[],\n    previous: OrderBookLevel[]\n  ): number {\n    const currentVolume = current.reduce((sum, level) => sum + level.price * level.amount, 0);\n    const previousVolume = previous.reduce((sum, level) => sum + level.price * level.amount, 0);\n    return currentVolume - previousVolume;\n  }\n\n  /**\n   * Calculate VPIN variance for confidence scoring\n   */\n  private static calculateVPINVariance(\n    buckets: Array<{ buyVolume: number; sellVolume: number }>\n  ): number {\n    const imbalances = buckets.map(bucket => {\n      const total = bucket.buyVolume + bucket.sellVolume;\n      return total > 0 ? Math.abs(bucket.buyVolume - bucket.sellVolume) / total : 0;\n    });\n\n    const mean = imbalances.reduce((sum, val) => sum + val, 0) / imbalances.length;\n    const variance = imbalances.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / imbalances.length;\n\n    return Math.sqrt(variance); // Standard deviation\n  }\n\n  /**\n   * Calculate Order Flow Toxicity\n   */\n  static async calculateOrderFlowToxicity(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<OrderFlowToxicityMetrics> {\n    try {\n      const startTime = new Date(Date.now() - lookbackMinutes * 60 * 1000);\n\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      if (snapshots.length < 10) {\n        throw new BadRequestError('Insufficient data for toxicity calculation');\n      }\n\n      // Calculate effective spread\n      const effectiveSpreads = snapshots.map(s => parseFloat(s.spread || '0'));\n      const effectiveSpread = effectiveSpreads.reduce((sum, val) => sum + val, 0) / effectiveSpreads.length;\n\n      // Calculate price reversals\n      let reversals = 0;\n      for (let i = 1; i < snapshots.length - 1; i++) {\n        const prev = parseFloat(snapshots[i - 1].midPrice || '0');\n        const curr = parseFloat(snapshots[i].midPrice || '0');\n        const next = parseFloat(snapshots[i + 1].midPrice || '0');\n\n        if ((curr > prev && curr > next) || (curr < prev && curr < next)) {\n          reversals++;\n        }\n      }\n      const priceReversal = (reversals / (snapshots.length - 2)) * 100;\n\n      // Calculate realized spread (using 5-minute delay)\n      const realizedSpread = this.calculateRealizedSpread(snapshots);\n\n      // Adverse selection cost = Effective Spread - Realized Spread\n      const adverseSelectionCost = Math.max(0, effectiveSpread - realizedSpread);\n\n      // Price impact\n      const priceImpact = this.calculateAveragePriceImpact(snapshots);\n\n      // Informed trading ratio (higher adverse selection = more informed trading)\n      const informedTradingRatio = effectiveSpread > 0\n        ? adverseSelectionCost / effectiveSpread\n        : 0;\n\n      // Calculate toxicity score (0-100)\n      const toxicityScore = Math.min(100,\n        (adverseSelectionCost / effectiveSpread) * 40 + // 40% weight\n        (priceReversal / 100) * 30 +                    // 30% weight\n        (priceImpact) * 30                              // 30% weight\n      );\n\n      // Toxicity level\n      let toxicityLevel: 'low' | 'medium' | 'high' | 'extreme';\n      if (toxicityScore < 25) toxicityLevel = 'low';\n      else if (toxicityScore < 50) toxicityLevel = 'medium';\n      else if (toxicityScore < 75) toxicityLevel = 'high';\n      else toxicityLevel = 'extreme';\n\n      // Adverse selection risk\n      let adverseSelectionRisk: 'low' | 'medium' | 'high';\n      if (informedTradingRatio < 0.3) adverseSelectionRisk = 'low';\n      else if (informedTradingRatio < 0.6) adverseSelectionRisk = 'medium';\n      else adverseSelectionRisk = 'high';\n\n      // Market maker risk score\n      const marketMakerRisk = toxicityScore * (1 + informedTradingRatio);\n\n      const result: OrderFlowToxicityMetrics = {\n        exchangeId,\n        symbol,\n        timestamp: snapshots[snapshots.length - 1].timestamp,\n        toxicityScore,\n        toxicityLevel,\n        adverseSelectionCost,\n        priceReversal,\n        informedTradingRatio,\n        effectiveSpread,\n        realizedSpread,\n        priceImpact,\n        adverseSelectionRisk,\n        marketMakerRisk,\n      };\n\n      logger.debug('Calculated order flow toxicity', {\n        exchangeId,\n        symbol,\n        toxicityScore: toxicityScore.toFixed(2),\n        toxicityLevel,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate order flow toxicity', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate realized spread\n   */\n  private static calculateRealizedSpread(\n    snapshots: Array<typeof orderBookSnapshots.$inferSelect>\n  ): number {\n    if (snapshots.length < 2) return 0;\n\n    const delays = Math.min(5, snapshots.length - 1);\n    let totalRealizedSpread = 0;\n    let count = 0;\n\n    for (let i = 0; i < snapshots.length - delays; i++) {\n      const current = parseFloat(snapshots[i].midPrice || '0');\n      const future = parseFloat(snapshots[i + delays].midPrice || '0');\n\n      totalRealizedSpread += Math.abs(future - current);\n      count++;\n    }\n\n    return count > 0 ? totalRealizedSpread / count : 0;\n  }\n\n  /**\n   * Calculate average price impact from order book changes\n   */\n  private static calculateAveragePriceImpact(\n    snapshots: Array<typeof orderBookSnapshots.$inferSelect>\n  ): number {\n    if (snapshots.length < 2) return 0;\n\n    let totalImpact = 0;\n    let count = 0;\n\n    for (let i = 1; i < snapshots.length; i++) {\n      const currentPrice = parseFloat(snapshots[i].midPrice || '0');\n      const previousPrice = parseFloat(snapshots[i - 1].midPrice || '0');\n\n      if (previousPrice > 0) {\n        const impact = Math.abs((currentPrice - previousPrice) / previousPrice) * 100;\n        totalImpact += impact;\n        count++;\n      }\n    }\n\n    return count > 0 ? totalImpact / count : 0;\n  }\n\n  /**\n   * Calculate Market Noise Metrics\n   */\n  static async calculateMarketNoise(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<MarketNoiseMetrics> {\n    try {\n      const startTime = new Date(Date.now() - lookbackMinutes * 60 * 1000);\n\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      if (snapshots.length < 10) {\n        throw new BadRequestError('Insufficient data for noise calculation');\n      }\n\n      // Extract mid prices\n      const midPrices = snapshots.map(s => parseFloat(s.midPrice || '0'));\n\n      // Calculate price changes\n      const priceChanges = [];\n      for (let i = 1; i < midPrices.length; i++) {\n        priceChanges.push(midPrices[i] - midPrices[i - 1]);\n      }\n\n      // Calculate autocorrelation (lag-1)\n      const autocorrelation = this.calculateAutocorrelation(priceChanges, 1);\n\n      // Bid-ask bounce variance\n      const bidAskBounce = this.calculateBidAskBounce(snapshots);\n\n      // Efficiency ratio (directional movement / total movement)\n      const efficiencyRatio = this.calculateEfficiencyRatio(midPrices);\n\n      // Noise ratio (inverse of efficiency)\n      const noiseRatio = 1 - efficiencyRatio;\n\n      // Signal to noise ratio\n      const signalToNoise = efficiencyRatio > 0 ? (1 / noiseRatio) : 0;\n\n      // Tick noise (variance due to minimum tick size)\n      const tickNoise = this.calculateTickNoise(midPrices);\n\n      // Quality assessment\n      let priceQuality: 'excellent' | 'good' | 'fair' | 'poor';\n      if (efficiencyRatio > 0.8) priceQuality = 'excellent';\n      else if (efficiencyRatio > 0.6) priceQuality = 'good';\n      else if (efficiencyRatio > 0.4) priceQuality = 'fair';\n      else priceQuality = 'poor';\n\n      const result: MarketNoiseMetrics = {\n        exchangeId,\n        symbol,\n        timestamp: snapshots[snapshots.length - 1].timestamp,\n        noiseRatio,\n        signalToNoise,\n        efficiencyRatio,\n        autocorrelation,\n        bidAskBounce,\n        tickNoise,\n        priceQuality,\n      };\n\n      logger.debug('Calculated market noise', {\n        exchangeId,\n        symbol,\n        noiseRatio: noiseRatio.toFixed(3),\n        priceQuality,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate market noise', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate autocorrelation\n   */\n  private static calculateAutocorrelation(data: number[], lag: number): number {\n    if (data.length < lag + 1) return 0;\n\n    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;\n\n    let numerator = 0;\n    let denominator = 0;\n\n    for (let i = lag; i < data.length; i++) {\n      numerator += (data[i] - mean) * (data[i - lag] - mean);\n    }\n\n    for (let i = 0; i < data.length; i++) {\n      denominator += Math.pow(data[i] - mean, 2);\n    }\n\n    return denominator !== 0 ? numerator / denominator : 0;\n  }\n\n  /**\n   * Calculate bid-ask bounce variance\n   */\n  private static calculateBidAskBounce(\n    snapshots: Array<typeof orderBookSnapshots.$inferSelect>\n  ): number {\n    const spreads = snapshots.map(s => parseFloat(s.spread || '0'));\n\n    if (spreads.length === 0) return 0;\n\n    const mean = spreads.reduce((sum, val) => sum + val, 0) / spreads.length;\n    const variance = spreads.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / spreads.length;\n\n    return Math.sqrt(variance);\n  }\n\n  /**\n   * Calculate efficiency ratio (Kaufman's)\n   */\n  private static calculateEfficiencyRatio(prices: number[]): number {\n    if (prices.length < 2) return 0;\n\n    // Direction: net price change\n    const direction = Math.abs(prices[prices.length - 1] - prices[0]);\n\n    // Volatility: sum of absolute price changes\n    let volatility = 0;\n    for (let i = 1; i < prices.length; i++) {\n      volatility += Math.abs(prices[i] - prices[i - 1]);\n    }\n\n    return volatility !== 0 ? direction / volatility : 0;\n  }\n\n  /**\n   * Calculate tick noise\n   */\n  private static calculateTickNoise(prices: number[]): number {\n    if (prices.length < 2) return 0;\n\n    // Estimate minimum tick size\n    const priceChanges = [];\n    for (let i = 1; i < prices.length; i++) {\n      const change = Math.abs(prices[i] - prices[i - 1]);\n      if (change > 0) {\n        priceChanges.push(change);\n      }\n    }\n\n    if (priceChanges.length === 0) return 0;\n\n    // Minimum non-zero change is likely the tick size\n    const tickSize = Math.min(...priceChanges);\n\n    // Tick noise is the ratio of tick size to average price\n    const avgPrice = prices.reduce((sum, val) => sum + val, 0) / prices.length;\n\n    return avgPrice > 0 ? (tickSize / avgPrice) * 100 : 0;\n  }\n\n  /**\n   * Calculate Kyle's Lambda (Price Impact Coefficient)\n   */\n  static async calculateKyleLambda(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<KyleLambda> {\n    try {\n      const startTime = new Date(Date.now() - lookbackMinutes * 60 * 1000);\n\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      if (snapshots.length < 10) {\n        throw new BadRequestError('Insufficient data for Kyle Lambda calculation');\n      }\n\n      // Regression: price_change = lambda * volume + error\n      const dataPoints: Array<{ priceChange: number; volume: number }> = [];\n\n      for (let i = 1; i < snapshots.length; i++) {\n        const currentPrice = parseFloat(snapshots[i].midPrice || '0');\n        const previousPrice = parseFloat(snapshots[i - 1].midPrice || '0');\n\n        const priceChange = Math.abs(currentPrice - previousPrice);\n\n        const currentBids = snapshots[i].bids as any as OrderBookLevel[];\n        const currentAsks = snapshots[i].asks as any as OrderBookLevel[];\n        const previousBids = snapshots[i - 1].bids as any as OrderBookLevel[];\n        const previousAsks = snapshots[i - 1].asks as any as OrderBookLevel[];\n\n        const volumeChange = Math.abs(\n          this.calculateVolumeChange(currentBids, previousBids) +\n          this.calculateVolumeChange(currentAsks, previousAsks)\n        );\n\n        if (volumeChange > 0 && priceChange > 0) {\n          dataPoints.push({ priceChange, volume: volumeChange });\n        }\n      }\n\n      if (dataPoints.length < 5) {\n        throw new BadRequestError('Insufficient variation for Kyle Lambda');\n      }\n\n      // Simple linear regression\n      const n = dataPoints.length;\n      const sumX = dataPoints.reduce((sum, p) => sum + p.volume, 0);\n      const sumY = dataPoints.reduce((sum, p) => sum + p.priceChange, 0);\n      const sumXY = dataPoints.reduce((sum, p) => sum + p.volume * p.priceChange, 0);\n      const sumX2 = dataPoints.reduce((sum, p) => sum + p.volume * p.volume, 0);\n      const sumY2 = dataPoints.reduce((sum, p) => sum + p.priceChange * p.priceChange, 0);\n\n      // Lambda = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX^2)\n      const lambda = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n\n      // R-squared for confidence\n      const meanY = sumY / n;\n      const ssTotal = sumY2 - n * meanY * meanY;\n      const ssResidual = dataPoints.reduce((sum, p) => {\n        const predicted = lambda * p.volume;\n        return sum + Math.pow(p.priceChange - predicted, 2);\n      }, 0);\n      const rSquared = 1 - (ssResidual / ssTotal);\n\n      // Interpretation\n      let marketDepth: 'deep' | 'moderate' | 'shallow';\n      if (lambda < 0.00001) marketDepth = 'deep';\n      else if (lambda < 0.0001) marketDepth = 'moderate';\n      else marketDepth = 'shallow';\n\n      const liquidityLevel = lambda > 0 ? 1 / lambda : Infinity;\n\n      // Average price change and volume\n      const avgPriceChange = sumY / n;\n      const avgVolume = sumX / n;\n\n      const result: KyleLambda = {\n        exchangeId,\n        symbol,\n        timestamp: snapshots[snapshots.length - 1].timestamp,\n        lambda,\n        marketDepth,\n        liquidityLevel,\n        priceChange: avgPriceChange,\n        volumeTraded: avgVolume,\n        rSquared: Math.max(0, Math.min(1, rSquared)),\n        sampleSize: n,\n      };\n\n      logger.debug('Calculated Kyle Lambda', {\n        exchangeId,\n        symbol,\n        lambda: lambda.toFixed(8),\n        marketDepth,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate Kyle Lambda', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate comprehensive microstructure metrics\n   */\n  static async calculateComprehensiveMetrics(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 60\n  ): Promise<MicrostructureMetricsComplete> {\n    try {\n      // Calculate all metrics in parallel\n      const [vpin, toxicity, noise, kyle] = await Promise.all([\n        this.calculateVPIN(exchangeId, symbol),\n        this.calculateOrderFlowToxicity(exchangeId, symbol, lookbackMinutes),\n        this.calculateMarketNoise(exchangeId, symbol, lookbackMinutes),\n        this.calculateKyleLambda(exchangeId, symbol, lookbackMinutes),\n      ]);\n\n      // Overall quality assessment\n      const qualityScore =\n        (vpin.toxicityLevel === 'low' ? 25 : vpin.toxicityLevel === 'medium' ? 15 : vpin.toxicityLevel === 'high' ? 5 : 0) +\n        (toxicity.toxicityLevel === 'low' ? 25 : toxicity.toxicityLevel === 'medium' ? 15 : toxicity.toxicityLevel === 'high' ? 5 : 0) +\n        (noise.priceQuality === 'excellent' ? 25 : noise.priceQuality === 'good' ? 15 : noise.priceQuality === 'fair' ? 10 : 0) +\n        (kyle.marketDepth === 'deep' ? 25 : kyle.marketDepth === 'moderate' ? 15 : 5);\n\n      let overallQuality: 'excellent' | 'good' | 'fair' | 'poor';\n      if (qualityScore >= 80) overallQuality = 'excellent';\n      else if (qualityScore >= 60) overallQuality = 'good';\n      else if (qualityScore >= 40) overallQuality = 'fair';\n      else overallQuality = 'poor';\n\n      // Trading recommendation\n      let tradingRecommendation: 'favorable' | 'neutral' | 'caution' | 'avoid';\n      if (vpin.vpin > 70 || toxicity.toxicityScore > 75) {\n        tradingRecommendation = 'avoid';\n      } else if (vpin.vpin > 50 || toxicity.toxicityScore > 50) {\n        tradingRecommendation = 'caution';\n      } else if (overallQuality === 'excellent' || overallQuality === 'good') {\n        tradingRecommendation = 'favorable';\n      } else {\n        tradingRecommendation = 'neutral';\n      }\n\n      const result: MicrostructureMetricsComplete = {\n        exchangeId,\n        symbol,\n        timestamp: new Date(),\n        vpin,\n        toxicity,\n        noise,\n        kyle,\n        overallQuality,\n        tradingRecommendation,\n      };\n\n      logger.info('Calculated comprehensive microstructure metrics', {\n        exchangeId,\n        symbol,\n        overallQuality,\n        tradingRecommendation,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate comprehensive metrics', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Store toxicity metrics in database\n   */\n  static async storeToxicityMetrics(\n    metrics: OrderFlowToxicityMetrics\n  ): Promise<void> {\n    try {\n      // Map to schema fields\n      await db.insert(orderFlowToxicity).values({\n        exchangeId: metrics.exchangeId,\n        symbol: metrics.symbol,\n        timestamp: metrics.timestamp,\n        vpin: metrics.toxicityScore.toString(), // Using toxicity score as VPIN\n        volumeBuckets: 50, // Default value\n        buyVolume: '0', // Would come from order flow analysis\n        sellVolume: '0',\n        orderImbalance: metrics.informedTradingRatio.toString(),\n        toxicityLevel: metrics.toxicityScore > 0.7 ? 'high' : metrics.toxicityScore > 0.4 ? 'medium' : 'low',\n      });\n\n      logger.debug('Stored toxicity metrics', {\n        exchangeId: metrics.exchangeId,\n        symbol: metrics.symbol,\n      });\n    } catch (error) {\n      logger.error('Failed to store toxicity metrics', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Store microstructure metrics in database\n   */\n  static async storeMicrostructureMetrics(\n    metrics: MicrostructureMetricsComplete\n  ): Promise<void> {\n    try {\n      // Map to schema fields\n      await db.insert(microstructureMetrics).values({\n        exchangeId: metrics.exchangeId,\n        symbol: metrics.symbol,\n        timestamp: metrics.timestamp,\n        intervalMinutes: 1, // Default 1 minute interval\n        totalOrders: 0, // Would come from order tracking\n        totalCancels: 0,\n        cancelRate: '0',\n        averageSpread: '0',\n        averageDepth: '0',\n        depthVolatility: '0',\n        priceVolatility: '0',\n        returnVariance: '0',\n        microstructureNoise: metrics.noise.bidAskBounce.toString(),\n        effectiveSpread: metrics.toxicity.effectiveSpread.toString(),\n        realizedSpread: metrics.toxicity.realizedSpread.toString(),\n        averageQueuePosition: '0',\n        queueJumps: 0,\n      });\n\n      logger.debug('Stored microstructure metrics', {\n        exchangeId: metrics.exchangeId,\n        symbol: metrics.symbol,\n      });\n    } catch (error) {\n      logger.error('Failed to store microstructure metrics', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/order-book-aggregator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'orderBookSnapshots' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'analytics' is defined but never used. Allowed unused args must match /^_/u.","line":635,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":635,"endColumn":62}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Book Aggregator Service\n * Multi-exchange order book aggregation and smart order routing\n *\n * Features:\n * - Multi-exchange order book merging\n * - Smart order routing (SOR)\n * - Best execution price discovery\n * - Cross-exchange arbitrage detection\n * - Liquidity aggregation\n * - Exchange quality scoring\n * - Routing optimization\n *\n * Benefits:\n * - Deeper liquidity pool\n * - Better execution prices\n * - Reduced slippage\n * - Arbitrage opportunities\n * - Risk diversification\n */\n\nimport { db } from '@/db';\nimport { eq, and, inArray } from 'drizzle-orm';\nimport { orderBookSnapshots } from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport { OrderBookAnalyticsService } from './order-book-analytics.service';\nimport { PriceImpactService } from './price-impact.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type { OrderBookSnapshot, OrderBookLevel } from '../types/order-book.types';\n\n/**\n * Aggregated Order Book\n */\nexport interface AggregatedOrderBook {\n  symbol: string;\n  timestamp: Date;\n\n  // Aggregated levels\n  bids: Array<OrderBookLevel & { exchanges: string[] }>;\n  asks: Array<OrderBookLevel & { exchanges: string[] }>;\n\n  // Best prices across all exchanges\n  bestBid: number;\n  bestAsk: number;\n  bestBidExchange: string;\n  bestAskExchange: string;\n\n  // Aggregated metrics\n  totalBidDepth: number;\n  totalAskDepth: number;\n  avgSpread: number;\n  tightestSpread: number;\n\n  // Exchange coverage\n  exchanges: string[];\n  exchangeCount: number;\n}\n\n/**\n * Smart Order Routing Plan\n */\nexport interface SmartOrderRoutingPlan {\n  symbol: string;\n  timestamp: Date;\n\n  // Order details\n  side: 'buy' | 'sell';\n  targetSize: number;\n  targetSizeUSD: number;\n\n  // Routing plan\n  routes: Array<{\n    exchange: string;\n    size: number;\n    sizeUSD: number;\n    price: number;\n    percentage: number; // % of total order\n    estimatedFee: number;\n  }>;\n\n  // Execution summary\n  averagePrice: number;\n  totalFees: number;\n  estimatedSlippage: number;\n  estimatedImpact: number;\n\n  // Comparison\n  bestSingleExchange: string;\n  bestSinglePrice: number;\n  improvementVsSingle: number; // % better price\n  savingsUSD: number;\n}\n\n/**\n * Cross-Exchange Arbitrage Opportunity\n */\nexport interface ArbitrageOpportunity {\n  symbol: string;\n  timestamp: Date;\n\n  // Buy side\n  buyExchange: string;\n  buyPrice: number;\n  buySize: number;\n\n  // Sell side\n  sellExchange: string;\n  sellPrice: number;\n  sellSize: number;\n\n  // Profit analysis\n  profitPercent: number;\n  profitUSD: number;\n  maxSize: number; // Max tradeable size\n\n  // Costs\n  buyFee: number;\n  sellFee: number;\n  transferCost: number;\n  netProfit: number;\n  netProfitPercent: number;\n\n  // Quality\n  confidence: number; // 0-100\n  executionRisk: 'low' | 'medium' | 'high';\n}\n\n/**\n * Exchange Quality Score\n */\nexport interface ExchangeQualityScore {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Quality metrics\n  liquidityScore: number; // 0-100\n  spreadScore: number; // 0-100 (tighter = better)\n  depthScore: number; // 0-100\n  stabilityScore: number; // 0-100\n\n  // Overall score\n  overallScore: number; // Weighted average\n  qualityTier: 'tier1' | 'tier2' | 'tier3' | 'tier4';\n\n  // Ranking\n  rank: number; // Among all exchanges for this symbol\n}\n\n/**\n * Liquidity Distribution\n */\nexport interface LiquidityDistribution {\n  symbol: string;\n  timestamp: Date;\n\n  // Per-exchange breakdown\n  exchanges: Array<{\n    exchangeId: string;\n    bidLiquidity: number;\n    askLiquidity: number;\n    totalLiquidity: number;\n    marketShare: number; // %\n  }>;\n\n  // Concentration metrics\n  herfindahlIndex: number; // 0-10000 (lower = more distributed)\n  top3Concentration: number; // % held by top 3 exchanges\n  effectiveExchangeCount: number; // Accounting for concentration\n}\n\nexport class OrderBookAggregatorService {\n  /**\n   * Aggregate order books from multiple exchanges\n   */\n  static async aggregateOrderBooks(\n    exchangeIds: string[],\n    symbol: string\n  ): Promise<AggregatedOrderBook> {\n    try {\n      if (exchangeIds.length === 0) {\n        throw new BadRequestError('At least one exchange required');\n      }\n\n      // Fetch order books from all exchanges in parallel\n      const snapshots = await Promise.all(\n        exchangeIds.map(async (exchangeId) => {\n          try {\n            return await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n          } catch (error) {\n            logger.warn('Failed to fetch order book', { exchangeId, symbol });\n            return null;\n          }\n        })\n      );\n\n      // Filter out failed fetches\n      const validSnapshots = snapshots.filter((s): s is OrderBookSnapshot => s !== null);\n\n      if (validSnapshots.length === 0) {\n        throw new BadRequestError('No order book data available from any exchange');\n      }\n\n      // Merge order books\n      const allBids: Array<OrderBookLevel & { exchange: string }> = [];\n      const allAsks: Array<OrderBookLevel & { exchange: string }> = [];\n\n      validSnapshots.forEach((snapshot, index) => {\n        const exchangeId = exchangeIds[index];\n\n        snapshot.bids.forEach(bid => {\n          allBids.push({ ...bid, exchange: exchangeId });\n        });\n\n        snapshot.asks.forEach(ask => {\n          allAsks.push({ ...ask, exchange: exchangeId });\n        });\n      });\n\n      // Sort bids (highest first) and asks (lowest first)\n      allBids.sort((a, b) => b.price - a.price);\n      allAsks.sort((a, b) => a.price - b.price);\n\n      // Aggregate levels at same price\n      const aggregatedBids = this.aggregateLevels(allBids);\n      const aggregatedAsks = this.aggregateLevels(allAsks);\n\n      // Find best prices\n      const bestBid = allBids[0]?.price || 0;\n      const bestAsk = allAsks[0]?.price || 0;\n      const bestBidExchange = allBids[0]?.exchange || '';\n      const bestAskExchange = allAsks[0]?.exchange || '';\n\n      // Calculate metrics\n      const totalBidDepth = allBids.reduce((sum, b) => sum + b.price * b.amount, 0);\n      const totalAskDepth = allAsks.reduce((sum, a) => sum + a.price * a.amount, 0);\n\n      const spreads = validSnapshots\n        .map(s => typeof s.spread === 'string' ? parseFloat(s.spread || '0') : (s.spread || 0))\n        .filter(s => s > 0);\n\n      const avgSpread = spreads.length > 0\n        ? spreads.reduce((sum, s) => sum + s, 0) / spreads.length\n        : 0;\n\n      const tightestSpread = spreads.length > 0\n        ? Math.min(...spreads)\n        : 0;\n\n      const result: AggregatedOrderBook = {\n        symbol,\n        timestamp: new Date(),\n        bids: aggregatedBids,\n        asks: aggregatedAsks,\n        bestBid,\n        bestAsk,\n        bestBidExchange,\n        bestAskExchange,\n        totalBidDepth,\n        totalAskDepth,\n        avgSpread,\n        tightestSpread,\n        exchanges: exchangeIds.filter((_, i) => validSnapshots[i] !== null),\n        exchangeCount: validSnapshots.length,\n      };\n\n      logger.info('Aggregated order books', {\n        symbol,\n        exchanges: result.exchangeCount,\n        bestBid,\n        bestAsk,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to aggregate order books', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Aggregate levels at the same price\n   */\n  private static aggregateLevels(\n    levels: Array<OrderBookLevel & { exchange: string }>\n  ): Array<OrderBookLevel & { exchanges: string[] }> {\n    const priceMap = new Map<number, { amount: number; exchanges: Set<string> }>();\n\n    levels.forEach(level => {\n      const existing = priceMap.get(level.price);\n\n      if (existing) {\n        existing.amount += level.amount;\n        existing.exchanges.add(level.exchange);\n      } else {\n        priceMap.set(level.price, {\n          amount: level.amount,\n          exchanges: new Set([level.exchange]),\n        });\n      }\n    });\n\n    return Array.from(priceMap.entries())\n      .map(([price, data]) => ({\n        price,\n        amount: data.amount,\n        exchanges: Array.from(data.exchanges),\n      }))\n      .sort((a, b) => b.price - a.price);\n  }\n\n  /**\n   * Calculate smart order routing plan\n   */\n  static async calculateSmartRouting(\n    exchangeIds: string[],\n    symbol: string,\n    side: 'buy' | 'sell',\n    targetSize: number,\n    feeRates?: Map<string, number> // Exchange ID -> fee rate (0.001 = 0.1%)\n  ): Promise<SmartOrderRoutingPlan> {\n    try {\n      // Get aggregated order book\n      const aggregated = await this.aggregateOrderBooks(exchangeIds, symbol);\n\n      // Select appropriate side\n      const levels = side === 'buy' ? aggregated.asks : aggregated.bids;\n\n      // Default fee rate: 0.1%\n      const defaultFeeRate = 0.001;\n      const getFeeRate = (exchange: string) =>\n        feeRates?.get(exchange) || defaultFeeRate;\n\n      // Walk through aggregated book to fill order\n      let remainingSize = targetSize;\n      const routes: SmartOrderRoutingPlan['routes'] = [];\n\n      for (const level of levels) {\n        if (remainingSize <= 0) break;\n\n        const fillSize = Math.min(remainingSize, level.amount);\n        const sizeUSD = level.price * fillSize;\n\n        // Distribute across exchanges at this price level\n        const exchangeShare = fillSize / level.exchanges.length;\n\n        level.exchanges.forEach(exchange => {\n          const fee = sizeUSD * getFeeRate(exchange) / level.exchanges.length;\n\n          routes.push({\n            exchange,\n            size: exchangeShare,\n            sizeUSD: sizeUSD / level.exchanges.length,\n            price: level.price,\n            percentage: (exchangeShare / targetSize) * 100,\n            estimatedFee: fee,\n          });\n        });\n\n        remainingSize -= fillSize;\n      }\n\n      if (remainingSize > 0) {\n        logger.warn('Insufficient aggregated liquidity', {\n          symbol,\n          requested: targetSize,\n          available: targetSize - remainingSize,\n        });\n      }\n\n      // Calculate summary metrics\n      const totalCost = routes.reduce((sum, r) => sum + r.sizeUSD, 0);\n      const totalFees = routes.reduce((sum, r) => sum + r.estimatedFee, 0);\n      const averagePrice = totalCost / targetSize;\n\n      // Compare to best single exchange\n      const bestSingleExchange = side === 'buy'\n        ? aggregated.bestAskExchange\n        : aggregated.bestBidExchange;\n\n      const bestSinglePrice = side === 'buy'\n        ? aggregated.bestAsk\n        : aggregated.bestBid;\n\n      // Estimate single exchange execution\n      let singleExchangeCost = 0;\n      try {\n        const singleImpact = await PriceImpactService.estimatePriceImpact(\n          bestSingleExchange,\n          symbol,\n          side,\n          targetSize\n        );\n        singleExchangeCost = singleImpact.orderSizeUSD;\n      } catch (error) {\n        singleExchangeCost = bestSinglePrice * targetSize;\n      }\n\n      const savingsUSD = Math.abs(singleExchangeCost - totalCost);\n      const improvementVsSingle = (savingsUSD / singleExchangeCost) * 100;\n\n      const result: SmartOrderRoutingPlan = {\n        symbol,\n        timestamp: new Date(),\n        side,\n        targetSize,\n        targetSizeUSD: totalCost,\n        routes,\n        averagePrice,\n        totalFees,\n        estimatedSlippage: Math.abs(averagePrice - bestSinglePrice),\n        estimatedImpact: ((averagePrice - bestSinglePrice) / bestSinglePrice) * 100,\n        bestSingleExchange,\n        bestSinglePrice,\n        improvementVsSingle,\n        savingsUSD,\n      };\n\n      logger.info('Calculated smart routing plan', {\n        symbol,\n        routes: routes.length,\n        savingsUSD: savingsUSD.toFixed(2),\n        improvement: improvementVsSingle.toFixed(2),\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate smart routing', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Detect arbitrage opportunities across exchanges\n   */\n  static async detectArbitrage(\n    exchangeIds: string[],\n    symbol: string,\n    minProfitPercent: number = 0.5\n  ): Promise<ArbitrageOpportunity[]> {\n    try {\n      if (exchangeIds.length < 2) {\n        throw new BadRequestError('At least 2 exchanges required for arbitrage');\n      }\n\n      // Fetch all order books\n      const snapshots = await Promise.all(\n        exchangeIds.map(async (exchangeId) => {\n          try {\n            const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n            return { exchangeId, snapshot };\n          } catch (error) {\n            return null;\n          }\n        })\n      );\n\n      const validSnapshots = snapshots.filter(\n        (s): s is { exchangeId: string; snapshot: OrderBookSnapshot } => s !== null\n      );\n\n      if (validSnapshots.length < 2) {\n        throw new BadRequestError('Need at least 2 exchanges with data');\n      }\n\n      const opportunities: ArbitrageOpportunity[] = [];\n\n      // Compare all exchange pairs\n      for (let i = 0; i < validSnapshots.length; i++) {\n        for (let j = i + 1; j < validSnapshots.length; j++) {\n          const exchange1 = validSnapshots[i];\n          const exchange2 = validSnapshots[j];\n\n          // Check both directions\n          const opp1 = this.checkArbitragePair(\n            exchange1.exchangeId,\n            exchange1.snapshot,\n            exchange2.exchangeId,\n            exchange2.snapshot,\n            symbol,\n            minProfitPercent\n          );\n\n          const opp2 = this.checkArbitragePair(\n            exchange2.exchangeId,\n            exchange2.snapshot,\n            exchange1.exchangeId,\n            exchange1.snapshot,\n            symbol,\n            minProfitPercent\n          );\n\n          if (opp1) opportunities.push(opp1);\n          if (opp2) opportunities.push(opp2);\n        }\n      }\n\n      // Sort by net profit percent\n      opportunities.sort((a, b) => b.netProfitPercent - a.netProfitPercent);\n\n      logger.info('Detected arbitrage opportunities', {\n        symbol,\n        opportunities: opportunities.length,\n      });\n\n      return opportunities;\n    } catch (error) {\n      logger.error('Failed to detect arbitrage', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check arbitrage between two exchanges\n   */\n  private static checkArbitragePair(\n    buyExchangeId: string,\n    buySnapshot: OrderBookSnapshot,\n    sellExchangeId: string,\n    sellSnapshot: OrderBookSnapshot,\n    symbol: string,\n    minProfitPercent: number\n  ): ArbitrageOpportunity | null {\n    const buyPrice = typeof buySnapshot.bestAsk === 'string'\n      ? parseFloat(buySnapshot.bestAsk || '0')\n      : (buySnapshot.bestAsk || 0);\n    const sellPrice = typeof sellSnapshot.bestBid === 'string'\n      ? parseFloat(sellSnapshot.bestBid || '0')\n      : (sellSnapshot.bestBid || 0);\n\n    if (buyPrice === 0 || sellPrice === 0) return null;\n\n    // Profit opportunity if sell > buy\n    const profitPercent = ((sellPrice - buyPrice) / buyPrice) * 100;\n\n    if (profitPercent < minProfitPercent) return null;\n\n    // Max tradeable size (limited by both sides)\n    const buySize = buySnapshot.asks[0]?.amount || 0;\n    const sellSize = sellSnapshot.bids[0]?.amount || 0;\n    const maxSize = Math.min(buySize, sellSize);\n\n    // Estimate fees (0.1% typical)\n    const buyFee = buyPrice * maxSize * 0.001;\n    const sellFee = sellPrice * maxSize * 0.001;\n    const transferCost = 0; // Would depend on blockchain/network\n\n    const profitUSD = (sellPrice - buyPrice) * maxSize;\n    const netProfit = profitUSD - buyFee - sellFee - transferCost;\n    const netProfitPercent = (netProfit / (buyPrice * maxSize)) * 100;\n\n    // Confidence based on spread tightness and size\n    const spreadBuy = typeof buySnapshot.spreadPercent === 'string'\n      ? parseFloat(buySnapshot.spreadPercent || '0')\n      : (buySnapshot.spreadPercent || 0);\n    const spreadSell = typeof sellSnapshot.spreadPercent === 'string'\n      ? parseFloat(sellSnapshot.spreadPercent || '0')\n      : (sellSnapshot.spreadPercent || 0);\n    const avgSpread = (spreadBuy + spreadSell) / 2;\n\n    const confidence = Math.min(100,\n      (profitPercent / minProfitPercent) * 40 +\n      Math.max(0, 100 - avgSpread * 100) * 30 +\n      (maxSize > 1 ? 30 : maxSize * 30)\n    );\n\n    // Execution risk\n    let executionRisk: 'low' | 'medium' | 'high';\n    if (confidence > 70 && maxSize > 1) executionRisk = 'low';\n    else if (confidence > 50 && maxSize > 0.1) executionRisk = 'medium';\n    else executionRisk = 'high';\n\n    return {\n      symbol,\n      timestamp: new Date(),\n      buyExchange: buyExchangeId,\n      buyPrice,\n      buySize: maxSize,\n      sellExchange: sellExchangeId,\n      sellPrice,\n      sellSize: maxSize,\n      profitPercent,\n      profitUSD,\n      maxSize,\n      buyFee,\n      sellFee,\n      transferCost,\n      netProfit,\n      netProfitPercent,\n      confidence,\n      executionRisk,\n    };\n  }\n\n  /**\n   * Score exchange quality for a symbol\n   */\n  static async scoreExchangeQuality(\n    exchangeIds: string[],\n    symbol: string\n  ): Promise<ExchangeQualityScore[]> {\n    try {\n      const scores: ExchangeQualityScore[] = [];\n\n      // Fetch snapshots and analytics for all exchanges\n      const results = await Promise.all(\n        exchangeIds.map(async (exchangeId) => {\n          try {\n            const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n            if (!snapshot) return null;\n\n            const analytics = OrderBookAnalyticsService.generateDOMDisplayData(snapshot);\n\n            return { exchangeId, snapshot, analytics };\n          } catch (error) {\n            return null;\n          }\n        })\n      );\n\n      const validResults = results.filter((r): r is NonNullable<typeof r> => r !== null);\n\n      if (validResults.length === 0) {\n        throw new BadRequestError('No exchange data available');\n      }\n\n      // Calculate scores for each exchange\n      validResults.forEach(({ exchangeId, snapshot, analytics }) => {\n        // Liquidity score (based on depth)\n        const bidDepth50 = typeof snapshot.bidDepth50 === 'string'\n          ? parseFloat(snapshot.bidDepth50 || '0')\n          : (snapshot.bidDepth50 || 0);\n        const askDepth50 = typeof snapshot.askDepth50 === 'string'\n          ? parseFloat(snapshot.askDepth50 || '0')\n          : (snapshot.askDepth50 || 0);\n        const totalDepth = bidDepth50 + askDepth50;\n        const liquidityScore = Math.min(100, (totalDepth / 1000000) * 100);\n\n        // Spread score (tighter = better)\n        const spreadPercent = typeof snapshot.spreadPercent === 'string'\n          ? parseFloat(snapshot.spreadPercent || '1')\n          : (snapshot.spreadPercent || 1);\n        const spreadScore = Math.max(0, 100 - spreadPercent * 1000);\n\n        // Depth score (how many levels)\n        const depthScore = Math.min(100,\n          ((snapshot.bids.length + snapshot.asks.length) / 100) * 100\n        );\n\n        // Stability score (inverse of volatility)\n        const stabilityScore = 75; // Would require historical data\n\n        // Overall score (weighted)\n        const overallScore =\n          liquidityScore * 0.4 +\n          spreadScore * 0.3 +\n          depthScore * 0.2 +\n          stabilityScore * 0.1;\n\n        // Quality tier\n        let qualityTier: 'tier1' | 'tier2' | 'tier3' | 'tier4';\n        if (overallScore >= 80) qualityTier = 'tier1';\n        else if (overallScore >= 60) qualityTier = 'tier2';\n        else if (overallScore >= 40) qualityTier = 'tier3';\n        else qualityTier = 'tier4';\n\n        scores.push({\n          exchangeId,\n          symbol,\n          timestamp: snapshot.timestamp,\n          liquidityScore,\n          spreadScore,\n          depthScore,\n          stabilityScore,\n          overallScore,\n          qualityTier,\n          rank: 0, // Will be set after sorting\n        });\n      });\n\n      // Rank exchanges\n      scores.sort((a, b) => b.overallScore - a.overallScore);\n      scores.forEach((score, index) => {\n        score.rank = index + 1;\n      });\n\n      logger.info('Scored exchange quality', {\n        symbol,\n        exchanges: scores.length,\n      });\n\n      return scores;\n    } catch (error) {\n      logger.error('Failed to score exchange quality', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Analyze liquidity distribution across exchanges\n   */\n  static async analyzeLiquidityDistribution(\n    exchangeIds: string[],\n    symbol: string\n  ): Promise<LiquidityDistribution> {\n    try {\n      const snapshots = await Promise.all(\n        exchangeIds.map(async (exchangeId) => {\n          try {\n            const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n            return { exchangeId, snapshot };\n          } catch (error) {\n            return null;\n          }\n        })\n      );\n\n      const validSnapshots = snapshots.filter(\n        (s): s is { exchangeId: string; snapshot: OrderBookSnapshot } => s !== null\n      );\n\n      if (validSnapshots.length === 0) {\n        throw new BadRequestError('No exchange data available');\n      }\n\n      // Calculate liquidity per exchange\n      const exchanges = validSnapshots.map(({ exchangeId, snapshot }) => {\n        const bidLiquidity = snapshot.bids.reduce((sum, b) => sum + b.price * b.amount, 0);\n        const askLiquidity = snapshot.asks.reduce((sum, a) => sum + a.price * a.amount, 0);\n        const totalLiquidity = bidLiquidity + askLiquidity;\n\n        return {\n          exchangeId,\n          bidLiquidity,\n          askLiquidity,\n          totalLiquidity,\n          marketShare: 0, // Will calculate after total\n        };\n      });\n\n      // Calculate market shares\n      const totalMarketLiquidity = exchanges.reduce((sum, e) => sum + e.totalLiquidity, 0);\n\n      exchanges.forEach(exchange => {\n        exchange.marketShare = totalMarketLiquidity > 0\n          ? (exchange.totalLiquidity / totalMarketLiquidity) * 100\n          : 0;\n      });\n\n      // Sort by liquidity\n      exchanges.sort((a, b) => b.totalLiquidity - a.totalLiquidity);\n\n      // Calculate concentration metrics\n      // Herfindahl-Hirschman Index (HHI)\n      const herfindahlIndex = exchanges.reduce((sum, e) => {\n        return sum + Math.pow(e.marketShare, 2);\n      }, 0);\n\n      // Top 3 concentration\n      const top3Concentration = exchanges\n        .slice(0, 3)\n        .reduce((sum, e) => sum + e.marketShare, 0);\n\n      // Effective number of exchanges\n      const effectiveExchangeCount = herfindahlIndex > 0\n        ? 10000 / herfindahlIndex\n        : exchanges.length;\n\n      const result: LiquidityDistribution = {\n        symbol,\n        timestamp: new Date(),\n        exchanges,\n        herfindahlIndex,\n        top3Concentration,\n        effectiveExchangeCount,\n      };\n\n      logger.info('Analyzed liquidity distribution', {\n        symbol,\n        exchanges: exchanges.length,\n        herfindahlIndex: herfindahlIndex.toFixed(2),\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to analyze liquidity distribution', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get best execution venue for order\n   */\n  static async getBestExecutionVenue(\n    exchangeIds: string[],\n    symbol: string,\n    side: 'buy' | 'sell',\n    orderSize: number\n  ): Promise<{\n    bestExchange: string;\n    reason: string;\n    estimatedImpact: number;\n    alternatives: Array<{ exchange: string; impact: number }>;\n  }> {\n    try {\n      // Score all exchanges for this order\n      const impacts = await Promise.all(\n        exchangeIds.map(async (exchangeId) => {\n          try {\n            const impact = await PriceImpactService.estimatePriceImpact(\n              exchangeId,\n              symbol,\n              side,\n              orderSize\n            );\n\n            return {\n              exchange: exchangeId,\n              impact: impact.impactPercent,\n            };\n          } catch (error) {\n            return {\n              exchange: exchangeId,\n              impact: Infinity,\n            };\n          }\n        })\n      );\n\n      // Filter out failed exchanges\n      const validImpacts = impacts.filter(i => i.impact !== Infinity);\n\n      if (validImpacts.length === 0) {\n        throw new BadRequestError('No exchange can handle this order');\n      }\n\n      // Sort by impact (lowest first)\n      validImpacts.sort((a, b) => a.impact - b.impact);\n\n      const bestExchange = validImpacts[0].exchange;\n      const estimatedImpact = validImpacts[0].impact;\n\n      let reason = 'Lowest price impact';\n      if (estimatedImpact < 0.1) {\n        reason = 'Excellent liquidity, minimal impact';\n      } else if (estimatedImpact < 0.5) {\n        reason = 'Good liquidity, low impact';\n      } else if (estimatedImpact < 1.0) {\n        reason = 'Moderate impact, best available';\n      } else {\n        reason = 'High impact, consider splitting order';\n      }\n\n      return {\n        bestExchange,\n        reason,\n        estimatedImpact,\n        alternatives: validImpacts.slice(1, 4), // Top 3 alternatives\n      };\n    } catch (error) {\n      logger.error('Failed to get best execution venue', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/order-book-analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'minPrice' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":326,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":326,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'maxPrice' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":327,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":327,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Book Analytics Service\n * Advanced analytics for order book data\n *\n * Features:\n * - Depth analysis (multi-level)\n * - Spread analysis (absolute, relative, effective)\n * - Volume distribution analysis\n * - Liquidity scoring\n * - Depth chart data generation\n * - DOM (Depth of Market) display data\n * - Statistical analysis\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte, sql } from 'drizzle-orm';\nimport { orderBookSnapshots, liquidityScores } from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type {\n  OrderBookSnapshot,\n  OrderBookLevel,\n  DepthChartData,\n  DOMDisplayData,\n  DOMLevelData,\n  LiquidityScore,\n} from '../types/order-book.types';\n\nexport class OrderBookAnalyticsService {\n  /**\n   * Analyze order book depth at multiple levels\n   */\n  static analyzeDepth(\n    snapshot: OrderBookSnapshot\n  ): {\n    depth5: { bid: number; ask: number; total: number; imbalance: number };\n    depth10: { bid: number; ask: number; total: number; imbalance: number };\n    depth20: { bid: number; ask: number; total: number; imbalance: number };\n    depth50: { bid: number; ask: number; total: number; imbalance: number };\n    depth100: { bid: number; ask: number; total: number; imbalance: number };\n  } {\n    const calculateDepthAtLevel = (levels: number) => {\n      const bidDepth = this.calculateDepth(snapshot.bids.slice(0, levels));\n      const askDepth = this.calculateDepth(snapshot.asks.slice(0, levels));\n      const total = bidDepth + askDepth;\n      const imbalance = total > 0 ? (bidDepth - askDepth) / total : 0;\n\n      return { bid: bidDepth, ask: askDepth, total, imbalance };\n    };\n\n    return {\n      depth5: calculateDepthAtLevel(5),\n      depth10: calculateDepthAtLevel(10),\n      depth20: calculateDepthAtLevel(20),\n      depth50: calculateDepthAtLevel(50),\n      depth100: calculateDepthAtLevel(100),\n    };\n  }\n\n  /**\n   * Analyze spread metrics\n   */\n  static analyzeSpread(snapshot: OrderBookSnapshot): {\n    absolute: number;\n    percent: number;\n    bps: number; // Basis points\n    midPrice: number;\n    effectiveSpread?: number;\n  } {\n    const bestBid = snapshot.bestBid || snapshot.bids[0]?.price || 0;\n    const bestAsk = snapshot.bestAsk || snapshot.asks[0]?.price || 0;\n\n    const absolute = bestAsk - bestBid;\n    const midPrice = (bestBid + bestAsk) / 2;\n    const percent = bestBid > 0 ? (absolute / bestBid) * 100 : 0;\n    const bps = percent * 100; // 1% = 100 bps\n\n    return {\n      absolute,\n      percent,\n      bps,\n      midPrice,\n    };\n  }\n\n  /**\n   * Calculate volume distribution across price levels\n   */\n  static analyzeVolumeDistribution(snapshot: OrderBookSnapshot): {\n    bid: {\n      totalVolume: number;\n      averageSize: number;\n      weightedAveragePrice: number;\n      concentrationIndex: number; // Gini coefficient\n    };\n    ask: {\n      totalVolume: number;\n      averageSize: number;\n      weightedAveragePrice: number;\n      concentrationIndex: number;\n    };\n  } {\n    const analyzeSide = (levels: OrderBookLevel[]) => {\n      const totalVolume = levels.reduce((sum, level) => sum + level.amount, 0);\n      const averageSize = levels.length > 0 ? totalVolume / levels.length : 0;\n\n      // Weighted average price\n      const totalValue = levels.reduce((sum, level) => sum + level.price * level.amount, 0);\n      const weightedAveragePrice = totalVolume > 0 ? totalValue / totalVolume : 0;\n\n      // Concentration index (simplified Gini coefficient)\n      // Measures how concentrated the volume is (0 = uniform, 1 = concentrated)\n      const sortedAmounts = levels.map((l) => l.amount).sort((a, b) => a - b);\n      const n = sortedAmounts.length;\n      let sumOfDifferences = 0;\n      for (let i = 0; i < n; i++) {\n        sumOfDifferences += (2 * (i + 1) - n - 1) * sortedAmounts[i];\n      }\n      const concentrationIndex =\n        n > 0 && totalVolume > 0 ? sumOfDifferences / (n * totalVolume) : 0;\n\n      return {\n        totalVolume,\n        averageSize,\n        weightedAveragePrice,\n        concentrationIndex,\n      };\n    };\n\n    return {\n      bid: analyzeSide(snapshot.bids),\n      ask: analyzeSide(snapshot.asks),\n    };\n  }\n\n  /**\n   * Calculate liquidity score (0-100)\n   */\n  static calculateLiquidityScore(snapshot: OrderBookSnapshot): LiquidityScore {\n    const depth = this.analyzeDepth(snapshot);\n    const spread = this.analyzeSpread(snapshot);\n\n    // Component scores (0-100)\n\n    // 1. Depth Score - based on total depth (normalized)\n    // Assume $100k depth = 50 score, $1M depth = 100 score\n    const depthScore = Math.min(100, (depth.depth50.total / 1000000) * 100);\n\n    // 2. Spread Score - tighter spread = higher score\n    // 0.01% spread = 100, 1% spread = 0\n    const spreadScore = Math.max(0, 100 - spread.percent * 100);\n\n    // 3. Volume Score - based on average order size\n    const volumeDistribution = this.analyzeVolumeDistribution(snapshot);\n    const avgVolume =\n      (volumeDistribution.bid.totalVolume + volumeDistribution.ask.totalVolume) / 2;\n    const volumeScore = Math.min(100, (avgVolume / 100) * 100); // Normalized to 100 BTC\n\n    // 4. Stability Score - based on bid-ask balance\n    const stabilityScore = Math.max(0, 100 - Math.abs(depth.depth10.imbalance) * 200);\n\n    // Overall score (weighted average)\n    const score =\n      depthScore * 0.3 + // 30% weight\n      spreadScore * 0.3 + // 30% weight\n      volumeScore * 0.2 + // 20% weight\n      stabilityScore * 0.2; // 20% weight\n\n    // Determine regime\n    let regime: 'abundant' | 'normal' | 'scarce' | 'crisis';\n    if (score >= 80) regime = 'abundant';\n    else if (score >= 60) regime = 'normal';\n    else if (score >= 40) regime = 'scarce';\n    else regime = 'crisis';\n\n    return {\n      exchangeId: snapshot.exchangeId,\n      symbol: snapshot.symbol,\n      timestamp: snapshot.timestamp,\n      score,\n      depthScore,\n      spreadScore,\n      volumeScore,\n      stabilityScore,\n      regime,\n      bidDepth: depth.depth50.bid,\n      askDepth: depth.depth50.ask,\n      spread: spread.absolute,\n    };\n  }\n\n  /**\n   * Store liquidity score\n   */\n  static async storeLiquidityScore(score: LiquidityScore): Promise<void> {\n    try {\n      await db.insert(liquidityScores).values({\n        exchangeId: score.exchangeId,\n        symbol: score.symbol,\n        timestamp: score.timestamp,\n        score: score.score.toString(),\n        depthScore: score.depthScore?.toString(),\n        spreadScore: score.spreadScore?.toString(),\n        volumeScore: score.volumeScore?.toString(),\n        stabilityScore: score.stabilityScore?.toString(),\n        regime: score.regime,\n        bidDepth: score.bidDepth?.toString(),\n        askDepth: score.askDepth?.toString(),\n        spread: score.spread?.toString(),\n      });\n\n      logger.debug('Stored liquidity score', {\n        exchangeId: score.exchangeId,\n        symbol: score.symbol,\n        score: score.score.toFixed(2),\n        regime: score.regime,\n      });\n    } catch (error) {\n      logger.error('Failed to store liquidity score', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get latest liquidity score\n   */\n  static async getLatestLiquidityScore(\n    exchangeId: string,\n    symbol: string\n  ): Promise<LiquidityScore | null> {\n    try {\n      const [result] = await db\n        .select()\n        .from(liquidityScores)\n        .where(\n          and(eq(liquidityScores.exchangeId, exchangeId), eq(liquidityScores.symbol, symbol))\n        )\n        .orderBy(desc(liquidityScores.timestamp))\n        .limit(1);\n\n      if (!result) return null;\n\n      return {\n        id: result.id,\n        exchangeId: result.exchangeId,\n        symbol: result.symbol,\n        timestamp: result.timestamp,\n        score: parseFloat(result.score),\n        depthScore: result.depthScore ? parseFloat(result.depthScore) : undefined,\n        spreadScore: result.spreadScore ? parseFloat(result.spreadScore) : undefined,\n        volumeScore: result.volumeScore ? parseFloat(result.volumeScore) : undefined,\n        stabilityScore: result.stabilityScore ? parseFloat(result.stabilityScore) : undefined,\n        regime: result.regime as 'abundant' | 'normal' | 'scarce' | 'crisis',\n        bidDepth: result.bidDepth ? parseFloat(result.bidDepth) : undefined,\n        askDepth: result.askDepth ? parseFloat(result.askDepth) : undefined,\n        spread: result.spread ? parseFloat(result.spread) : undefined,\n        createdAt: result.createdAt,\n      };\n    } catch (error) {\n      logger.error('Failed to get latest liquidity score', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate depth chart data for visualization\n   */\n  static generateDepthChartData(snapshot: OrderBookSnapshot): DepthChartData {\n    // Calculate cumulative depth for bids (descending)\n    let cumulativeBid = 0;\n    const bids = snapshot.bids.map((level) => {\n      cumulativeBid += level.price * level.amount;\n      return {\n        price: level.price,\n        cumulative: cumulativeBid,\n      };\n    });\n\n    // Calculate cumulative depth for asks (ascending)\n    let cumulativeAsk = 0;\n    const asks = snapshot.asks.map((level) => {\n      cumulativeAsk += level.price * level.amount;\n      return {\n        price: level.price,\n        cumulative: cumulativeAsk,\n      };\n    });\n\n    const spread = this.analyzeSpread(snapshot);\n\n    return {\n      exchangeId: snapshot.exchangeId,\n      symbol: snapshot.symbol,\n      timestamp: snapshot.timestamp,\n      bids,\n      asks,\n      bestBid: snapshot.bestBid || snapshot.bids[0]?.price || 0,\n      bestAsk: snapshot.bestAsk || snapshot.asks[0]?.price || 0,\n      midPrice: spread.midPrice,\n    };\n  }\n\n  /**\n   * Generate DOM (Depth of Market) display data\n   * Nelogica-style DOM visualization\n   */\n  static generateDOMDisplayData(snapshot: OrderBookSnapshot, levels: number = 20): DOMDisplayData {\n    const spread = this.analyzeSpread(snapshot);\n    const midPrice = spread.midPrice;\n\n    // Get levels around mid price\n    const bidLevels = snapshot.bids.slice(0, levels);\n    const askLevels = snapshot.asks.slice(0, levels);\n\n    // Calculate max volume for intensity normalization\n    const maxBidVolume = Math.max(...bidLevels.map((l) => l.amount), 0);\n    const maxAskVolume = Math.max(...askLevels.map((l) => l.amount), 0);\n    const maxVolume = Math.max(maxBidVolume, maxAskVolume);\n\n    // Create price range (from best ask to best bid)\n    const minPrice = Math.min(bidLevels[bidLevels.length - 1]?.price || 0, askLevels[0]?.price || 0);\n    const maxPrice = Math.max(bidLevels[0]?.price || 0, askLevels[askLevels.length - 1]?.price || 0);\n\n    // Generate levels\n    const domLevels: DOMLevelData[] = [];\n\n    // Create a map for quick lookup\n    const bidMap = new Map(bidLevels.map((l) => [l.price, l]));\n    const askMap = new Map(askLevels.map((l) => [l.price, l]));\n\n    // Generate all price levels\n    const allPrices = new Set([\n      ...bidLevels.map((l) => l.price),\n      ...askLevels.map((l) => l.price),\n    ]);\n\n    let cumulativeBid = 0;\n    let cumulativeAsk = 0;\n\n    Array.from(allPrices)\n      .sort((a, b) => b - a) // Descending\n      .forEach((price) => {\n        const bidLevel = bidMap.get(price);\n        const askLevel = askMap.get(price);\n\n        const bidSize = bidLevel?.amount || 0;\n        const askSize = askLevel?.amount || 0;\n\n        if (bidSize > 0) cumulativeBid += bidSize;\n        if (askSize > 0) cumulativeAsk += askSize;\n\n        const bidIntensity = maxVolume > 0 ? (bidSize / maxVolume) * 100 : 0;\n        const askIntensity = maxVolume > 0 ? (askSize / maxVolume) * 100 : 0;\n\n        const imbalance =\n          bidSize + askSize > 0 ? (bidSize - askSize) / (bidSize + askSize) : 0;\n\n        domLevels.push({\n          price,\n          bidSize: bidSize > 0 ? bidSize : undefined,\n          bidOrders: bidLevel ? 1 : undefined, // Simplified - CCXT doesn't provide order count\n          bidIntensity: bidSize > 0 ? bidIntensity : undefined,\n          askSize: askSize > 0 ? askSize : undefined,\n          askOrders: askLevel ? 1 : undefined,\n          askIntensity: askSize > 0 ? askIntensity : undefined,\n          cumulativeBidSize: cumulativeBid > 0 ? cumulativeBid : undefined,\n          cumulativeAskSize: cumulativeAsk > 0 ? cumulativeAsk : undefined,\n          imbalance: bidSize > 0 || askSize > 0 ? imbalance : undefined,\n        });\n      });\n\n    const totalBidVolume = bidLevels.reduce((sum, l) => sum + l.amount, 0);\n    const totalAskVolume = askLevels.reduce((sum, l) => sum + l.amount, 0);\n\n    return {\n      exchangeId: snapshot.exchangeId,\n      symbol: snapshot.symbol,\n      timestamp: snapshot.timestamp,\n      levels: domLevels,\n      totalBidVolume,\n      totalAskVolume,\n      totalBidOrders: bidLevels.length, // Simplified\n      totalAskOrders: askLevels.length, // Simplified\n      midPrice,\n      spread: spread.absolute,\n      spreadPercent: spread.percent,\n    };\n  }\n\n  /**\n   * Calculate order book statistics over time period\n   */\n  static async calculateStatistics(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date\n  ): Promise<{\n    count: number;\n    avgSpread: number;\n    minSpread: number;\n    maxSpread: number;\n    avgDepth: number;\n    minDepth: number;\n    maxDepth: number;\n    avgImbalance: number;\n    avgLiquidityScore: number;\n    liquidityRegimeDistribution: {\n      abundant: number;\n      normal: number;\n      scarce: number;\n      crisis: number;\n    };\n  }> {\n    try {\n      // Get snapshot statistics\n      const [snapshotStats] = await db\n        .select({\n          count: sql<number>`COUNT(*)::int`,\n          avgSpread: sql<number>`AVG(${orderBookSnapshots.spread})::float`,\n          minSpread: sql<number>`MIN(${orderBookSnapshots.spread})::float`,\n          maxSpread: sql<number>`MAX(${orderBookSnapshots.spread})::float`,\n          avgDepth: sql<number>`AVG(${orderBookSnapshots.totalDepth})::float`,\n          minDepth: sql<number>`MIN(${orderBookSnapshots.totalDepth})::float`,\n          maxDepth: sql<number>`MAX(${orderBookSnapshots.totalDepth})::float`,\n          avgImbalance: sql<number>`AVG(\n            (${orderBookSnapshots.bidDepth10} - ${orderBookSnapshots.askDepth10}) /\n            NULLIF(${orderBookSnapshots.bidDepth10} + ${orderBookSnapshots.askDepth10}, 0)\n          )::float`,\n        })\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime),\n            lte(orderBookSnapshots.timestamp, endTime)\n          )\n        );\n\n      // Get liquidity score statistics\n      const [liquidityStats] = await db\n        .select({\n          avgScore: sql<number>`AVG(${liquidityScores.score})::float`,\n        })\n        .from(liquidityScores)\n        .where(\n          and(\n            eq(liquidityScores.exchangeId, exchangeId),\n            eq(liquidityScores.symbol, symbol),\n            gte(liquidityScores.timestamp, startTime),\n            lte(liquidityScores.timestamp, endTime)\n          )\n        );\n\n      // Get regime distribution\n      const regimeDistribution = await db\n        .select({\n          regime: liquidityScores.regime,\n          count: sql<number>`COUNT(*)::int`,\n        })\n        .from(liquidityScores)\n        .where(\n          and(\n            eq(liquidityScores.exchangeId, exchangeId),\n            eq(liquidityScores.symbol, symbol),\n            gte(liquidityScores.timestamp, startTime),\n            lte(liquidityScores.timestamp, endTime)\n          )\n        )\n        .groupBy(liquidityScores.regime);\n\n      const regimeMap = {\n        abundant: 0,\n        normal: 0,\n        scarce: 0,\n        crisis: 0,\n      };\n\n      regimeDistribution.forEach((r) => {\n        if (r.regime && r.regime in regimeMap) {\n          regimeMap[r.regime as keyof typeof regimeMap] = r.count;\n        }\n      });\n\n      return {\n        count: snapshotStats?.count || 0,\n        avgSpread: snapshotStats?.avgSpread || 0,\n        minSpread: snapshotStats?.minSpread || 0,\n        maxSpread: snapshotStats?.maxSpread || 0,\n        avgDepth: snapshotStats?.avgDepth || 0,\n        minDepth: snapshotStats?.minDepth || 0,\n        maxDepth: snapshotStats?.maxDepth || 0,\n        avgImbalance: snapshotStats?.avgImbalance || 0,\n        avgLiquidityScore: liquidityStats?.avgScore || 0,\n        liquidityRegimeDistribution: regimeMap,\n      };\n    } catch (error) {\n      logger.error('Failed to calculate order book statistics', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Detect price gaps (liquidity gaps) in order book\n   */\n  static detectLiquidityGaps(\n    snapshot: OrderBookSnapshot,\n    thresholdPercent: number = 0.5\n  ): {\n    bidGaps: { startPrice: number; endPrice: number; gapPercent: number }[];\n    askGaps: { startPrice: number; endPrice: number; gapPercent: number }[];\n  } {\n    const detectGaps = (levels: OrderBookLevel[]) => {\n      const gaps: { startPrice: number; endPrice: number; gapPercent: number }[] = [];\n\n      for (let i = 0; i < levels.length - 1; i++) {\n        const currentPrice = levels[i].price;\n        const nextPrice = levels[i + 1].price;\n        const gap = Math.abs(currentPrice - nextPrice);\n        const gapPercent = (gap / currentPrice) * 100;\n\n        if (gapPercent > thresholdPercent) {\n          gaps.push({\n            startPrice: currentPrice,\n            endPrice: nextPrice,\n            gapPercent,\n          });\n        }\n      }\n\n      return gaps;\n    };\n\n    return {\n      bidGaps: detectGaps(snapshot.bids),\n      askGaps: detectGaps(snapshot.asks),\n    };\n  }\n\n  /**\n   * Calculate depth (total USD value) at given levels\n   */\n  private static calculateDepth(levels: OrderBookLevel[]): number {\n    return levels.reduce((sum, level) => sum + level.price * level.amount, 0);\n  }\n\n  /**\n   * Analyze and store complete analytics (convenience method)\n   */\n  static async analyzeAndStore(\n    exchangeId: string,\n    symbol: string\n  ): Promise<{\n    snapshot: OrderBookSnapshot;\n    depth: ReturnType<typeof OrderBookAnalyticsService.analyzeDepth>;\n    spread: ReturnType<typeof OrderBookAnalyticsService.analyzeSpread>;\n    volumeDistribution: ReturnType<typeof OrderBookAnalyticsService.analyzeVolumeDistribution>;\n    liquidityScore: LiquidityScore;\n  }> {\n    // Fetch latest snapshot\n    const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n    if (!snapshot) {\n      throw new BadRequestError('No order book snapshot found');\n    }\n\n    // Analyze\n    const depth = this.analyzeDepth(snapshot);\n    const spread = this.analyzeSpread(snapshot);\n    const volumeDistribution = this.analyzeVolumeDistribution(snapshot);\n    const liquidityScore = this.calculateLiquidityScore(snapshot);\n\n    // Store liquidity score\n    await this.storeLiquidityScore(liquidityScore);\n\n    logger.info('Analyzed and stored order book analytics', {\n      exchangeId,\n      symbol,\n      liquidityScore: liquidityScore.score.toFixed(2),\n      regime: liquidityScore.regime,\n    });\n\n    return {\n      snapshot,\n      depth,\n      spread,\n      volumeDistribution,\n      liquidityScore,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/order-book-imbalance.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'neutralRange' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":339,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Book Imbalance Service\n * Calculate and analyze order book imbalance at multiple depth levels\n *\n * Features:\n * - Multi-level imbalance calculation (5, 10, 20, 50 levels)\n * - Volume imbalance (USD value)\n * - Pressure score (-100 to +100)\n * - Imbalance momentum (rate of change)\n * - Cumulative imbalance (time window)\n * - Adaptive thresholds based on volatility\n * - Trading signals from imbalance\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte, sql } from 'drizzle-orm';\nimport { orderBookImbalance } from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type {\n  OrderBookSnapshot,\n  OrderBookImbalance as OrderBookImbalanceType,\n  OrderBookLevel,\n} from '../types/order-book.types';\n\nexport class OrderBookImbalanceService {\n  /**\n   * Calculate order book imbalance at multiple depth levels\n   * Imbalance = (Bid - Ask) / (Bid + Ask)\n   * Range: -1 to +1 (-1 = all asks, +1 = all bids, 0 = balanced)\n   */\n  static calculateImbalance(snapshot: OrderBookSnapshot): OrderBookImbalanceType {\n    // Calculate imbalance at different depths\n    const imbalance5 = this.calculateImbalanceAtDepth(snapshot.bids.slice(0, 5), snapshot.asks.slice(0, 5));\n    const imbalance10 = this.calculateImbalanceAtDepth(snapshot.bids.slice(0, 10), snapshot.asks.slice(0, 10));\n    const imbalance20 = this.calculateImbalanceAtDepth(snapshot.bids.slice(0, 20), snapshot.asks.slice(0, 20));\n    const imbalance50 = this.calculateImbalanceAtDepth(snapshot.bids.slice(0, 50), snapshot.asks.slice(0, 50));\n\n    // Calculate volume imbalance (USD value)\n    const bidVolume = this.calculateVolume(snapshot.bids.slice(0, 10));\n    const askVolume = this.calculateVolume(snapshot.asks.slice(0, 10));\n    const volumeImbalance = bidVolume - askVolume;\n\n    // Calculate pressure score (-100 to +100)\n    // Weighted average of imbalances at different depths\n    const pressureScore = this.calculatePressureScore(\n      imbalance5,\n      imbalance10,\n      imbalance20,\n      imbalance50\n    );\n\n    return {\n      exchangeId: snapshot.exchangeId,\n      symbol: snapshot.symbol,\n      timestamp: snapshot.timestamp,\n      imbalance5,\n      imbalance10,\n      imbalance20,\n      imbalance50,\n      volumeImbalance,\n      pressureScore,\n    };\n  }\n\n  /**\n   * Calculate imbalance momentum (rate of change)\n   */\n  static calculateImbalanceMomentum(\n    current: OrderBookImbalanceType,\n    previous: OrderBookImbalanceType\n  ): number {\n    // Rate of change in imbalance10 (most commonly used depth)\n    const timeDiffSeconds =\n      (current.timestamp.getTime() - previous.timestamp.getTime()) / 1000;\n\n    if (timeDiffSeconds === 0) return 0;\n\n    const imbalanceChange = current.imbalance10 - previous.imbalance10;\n    const momentum = imbalanceChange / timeDiffSeconds; // Change per second\n\n    return momentum;\n  }\n\n  /**\n   * Calculate cumulative imbalance over time window\n   */\n  static async calculateCumulativeImbalance(\n    exchangeId: string,\n    symbol: string,\n    windowMinutes: number = 5\n  ): Promise<number> {\n    try {\n      const endTime = new Date();\n      const startTime = new Date(endTime.getTime() - windowMinutes * 60 * 1000);\n\n      const [result] = await db\n        .select({\n          cumulative: sql<number>`SUM(${orderBookImbalance.imbalance10})::float`,\n        })\n        .from(orderBookImbalance)\n        .where(\n          and(\n            eq(orderBookImbalance.exchangeId, exchangeId),\n            eq(orderBookImbalance.symbol, symbol),\n            gte(orderBookImbalance.timestamp, startTime),\n            lte(orderBookImbalance.timestamp, endTime)\n          )\n        );\n\n      return result?.cumulative || 0;\n    } catch (error) {\n      logger.error('Failed to calculate cumulative imbalance', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Store order book imbalance\n   */\n  static async storeImbalance(imbalance: OrderBookImbalanceType): Promise<void> {\n    try {\n      await db.insert(orderBookImbalance).values({\n        exchangeId: imbalance.exchangeId,\n        symbol: imbalance.symbol,\n        timestamp: imbalance.timestamp,\n        imbalance5: imbalance.imbalance5.toString(),\n        imbalance10: imbalance.imbalance10.toString(),\n        imbalance20: imbalance.imbalance20.toString(),\n        imbalance50: imbalance.imbalance50.toString(),\n        volumeImbalance: imbalance.volumeImbalance.toString(),\n        pressureScore: imbalance.pressureScore.toString(),\n        imbalanceMomentum: imbalance.imbalanceMomentum?.toString(),\n        cumulativeImbalance: imbalance.cumulativeImbalance?.toString(),\n      });\n\n      logger.debug('Stored order book imbalance', {\n        exchangeId: imbalance.exchangeId,\n        symbol: imbalance.symbol,\n        imbalance10: imbalance.imbalance10.toFixed(4),\n        pressureScore: imbalance.pressureScore.toFixed(2),\n      });\n    } catch (error) {\n      logger.error('Failed to store order book imbalance', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get latest imbalance\n   */\n  static async getLatestImbalance(\n    exchangeId: string,\n    symbol: string\n  ): Promise<OrderBookImbalanceType | null> {\n    try {\n      const [result] = await db\n        .select()\n        .from(orderBookImbalance)\n        .where(\n          and(\n            eq(orderBookImbalance.exchangeId, exchangeId),\n            eq(orderBookImbalance.symbol, symbol)\n          )\n        )\n        .orderBy(desc(orderBookImbalance.timestamp))\n        .limit(1);\n\n      if (!result) return null;\n\n      return {\n        id: result.id,\n        exchangeId: result.exchangeId,\n        symbol: result.symbol,\n        timestamp: result.timestamp,\n        imbalance5: parseFloat(result.imbalance5 ?? '0'),\n        imbalance10: parseFloat(result.imbalance10 ?? '0'),\n        imbalance20: parseFloat(result.imbalance20 ?? '0'),\n        imbalance50: parseFloat(result.imbalance50 ?? '0'),\n        volumeImbalance: parseFloat(result.volumeImbalance ?? '0'),\n        pressureScore: parseFloat(result.pressureScore ?? '0'),\n        imbalanceMomentum: result.imbalanceMomentum\n          ? parseFloat(result.imbalanceMomentum)\n          : undefined,\n        cumulativeImbalance: result.cumulativeImbalance\n          ? parseFloat(result.cumulativeImbalance)\n          : undefined,\n        createdAt: result.createdAt,\n      };\n    } catch (error) {\n      logger.error('Failed to get latest imbalance', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get historical imbalance data\n   */\n  static async getHistoricalImbalance(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date,\n    limit: number = 1000\n  ): Promise<OrderBookImbalanceType[]> {\n    try {\n      const results = await db\n        .select()\n        .from(orderBookImbalance)\n        .where(\n          and(\n            eq(orderBookImbalance.exchangeId, exchangeId),\n            eq(orderBookImbalance.symbol, symbol),\n            gte(orderBookImbalance.timestamp, startTime),\n            lte(orderBookImbalance.timestamp, endTime)\n          )\n        )\n        .orderBy(desc(orderBookImbalance.timestamp))\n        .limit(limit);\n\n      return results.map((row) => ({\n        id: row.id,\n        exchangeId: row.exchangeId,\n        symbol: row.symbol,\n        timestamp: row.timestamp,\n        imbalance5: parseFloat(row.imbalance5 ?? '0'),\n        imbalance10: parseFloat(row.imbalance10 ?? '0'),\n        imbalance20: parseFloat(row.imbalance20 ?? '0'),\n        imbalance50: parseFloat(row.imbalance50 ?? '0'),\n        volumeImbalance: parseFloat(row.volumeImbalance ?? '0'),\n        pressureScore: parseFloat(row.pressureScore ?? '0'),\n        imbalanceMomentum: row.imbalanceMomentum ? parseFloat(row.imbalanceMomentum) : undefined,\n        cumulativeImbalance: row.cumulativeImbalance\n          ? parseFloat(row.cumulativeImbalance)\n          : undefined,\n        createdAt: row.createdAt,\n      }));\n    } catch (error) {\n      logger.error('Failed to get historical imbalance', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate adaptive thresholds based on volatility\n   */\n  static async calculateAdaptiveThresholds(\n    exchangeId: string,\n    symbol: string,\n    windowMinutes: number = 60\n  ): Promise<{\n    buyThreshold: number;\n    sellThreshold: number;\n    neutralRange: { min: number; max: number };\n  }> {\n    try {\n      const endTime = new Date();\n      const startTime = new Date(endTime.getTime() - windowMinutes * 60 * 1000);\n\n      // Get historical imbalance data\n      const historicalData = await this.getHistoricalImbalance(\n        exchangeId,\n        symbol,\n        startTime,\n        endTime,\n        100\n      );\n\n      if (historicalData.length === 0) {\n        // Default thresholds\n        return {\n          buyThreshold: 0.3,\n          sellThreshold: -0.3,\n          neutralRange: { min: -0.1, max: 0.1 },\n        };\n      }\n\n      // Calculate statistics\n      const imbalances = historicalData.map((d) => d.imbalance10);\n      const mean = imbalances.reduce((sum, val) => sum + val, 0) / imbalances.length;\n      const variance =\n        imbalances.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / imbalances.length;\n      const stdDev = Math.sqrt(variance);\n\n      // Adaptive thresholds based on volatility\n      const buyThreshold = mean + stdDev * 1.5;\n      const sellThreshold = mean - stdDev * 1.5;\n      const neutralRange = {\n        min: mean - stdDev * 0.5,\n        max: mean + stdDev * 0.5,\n      };\n\n      logger.debug('Calculated adaptive imbalance thresholds', {\n        exchangeId,\n        symbol,\n        mean: mean.toFixed(4),\n        stdDev: stdDev.toFixed(4),\n        buyThreshold: buyThreshold.toFixed(4),\n        sellThreshold: sellThreshold.toFixed(4),\n      });\n\n      return { buyThreshold, sellThreshold, neutralRange };\n    } catch (error) {\n      logger.error('Failed to calculate adaptive thresholds', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate trading signal from imbalance\n   */\n  static generateSignal(\n    imbalance: OrderBookImbalanceType,\n    thresholds?: {\n      buyThreshold: number;\n      sellThreshold: number;\n      neutralRange: { min: number; max: number };\n    }\n  ): {\n    direction: 'buy' | 'sell' | 'neutral';\n    strength: number; // 0-100\n    reason: string;\n  } {\n    // Use default thresholds if not provided\n    const {\n      buyThreshold = 0.3,\n      sellThreshold = -0.3,\n      neutralRange = { min: -0.1, max: 0.1 },\n    } = thresholds || {};\n\n    const imb = imbalance.imbalance10; // Use 10-level imbalance as primary\n\n    let direction: 'buy' | 'sell' | 'neutral';\n    let strength: number;\n    let reason: string;\n\n    if (imb > buyThreshold) {\n      direction = 'buy';\n      // Strength based on how far above threshold (0-100 scale)\n      strength = Math.min(100, ((imb - buyThreshold) / (1 - buyThreshold)) * 100);\n      reason = `Strong bid pressure: ${(imb * 100).toFixed(1)}% imbalance`;\n    } else if (imb < sellThreshold) {\n      direction = 'sell';\n      strength = Math.min(100, ((sellThreshold - imb) / (1 + sellThreshold)) * 100);\n      reason = `Strong ask pressure: ${(imb * 100).toFixed(1)}% imbalance`;\n    } else {\n      direction = 'neutral';\n      // Strength of neutrality (closer to center = stronger neutral)\n      const distanceFromCenter = Math.abs(imb);\n      strength = Math.max(0, 100 - distanceFromCenter * 200);\n      reason = `Balanced order book: ${(imb * 100).toFixed(1)}% imbalance`;\n    }\n\n    return { direction, strength, reason };\n  }\n\n  /**\n   * Calculate and store imbalance with full enrichment (convenience method)\n   */\n  static async calculateAndStore(\n    exchangeId: string,\n    symbol: string\n  ): Promise<OrderBookImbalanceType> {\n    // Get latest snapshot\n    const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n    if (!snapshot) {\n      throw new BadRequestError('No order book snapshot found');\n    }\n\n    // Calculate imbalance\n    const imbalance = this.calculateImbalance(snapshot);\n\n    // Get previous imbalance for momentum\n    const previousImbalance = await this.getLatestImbalance(exchangeId, symbol);\n\n    if (previousImbalance) {\n      imbalance.imbalanceMomentum = this.calculateImbalanceMomentum(imbalance, previousImbalance);\n    }\n\n    // Calculate cumulative imbalance\n    imbalance.cumulativeImbalance = await this.calculateCumulativeImbalance(exchangeId, symbol, 5);\n\n    // Store\n    await this.storeImbalance(imbalance);\n\n    logger.info('Calculated and stored order book imbalance', {\n      exchangeId,\n      symbol,\n      imbalance10: imbalance.imbalance10.toFixed(4),\n      pressureScore: imbalance.pressureScore.toFixed(2),\n      momentum: imbalance.imbalanceMomentum?.toFixed(6),\n    });\n\n    return imbalance;\n  }\n\n  /**\n   * Calculate imbalance at specific depth\n   */\n  private static calculateImbalanceAtDepth(\n    bids: OrderBookLevel[],\n    asks: OrderBookLevel[]\n  ): number {\n    const bidVolume = this.calculateVolume(bids);\n    const askVolume = this.calculateVolume(asks);\n    const total = bidVolume + askVolume;\n\n    if (total === 0) return 0;\n\n    return (bidVolume - askVolume) / total;\n  }\n\n  /**\n   * Calculate total volume (USD value) at given levels\n   */\n  private static calculateVolume(levels: OrderBookLevel[]): number {\n    return levels.reduce((sum, level) => sum + level.price * level.amount, 0);\n  }\n\n  /**\n   * Calculate pressure score from multi-level imbalances\n   * Weighted average: closer levels = higher weight\n   */\n  private static calculatePressureScore(\n    imbalance5: number,\n    imbalance10: number,\n    imbalance20: number,\n    imbalance50: number\n  ): number {\n    // Weights: closer levels have more weight\n    const weights = {\n      level5: 0.4, // 40% weight\n      level10: 0.3, // 30% weight\n      level20: 0.2, // 20% weight\n      level50: 0.1, // 10% weight\n    };\n\n    const weightedSum =\n      imbalance5 * weights.level5 +\n      imbalance10 * weights.level10 +\n      imbalance20 * weights.level20 +\n      imbalance50 * weights.level50;\n\n    // Convert to -100 to +100 scale\n    return weightedSum * 100;\n  }\n\n  /**\n   * Get imbalance statistics\n   */\n  static async getImbalanceStatistics(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date\n  ): Promise<{\n    count: number;\n    avgImbalance: number;\n    maxImbalance: number;\n    minImbalance: number;\n    avgPressure: number;\n    buySignalCount: number;\n    sellSignalCount: number;\n    neutralCount: number;\n  }> {\n    try {\n      const [result] = await db\n        .select({\n          count: sql<number>`COUNT(*)::int`,\n          avgImbalance: sql<number>`AVG(${orderBookImbalance.imbalance10})::float`,\n          maxImbalance: sql<number>`MAX(${orderBookImbalance.imbalance10})::float`,\n          minImbalance: sql<number>`MIN(${orderBookImbalance.imbalance10})::float`,\n          avgPressure: sql<number>`AVG(${orderBookImbalance.pressureScore})::float`,\n          buySignalCount: sql<number>`COUNT(CASE WHEN ${orderBookImbalance.imbalance10}::float > 0.3 THEN 1 END)::int`,\n          sellSignalCount: sql<number>`COUNT(CASE WHEN ${orderBookImbalance.imbalance10}::float < -0.3 THEN 1 END)::int`,\n          neutralCount: sql<number>`COUNT(CASE WHEN ${orderBookImbalance.imbalance10}::float BETWEEN -0.1 AND 0.1 THEN 1 END)::int`,\n        })\n        .from(orderBookImbalance)\n        .where(\n          and(\n            eq(orderBookImbalance.exchangeId, exchangeId),\n            eq(orderBookImbalance.symbol, symbol),\n            gte(orderBookImbalance.timestamp, startTime),\n            lte(orderBookImbalance.timestamp, endTime)\n          )\n        );\n\n      return {\n        count: result?.count || 0,\n        avgImbalance: result?.avgImbalance || 0,\n        maxImbalance: result?.maxImbalance || 0,\n        minImbalance: result?.minImbalance || 0,\n        avgPressure: result?.avgPressure || 0,\n        buySignalCount: result?.buySignalCount || 0,\n        sellSignalCount: result?.sellSignalCount || 0,\n        neutralCount: result?.neutralCount || 0,\n      };\n    } catch (error) {\n      logger.error('Failed to get imbalance statistics', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/order-book-snapshot.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/price-impact.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OrderBookAnalyticsService' is defined but never used. Allowed unused vars must match /^_/u.","line":28,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OrderBookLevel' is defined but never used. Allowed unused vars must match /^_/u.","line":31,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Price Impact Service\n * Advanced slippage estimation and liquidity cost analysis\n *\n * Features:\n * - Slippage estimation for market orders\n * - Price impact calculation (temporary + permanent)\n * - Optimal execution analysis (VWAP, TWAP)\n * - Liquidity cost modeling\n * - Trade splitting recommendations\n * - Market depth curves\n * - Execution quality metrics\n *\n * Models:\n * - Linear impact model\n * - Square-root impact model (Almgren-Chriss)\n * - Permanent vs temporary impact decomposition\n * - Cost of immediacy (spread + impact)\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte } from 'drizzle-orm';\nimport {\n  orderBookSnapshots,\n  priceImpactEstimates,\n} from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport { OrderBookAnalyticsService } from './order-book-analytics.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type { OrderBookSnapshot, OrderBookLevel } from '../types/order-book.types';\n\n/**\n * Price Impact Estimate\n */\nexport interface PriceImpactEstimate {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Order details\n  side: 'buy' | 'sell';\n  orderSize: number; // In base currency\n  orderSizeUSD: number;\n\n  // Price impact\n  impactPercent: number; // Total price impact %\n  impactBps: number; // Impact in basis points\n  slippageUSD: number; // Dollar slippage\n\n  // Execution prices\n  bestPrice: number; // Best available price\n  averagePrice: number; // VWAP execution price\n  worstPrice: number; // Last fill price\n\n  // Impact decomposition\n  temporaryImpact: number; // Reverses after trade\n  permanentImpact: number; // Persists in market\n  spreadCost: number; // Cost of crossing spread\n\n  // Liquidity analysis\n  liquidityConsumed: number; // % of available liquidity\n  levelsConsumed: number; // Number of price levels needed\n  executionPath: Array<{ price: number; size: number; cumulative: number }>;\n}\n\n/**\n * Slippage Analysis\n */\nexport interface SlippageAnalysis {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  side: 'buy' | 'sell';\n  orderSize: number;\n\n  // Slippage scenarios\n  bestCase: PriceImpactEstimate; // Current liquidity\n  worstCase: PriceImpactEstimate; // Stressed liquidity (-50%)\n  expected: PriceImpactEstimate; // Probabilistic estimate\n\n  // Risk metrics\n  slippageRisk: 'low' | 'medium' | 'high' | 'extreme';\n  recommendedMaxSize: number;\n  suggestedSplits: number; // Recommended order splits\n}\n\n/**\n * Optimal Execution Strategy\n */\nexport interface OptimalExecutionStrategy {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Target\n  targetSize: number;\n  targetSide: 'buy' | 'sell';\n\n  // Strategy\n  strategy: 'market' | 'vwap' | 'twap' | 'pov' | 'adaptive';\n  splitCount: number;\n  orderSizePerSplit: number;\n  timeBetweenOrders: number; // seconds\n\n  // Expected costs\n  estimatedImpact: number; // %\n  estimatedSlippage: number; // USD\n  estimatedDuration: number; // seconds\n\n  // Comparison\n  marketOrderCost: number; // Immediate execution cost\n  optimalCost: number; // Strategy cost\n  savings: number; // USD saved vs market order\n  savingsPercent: number; // % saved\n}\n\n/**\n * Market Depth Curve\n */\nexport interface MarketDepthCurve {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  side: 'buy' | 'sell';\n\n  // Curve points (size -> price impact)\n  curve: Array<{\n    size: number;\n    sizeUSD: number;\n    impactPercent: number;\n    averagePrice: number;\n    marginalCost: number; // Cost of next unit\n  }>;\n\n  // Key metrics\n  liquidityScore: number; // 0-100\n  depthQuality: 'excellent' | 'good' | 'fair' | 'poor';\n  elasticity: number; // How responsive price is to volume\n}\n\n/**\n * Execution Quality Metrics\n */\nexport interface ExecutionQualityMetrics {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Execution details\n  executedPrice: number;\n  executedSize: number;\n  executionTime: Date;\n\n  // Benchmarks\n  arrivalPrice: number; // Price when order was placed\n  vwapPrice: number; // VWAP during execution\n  twapPrice: number; // TWAP during execution\n\n  // Quality scores\n  priceImprovement: number; // vs arrival price (%)\n  implementationShortfall: number; // Total cost vs benchmark\n  slippageCost: number; // Actual slippage\n  opportunityCost: number; // Cost of not executing immediately\n\n  // Rating\n  executionQuality: 'excellent' | 'good' | 'fair' | 'poor';\n}\n\nexport class PriceImpactService {\n  /**\n   * Estimate price impact for a market order\n   */\n  static async estimatePriceImpact(\n    exchangeId: string,\n    symbol: string,\n    side: 'buy' | 'sell',\n    orderSize: number\n  ): Promise<PriceImpactEstimate> {\n    try {\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n      if (!snapshot) {\n        throw new BadRequestError('No order book data available');\n      }\n\n      // Select appropriate side of book\n      const levels = side === 'buy' ? snapshot.asks : snapshot.bids;\n      const bestAsk = typeof snapshot.bestAsk === 'string'\n        ? parseFloat(snapshot.bestAsk || '0')\n        : (snapshot.bestAsk || 0);\n      const bestBid = typeof snapshot.bestBid === 'string'\n        ? parseFloat(snapshot.bestBid || '0')\n        : (snapshot.bestBid || 0);\n      const bestPrice = side === 'buy' ? bestAsk : bestBid;\n\n      if (levels.length === 0 || bestPrice === 0) {\n        throw new BadRequestError('Insufficient liquidity');\n      }\n\n      // Walk through order book to fill order\n      let remainingSize = orderSize;\n      let totalCost = 0;\n      let levelsConsumed = 0;\n      const executionPath: Array<{ price: number; size: number; cumulative: number }> = [];\n\n      for (const level of levels) {\n        if (remainingSize <= 0) break;\n\n        const availableSize = level.amount;\n        const fillSize = Math.min(remainingSize, availableSize);\n\n        totalCost += level.price * fillSize;\n        remainingSize -= fillSize;\n        levelsConsumed++;\n\n        executionPath.push({\n          price: level.price,\n          size: fillSize,\n          cumulative: orderSize - remainingSize,\n        });\n      }\n\n      if (remainingSize > 0) {\n        throw new BadRequestError(\n          `Insufficient liquidity. Can only fill ${orderSize - remainingSize} of ${orderSize}`\n        );\n      }\n\n      // Calculate metrics\n      const averagePrice = totalCost / orderSize;\n      const worstPrice = executionPath[executionPath.length - 1].price;\n      const orderSizeUSD = totalCost;\n\n      // Impact calculation\n      const impactPercent = Math.abs(((averagePrice - bestPrice) / bestPrice) * 100);\n      const impactBps = impactPercent * 100;\n      const slippageUSD = Math.abs(totalCost - (bestPrice * orderSize));\n\n      // Impact decomposition (Almgren-Chriss model)\n      const { temporaryImpact, permanentImpact } = this.decomposeImpact(\n        impactPercent,\n        orderSize,\n        snapshot\n      );\n\n      // Spread cost\n      const midPrice = snapshot.midPrice || ((snapshot.bestBid || 0) + (snapshot.bestAsk || 0)) / 2;\n      const spreadCost = Math.abs(((bestPrice - midPrice) / midPrice) * 100);\n\n      // Liquidity consumed\n      const totalLiquidity = levels.reduce((sum, l) => sum + l.amount, 0);\n      const liquidityConsumed = (orderSize / totalLiquidity) * 100;\n\n      const result: PriceImpactEstimate = {\n        exchangeId,\n        symbol,\n        timestamp: snapshot.timestamp,\n        side,\n        orderSize,\n        orderSizeUSD,\n        impactPercent,\n        impactBps,\n        slippageUSD,\n        bestPrice,\n        averagePrice,\n        worstPrice,\n        temporaryImpact,\n        permanentImpact,\n        spreadCost,\n        liquidityConsumed,\n        levelsConsumed,\n        executionPath,\n      };\n\n      logger.debug('Estimated price impact', {\n        exchangeId,\n        symbol,\n        side,\n        orderSize,\n        impactPercent: impactPercent.toFixed(3),\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to estimate price impact', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Decompose impact into temporary and permanent components\n   * Based on Almgren-Chriss model\n   */\n  private static decomposeImpact(\n    totalImpact: number,\n    orderSize: number,\n    snapshot: OrderBookSnapshot\n  ): { temporaryImpact: number; permanentImpact: number } {\n    // Square-root law: impact ~ sqrt(orderSize / ADV)\n    // Temporary impact: ~70% of total (reverses quickly)\n    // Permanent impact: ~30% of total (market adjustment)\n\n    const totalVolume = snapshot.bids.reduce((sum, b) => sum + b.amount, 0) +\n                       snapshot.asks.reduce((sum, a) => sum + a.amount, 0);\n\n    const volumeRatio = orderSize / totalVolume;\n\n    // Larger orders have more permanent impact\n    const permanentRatio = Math.min(0.5, 0.2 + volumeRatio * 0.5);\n    const temporaryRatio = 1 - permanentRatio;\n\n    return {\n      temporaryImpact: totalImpact * temporaryRatio,\n      permanentImpact: totalImpact * permanentRatio,\n    };\n  }\n\n  /**\n   * Analyze slippage scenarios\n   */\n  static async analyzeSlippage(\n    exchangeId: string,\n    symbol: string,\n    side: 'buy' | 'sell',\n    orderSize: number\n  ): Promise<SlippageAnalysis> {\n    try {\n      // Best case: current liquidity\n      const bestCase = await this.estimatePriceImpact(exchangeId, symbol, side, orderSize);\n\n      // Expected case: 80% of current liquidity (typical)\n      const expectedSize = orderSize * 0.8;\n      const expected = await this.estimatePriceImpact(exchangeId, symbol, side, expectedSize);\n\n      // Worst case: 50% of current liquidity (stressed)\n      const worstCaseSize = orderSize * 0.5;\n      let worstCase: PriceImpactEstimate;\n      try {\n        worstCase = await this.estimatePriceImpact(exchangeId, symbol, side, worstCaseSize);\n      } catch (error) {\n        // If even 50% fails, use best case with doubled impact\n        worstCase = {\n          ...bestCase,\n          impactPercent: bestCase.impactPercent * 2,\n          impactBps: bestCase.impactBps * 2,\n          slippageUSD: bestCase.slippageUSD * 2,\n        };\n      }\n\n      // Risk assessment\n      let slippageRisk: 'low' | 'medium' | 'high' | 'extreme';\n      if (bestCase.impactPercent < 0.1) slippageRisk = 'low';\n      else if (bestCase.impactPercent < 0.5) slippageRisk = 'medium';\n      else if (bestCase.impactPercent < 1.0) slippageRisk = 'high';\n      else slippageRisk = 'extreme';\n\n      // Recommended max size (impact < 0.5%)\n      const recommendedMaxSize = orderSize * (0.5 / Math.max(0.1, bestCase.impactPercent));\n\n      // Suggested splits (to keep impact < 0.25% per order)\n      const suggestedSplits = Math.ceil(bestCase.impactPercent / 0.25);\n\n      const result: SlippageAnalysis = {\n        exchangeId,\n        symbol,\n        timestamp: bestCase.timestamp,\n        side,\n        orderSize,\n        bestCase,\n        worstCase,\n        expected,\n        slippageRisk,\n        recommendedMaxSize,\n        suggestedSplits: Math.max(1, suggestedSplits),\n      };\n\n      logger.info('Analyzed slippage scenarios', {\n        exchangeId,\n        symbol,\n        slippageRisk,\n        suggestedSplits,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to analyze slippage', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate optimal execution strategy\n   */\n  static async calculateOptimalExecution(\n    exchangeId: string,\n    symbol: string,\n    side: 'buy' | 'sell',\n    targetSize: number,\n    maxImpactPercent: number = 0.25\n  ): Promise<OptimalExecutionStrategy> {\n    try {\n      // Get market order cost (baseline)\n      const marketOrder = await this.estimatePriceImpact(exchangeId, symbol, side, targetSize);\n\n      // Calculate optimal split size\n      const splitCount = Math.ceil(marketOrder.impactPercent / maxImpactPercent);\n      const orderSizePerSplit = targetSize / splitCount;\n\n      // Estimate cost per split\n      const splitImpact = await this.estimatePriceImpact(\n        exchangeId,\n        symbol,\n        side,\n        orderSizePerSplit\n      );\n\n      // Time between orders (to allow market to absorb)\n      // Rule of thumb: wait for ~10% of daily volume to trade\n      const timeBetweenOrders = Math.max(30, splitCount * 10); // seconds\n\n      // Total execution time\n      const estimatedDuration = timeBetweenOrders * (splitCount - 1);\n\n      // Optimal strategy cost\n      const optimalCost = splitImpact.slippageUSD * splitCount;\n\n      // Savings vs market order\n      const savings = marketOrder.slippageUSD - optimalCost;\n      const savingsPercent = (savings / marketOrder.slippageUSD) * 100;\n\n      // Determine strategy type\n      let strategy: 'market' | 'vwap' | 'twap' | 'pov' | 'adaptive';\n      if (splitCount === 1) {\n        strategy = 'market'; // Small order, execute immediately\n      } else if (splitCount <= 5) {\n        strategy = 'twap'; // Time-weighted\n      } else if (marketOrder.liquidityConsumed > 20) {\n        strategy = 'adaptive'; // Large order, needs smart execution\n      } else {\n        strategy = 'vwap'; // Volume-weighted\n      }\n\n      const result: OptimalExecutionStrategy = {\n        exchangeId,\n        symbol,\n        timestamp: marketOrder.timestamp,\n        targetSize,\n        targetSide: side,\n        strategy,\n        splitCount,\n        orderSizePerSplit,\n        timeBetweenOrders,\n        estimatedImpact: splitImpact.impactPercent,\n        estimatedSlippage: optimalCost,\n        estimatedDuration,\n        marketOrderCost: marketOrder.slippageUSD,\n        optimalCost,\n        savings: Math.max(0, savings),\n        savingsPercent: Math.max(0, savingsPercent),\n      };\n\n      logger.info('Calculated optimal execution strategy', {\n        exchangeId,\n        symbol,\n        strategy,\n        splitCount,\n        savings: savings.toFixed(2),\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to calculate optimal execution', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate market depth curve\n   */\n  static async generateDepthCurve(\n    exchangeId: string,\n    symbol: string,\n    side: 'buy' | 'sell',\n    maxSizeMultiplier: number = 10\n  ): Promise<MarketDepthCurve> {\n    try {\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n      if (!snapshot) {\n        throw new BadRequestError('No order book data available');\n      }\n\n      const levels = side === 'buy' ? snapshot.asks : snapshot.bids;\n      const totalLiquidity = levels.reduce((sum, l) => sum + l.amount, 0);\n\n      // Calculate average order size\n      const avgOrderSize = totalLiquidity / levels.length;\n      const maxSize = avgOrderSize * maxSizeMultiplier;\n\n      // Generate curve points\n      const curve: MarketDepthCurve['curve'] = [];\n      const steps = 20;\n\n      for (let i = 1; i <= steps; i++) {\n        const size = (maxSize / steps) * i;\n\n        try {\n          const impact = await this.estimatePriceImpact(exchangeId, symbol, side, size);\n\n          curve.push({\n            size,\n            sizeUSD: impact.orderSizeUSD,\n            impactPercent: impact.impactPercent,\n            averagePrice: impact.averagePrice,\n            marginalCost: i > 1\n              ? impact.impactPercent - curve[i - 2].impactPercent\n              : impact.impactPercent,\n          });\n        } catch (error) {\n          // Stop if we hit liquidity limit\n          break;\n        }\n      }\n\n      // Calculate metrics\n      const liquidityScore = Math.min(100, (totalLiquidity / avgOrderSize) * 10);\n\n      let depthQuality: 'excellent' | 'good' | 'fair' | 'poor';\n      if (liquidityScore >= 80) depthQuality = 'excellent';\n      else if (liquidityScore >= 60) depthQuality = 'good';\n      else if (liquidityScore >= 40) depthQuality = 'fair';\n      else depthQuality = 'poor';\n\n      // Elasticity: how much impact changes per unit size\n      const elasticity = curve.length > 1\n        ? (curve[curve.length - 1].impactPercent - curve[0].impactPercent) /\n          (curve[curve.length - 1].size - curve[0].size)\n        : 0;\n\n      const result: MarketDepthCurve = {\n        exchangeId,\n        symbol,\n        timestamp: snapshot.timestamp,\n        side,\n        curve,\n        liquidityScore,\n        depthQuality,\n        elasticity,\n      };\n\n      logger.debug('Generated market depth curve', {\n        exchangeId,\n        symbol,\n        points: curve.length,\n        depthQuality,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to generate depth curve', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Measure execution quality\n   */\n  static async measureExecutionQuality(\n    exchangeId: string,\n    symbol: string,\n    executedPrice: number,\n    executedSize: number,\n    executionTime: Date,\n    arrivalTime: Date\n  ): Promise<ExecutionQualityMetrics> {\n    try {\n      // Get snapshot at arrival time\n      const arrivalSnapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, arrivalTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp)\n        .limit(1);\n\n      if (arrivalSnapshots.length === 0) {\n        throw new BadRequestError('No data at arrival time');\n      }\n\n      const arrivalSnapshot = arrivalSnapshots[0];\n      const arrivalPrice = parseFloat(arrivalSnapshot.midPrice || '0');\n\n      // Get snapshots during execution window\n      const executionSnapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, arrivalTime),\n            lte(orderBookSnapshots.timestamp, executionTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      // Calculate VWAP and TWAP\n      let vwapNumerator = 0;\n      let vwapDenominator = 0;\n      let twapSum = 0;\n\n      executionSnapshots.forEach(snapshot => {\n        const price = parseFloat(snapshot.midPrice || '0');\n        const volume = parseFloat(snapshot.bidDepth10 || '0') +\n                      parseFloat(snapshot.askDepth10 || '0');\n\n        vwapNumerator += price * volume;\n        vwapDenominator += volume;\n        twapSum += price;\n      });\n\n      const vwapPrice = vwapDenominator > 0\n        ? vwapNumerator / vwapDenominator\n        : arrivalPrice;\n\n      const twapPrice = executionSnapshots.length > 0\n        ? twapSum / executionSnapshots.length\n        : arrivalPrice;\n\n      // Calculate metrics\n      const priceImprovement = ((executedPrice - arrivalPrice) / arrivalPrice) * 100;\n\n      // Implementation shortfall: total cost vs arrival price\n      const implementationShortfall = Math.abs(\n        (executedPrice - arrivalPrice) * executedSize\n      );\n\n      // Slippage cost\n      const slippageCost = Math.abs(executedPrice - vwapPrice) * executedSize;\n\n      // Opportunity cost (if we had executed at arrival)\n      const opportunityCost = Math.abs(executedPrice - arrivalPrice) * executedSize;\n\n      // Quality rating\n      let executionQuality: 'excellent' | 'good' | 'fair' | 'poor';\n      const impactPct = Math.abs(priceImprovement);\n\n      if (impactPct < 0.1) executionQuality = 'excellent';\n      else if (impactPct < 0.3) executionQuality = 'good';\n      else if (impactPct < 0.6) executionQuality = 'fair';\n      else executionQuality = 'poor';\n\n      const result: ExecutionQualityMetrics = {\n        exchangeId,\n        symbol,\n        timestamp: executionTime,\n        executedPrice,\n        executedSize,\n        executionTime,\n        arrivalPrice,\n        vwapPrice,\n        twapPrice,\n        priceImprovement,\n        implementationShortfall,\n        slippageCost,\n        opportunityCost,\n        executionQuality,\n      };\n\n      logger.info('Measured execution quality', {\n        exchangeId,\n        symbol,\n        executionQuality,\n        priceImprovement: priceImprovement.toFixed(3),\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to measure execution quality', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Store price impact estimate in database\n   * Calculates impact for all standard order size tiers\n   */\n  static async storePriceImpactEstimate(\n    estimate: PriceImpactEstimate\n  ): Promise<void> {\n    try {\n      // Calculate impacts for all size tiers\n      const sizeTiers = [1000, 5000, 10000, 50000, 100000, 500000, 1000000]; // USD\n      const impacts: Record<string, string> = {};\n      const slippages: Record<string, string> = {};\n\n      // Get order book snapshot for calculations\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(\n        estimate.exchangeId,\n        estimate.symbol\n      );\n\n      if (!snapshot) {\n        throw new BadRequestError('No order book data available');\n      }\n\n      // Calculate impact for each tier\n      for (const sizeUSD of sizeTiers) {\n        try {\n          // Convert USD to base currency (approximate using current price)\n          const baseSize = sizeUSD / estimate.bestPrice;\n\n          const tierEstimate = await this.estimatePriceImpact(\n            estimate.exchangeId,\n            estimate.symbol,\n            estimate.side,\n            baseSize\n          );\n\n          // Map to schema field names\n          const tierKey = sizeUSD >= 1000000 ? '1m' : `${sizeUSD / 1000}k`;\n          impacts[`size${tierKey}`] = tierEstimate.impactPercent.toFixed(4);\n\n          // Store slippage for 1k, 10k, 100k tiers\n          if ([1000, 10000, 100000].includes(sizeUSD)) {\n            slippages[`slippage${tierKey}`] = tierEstimate.slippageUSD.toFixed(8);\n          }\n        } catch (error) {\n          // If tier size exceeds liquidity, use null\n          const tierKey = sizeUSD >= 1000000 ? '1m' : `${sizeUSD / 1000}k`;\n          impacts[`size${tierKey}`] = '0';\n          if ([1000, 10000, 100000].includes(sizeUSD)) {\n            slippages[`slippage${tierKey}`] = '0';\n          }\n        }\n      }\n\n      // Store in database\n      await db.insert(priceImpactEstimates).values({\n        exchangeId: estimate.exchangeId,\n        symbol: estimate.symbol,\n        calculatedAt: estimate.timestamp,\n        size1k: impacts.size1k || '0',\n        size5k: impacts.size5k || '0',\n        size10k: impacts.size10k || '0',\n        size50k: impacts.size50k || '0',\n        size100k: impacts.size100k || '0',\n        size500k: impacts.size500k || '0',\n        size1m: impacts.size1m || '0',\n        slippage1k: slippages.slippage1k || '0',\n        slippage10k: slippages.slippage10k || '0',\n        slippage100k: slippages.slippage100k || '0',\n        liquidityScore: estimate.liquidityConsumed.toFixed(4),\n      });\n\n      logger.info('Stored price impact estimate', {\n        exchangeId: estimate.exchangeId,\n        symbol: estimate.symbol,\n        tiers: Object.keys(impacts).length,\n      });\n    } catch (error) {\n      logger.error('Failed to store price impact estimate', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get historical impact estimates\n   */\n  static async getHistoricalImpact(\n    exchangeId: string,\n    symbol: string,\n    orderSize: number,\n    lookbackHours: number = 24\n  ): Promise<Array<typeof priceImpactEstimates.$inferSelect>> {\n    try {\n      const startTime = new Date(Date.now() - lookbackHours * 60 * 60 * 1000);\n\n      const estimates = await db\n        .select()\n        .from(priceImpactEstimates)\n        .where(\n          and(\n            eq(priceImpactEstimates.exchangeId, exchangeId),\n            eq(priceImpactEstimates.symbol, symbol),\n            gte(priceImpactEstimates.calculatedAt, startTime)\n          )\n        )\n        .orderBy(desc(priceImpactEstimates.calculatedAt));\n\n      logger.debug('Retrieved historical impact estimates', {\n        exchangeId,\n        symbol,\n        count: estimates.length,\n      });\n\n      return estimates;\n    } catch (error) {\n      logger.error('Failed to get historical impact', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate average impact for size\n   */\n  static async calculateAverageImpact(\n    exchangeId: string,\n    symbol: string,\n    orderSize: number,\n    lookbackHours: number = 24\n  ): Promise<{\n    avgImpactPercent: number;\n    avgSlippageUSD: number;\n    sampleSize: number;\n    confidence: number;\n  }> {\n    try {\n      const historical = await this.getHistoricalImpact(\n        exchangeId,\n        symbol,\n        orderSize,\n        lookbackHours\n      );\n\n      if (historical.length === 0) {\n        throw new BadRequestError('No historical data available');\n      }\n\n      // Select appropriate size tier based on order size (in USD)\n      // Tiers: 1k, 5k, 10k, 50k, 100k, 500k, 1m\n      const selectTierField = (sizeUSD: number): {\n        impactField: keyof typeof historical[0];\n        slippageField: keyof typeof historical[0];\n      } => {\n        if (sizeUSD >= 1000000) return { impactField: 'size1m' as any, slippageField: 'slippage100k' as any };\n        if (sizeUSD >= 500000) return { impactField: 'size500k' as any, slippageField: 'slippage100k' as any };\n        if (sizeUSD >= 100000) return { impactField: 'size100k' as any, slippageField: 'slippage100k' as any };\n        if (sizeUSD >= 50000) return { impactField: 'size50k' as any, slippageField: 'slippage10k' as any };\n        if (sizeUSD >= 10000) return { impactField: 'size10k' as any, slippageField: 'slippage10k' as any };\n        if (sizeUSD >= 5000) return { impactField: 'size5k' as any, slippageField: 'slippage1k' as any };\n        return { impactField: 'size1k' as any, slippageField: 'slippage1k' as any };\n      };\n\n      // Get average price from historical data to estimate USD value\n      const avgPrice = historical.length > 0\n        ? parseFloat(historical[0].size10k ?? '0') > 0\n          ? parseFloat(historical[0].size10k ?? '0')\n          : 1\n        : 1;\n\n      const estimatedSizeUSD = orderSize * avgPrice;\n      const { impactField, slippageField } = selectTierField(estimatedSizeUSD);\n\n      const impacts = historical.map(h => parseFloat((h[impactField] as string) ?? '0'));\n      const slippages = historical.map(h => parseFloat((h[slippageField] as string) ?? '0'));\n\n      const avgImpactPercent = impacts.reduce((sum, val) => sum + val, 0) / impacts.length;\n      const avgSlippageUSD = slippages.reduce((sum, val) => sum + val, 0) / slippages.length;\n\n      // Confidence based on sample size\n      const confidence = Math.min(100, (historical.length / 100) * 100);\n\n      return {\n        avgImpactPercent,\n        avgSlippageUSD,\n        sampleSize: historical.length,\n        confidence,\n      };\n    } catch (error) {\n      logger.error('Failed to calculate average impact', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/pulse-indicator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":591,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":591,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pulse Indicator Service\n * ProfitPro-style momentum signals from order book\n *\n * Features:\n * - Real-time bullish/bearish momentum detection\n * - Signal strength calculation (0-100)\n * - Confidence scoring\n * - Multi-factor analysis (imbalance + pressure + momentum)\n * - Trend detection\n * - Divergence detection\n * - Signal filtering and validation\n */\n\nimport { db } from '@/db';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport { OrderBookImbalanceService } from './order-book-imbalance.service';\nimport { OrderBookAnalyticsService } from './order-book-analytics.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type {\n  OrderBookSnapshot,\n  OrderBookImbalance,\n  PulseSignal,\n  LiquidityScore,\n} from '../types/order-book.types';\n\nexport class PulseIndicatorService {\n  /**\n   * Generate Pulse Signal from order book state\n   * Combines imbalance, pressure, and momentum into single signal\n   */\n  static async generatePulseSignal(\n    exchangeId: string,\n    symbol: string\n  ): Promise<PulseSignal> {\n    try {\n      // Get latest snapshot\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n      if (!snapshot) {\n        throw new BadRequestError('No order book snapshot found');\n      }\n\n      // Get latest imbalance\n      let imbalance = await OrderBookImbalanceService.getLatestImbalance(exchangeId, symbol);\n\n      // If no imbalance exists, calculate it\n      if (!imbalance) {\n        imbalance = await OrderBookImbalanceService.calculateAndStore(exchangeId, symbol);\n      }\n\n      // Get liquidity score\n      let liquidityScore = await OrderBookAnalyticsService.getLatestLiquidityScore(exchangeId, symbol);\n\n      // If no liquidity score, calculate it\n      if (!liquidityScore) {\n        const analytics = await OrderBookAnalyticsService.analyzeAndStore(exchangeId, symbol);\n        liquidityScore = analytics.liquidityScore;\n      }\n\n      // Calculate signal components\n      const imbalanceComponent = this.calculateImbalanceComponent(imbalance);\n      const pressureComponent = this.calculatePressureComponent(imbalance);\n      const momentumComponent = this.calculateMomentumComponent(imbalance);\n      const liquidityComponent = this.calculateLiquidityComponent(liquidityScore);\n\n      // Combine components\n      const { direction, strength, reason } = this.combineComponents(\n        imbalanceComponent,\n        pressureComponent,\n        momentumComponent,\n        liquidityComponent\n      );\n\n      // Calculate confidence\n      const confidence = this.calculateConfidence(\n        imbalance,\n        liquidityScore,\n        snapshot\n      );\n\n      const signal: PulseSignal = {\n        exchangeId,\n        symbol,\n        timestamp: new Date(),\n        direction,\n        strength,\n        imbalance: imbalance.imbalance10,\n        pressure: imbalance.pressureScore,\n        momentum: imbalance.imbalanceMomentum || 0,\n        confidence,\n        reason,\n      };\n\n      logger.info('Generated Pulse signal', {\n        exchangeId,\n        symbol,\n        direction,\n        strength: strength.toFixed(2),\n        confidence: confidence.toFixed(2),\n      });\n\n      return signal;\n    } catch (error) {\n      logger.error('Failed to generate Pulse signal', {\n        exchangeId,\n        symbol,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Detect trend from historical signals\n   */\n  static async detectTrend(\n    exchangeId: string,\n    symbol: string,\n    lookbackMinutes: number = 15\n  ): Promise<{\n    trend: 'bullish' | 'bearish' | 'neutral';\n    strength: number;\n    consistency: number; // How consistent the signals are\n  }> {\n    try {\n      const endTime = new Date();\n      const startTime = new Date(endTime.getTime() - lookbackMinutes * 60 * 1000);\n\n      // Get historical imbalance data\n      const historicalData = await OrderBookImbalanceService.getHistoricalImbalance(\n        exchangeId,\n        symbol,\n        startTime,\n        endTime,\n        50\n      );\n\n      if (historicalData.length < 5) {\n        return { trend: 'neutral', strength: 0, consistency: 0 };\n      }\n\n      // Count bullish/bearish signals\n      let bullishCount = 0;\n      let bearishCount = 0;\n      let totalPressure = 0;\n\n      historicalData.forEach((data) => {\n        if (data.pressureScore > 30) bullishCount++;\n        else if (data.pressureScore < -30) bearishCount++;\n        totalPressure += data.pressureScore;\n      });\n\n      const avgPressure = totalPressure / historicalData.length;\n      const total = historicalData.length;\n      const consistency = Math.max(bullishCount, bearishCount) / total;\n\n      let trend: 'bullish' | 'bearish' | 'neutral';\n      let strength: number;\n\n      if (bullishCount > bearishCount * 1.5 && avgPressure > 20) {\n        trend = 'bullish';\n        strength = Math.min(100, (bullishCount / total) * 100);\n      } else if (bearishCount > bullishCount * 1.5 && avgPressure < -20) {\n        trend = 'bearish';\n        strength = Math.min(100, (bearishCount / total) * 100);\n      } else {\n        trend = 'neutral';\n        strength = Math.max(0, 100 - Math.abs(avgPressure));\n      }\n\n      logger.debug('Detected trend', {\n        exchangeId,\n        symbol,\n        trend,\n        strength: strength.toFixed(2),\n        consistency: consistency.toFixed(2),\n      });\n\n      return { trend, strength, consistency };\n    } catch (error) {\n      logger.error('Failed to detect trend', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Detect divergence between price and order book signals\n   */\n  static async detectDivergence(\n    exchangeId: string,\n    symbol: string,\n    priceChange: number // % price change over period\n  ): Promise<{\n    hasDivergence: boolean;\n    type: 'bullish' | 'bearish' | 'none';\n    strength: number;\n    description: string;\n  }> {\n    try {\n      // Get current imbalance\n      const currentImbalance = await OrderBookImbalanceService.getLatestImbalance(\n        exchangeId,\n        symbol\n      );\n\n      if (!currentImbalance) {\n        return {\n          hasDivergence: false,\n          type: 'none',\n          strength: 0,\n          description: 'No data available',\n        };\n      }\n\n      const pressureScore = currentImbalance.pressureScore;\n\n      // Bullish divergence: price down but order book bullish\n      if (priceChange < -1 && pressureScore > 40) {\n        const strength = Math.min(100, Math.abs(priceChange) * 10 + pressureScore);\n        return {\n          hasDivergence: true,\n          type: 'bullish',\n          strength,\n          description: `Price down ${priceChange.toFixed(1)}% but strong bid pressure (${pressureScore.toFixed(0)})`,\n        };\n      }\n\n      // Bearish divergence: price up but order book bearish\n      if (priceChange > 1 && pressureScore < -40) {\n        const strength = Math.min(100, priceChange * 10 + Math.abs(pressureScore));\n        return {\n          hasDivergence: true,\n          type: 'bearish',\n          strength,\n          description: `Price up ${priceChange.toFixed(1)}% but strong ask pressure (${pressureScore.toFixed(0)})`,\n        };\n      }\n\n      return {\n        hasDivergence: false,\n        type: 'none',\n        strength: 0,\n        description: 'No significant divergence detected',\n      };\n    } catch (error) {\n      logger.error('Failed to detect divergence', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Validate signal quality\n   */\n  static validateSignal(signal: PulseSignal): {\n    isValid: boolean;\n    quality: 'high' | 'medium' | 'low';\n    warnings: string[];\n  } {\n    const warnings: string[] = [];\n\n    // Check confidence\n    if (signal.confidence < 50) {\n      warnings.push('Low confidence signal');\n    }\n\n    // Check strength\n    if (signal.strength < 30) {\n      warnings.push('Weak signal strength');\n    }\n\n    // Check for conflicting indicators\n    if (signal.direction === 'bullish' && signal.pressure < 0) {\n      warnings.push('Conflicting pressure indicator');\n    }\n    if (signal.direction === 'bearish' && signal.pressure > 0) {\n      warnings.push('Conflicting pressure indicator');\n    }\n\n    // Determine quality\n    let quality: 'high' | 'medium' | 'low';\n    if (signal.confidence >= 75 && signal.strength >= 60) {\n      quality = 'high';\n    } else if (signal.confidence >= 50 && signal.strength >= 40) {\n      quality = 'medium';\n    } else {\n      quality = 'low';\n    }\n\n    const isValid = warnings.length < 2 && signal.confidence >= 40;\n\n    return { isValid, quality, warnings };\n  }\n\n  /**\n   * Filter signals for trading\n   */\n  static async filterSignalsForTrading(\n    exchangeId: string,\n    symbol: string,\n    minConfidence: number = 60,\n    minStrength: number = 50\n  ): Promise<PulseSignal | null> {\n    const signal = await this.generatePulseSignal(exchangeId, symbol);\n\n    // Apply filters\n    if (signal.confidence < minConfidence) {\n      logger.debug('Signal filtered: low confidence', {\n        confidence: signal.confidence,\n        minConfidence,\n      });\n      return null;\n    }\n\n    if (signal.strength < minStrength) {\n      logger.debug('Signal filtered: low strength', {\n        strength: signal.strength,\n        minStrength,\n      });\n      return null;\n    }\n\n    // Validate signal\n    const validation = this.validateSignal(signal);\n    if (!validation.isValid) {\n      logger.debug('Signal filtered: invalid', {\n        warnings: validation.warnings,\n      });\n      return null;\n    }\n\n    // Only return high or medium quality signals\n    if (validation.quality === 'low') {\n      logger.debug('Signal filtered: low quality');\n      return null;\n    }\n\n    return signal;\n  }\n\n  /**\n   * Calculate imbalance component (-100 to 100)\n   */\n  private static calculateImbalanceComponent(imbalance: OrderBookImbalance): number {\n    // Use 10-level imbalance, scale to -100 to 100\n    return imbalance.imbalance10 * 100;\n  }\n\n  /**\n   * Calculate pressure component (-100 to 100)\n   */\n  private static calculatePressureComponent(imbalance: OrderBookImbalance): number {\n    // Pressure score is already -100 to 100\n    return imbalance.pressureScore;\n  }\n\n  /**\n   * Calculate momentum component (-100 to 100)\n   */\n  private static calculateMomentumComponent(imbalance: OrderBookImbalance): number {\n    if (!imbalance.imbalanceMomentum) return 0;\n\n    // Momentum is rate of change, scale appropriately\n    // Cap at -100 to 100\n    return Math.max(-100, Math.min(100, imbalance.imbalanceMomentum * 1000));\n  }\n\n  /**\n   * Calculate liquidity component (0 to 100)\n   */\n  private static calculateLiquidityComponent(liquidityScore: LiquidityScore): number {\n    // Higher liquidity = more reliable signals\n    return liquidityScore.score;\n  }\n\n  /**\n   * Combine all components into final signal\n   */\n  private static combineComponents(\n    imbalance: number,\n    pressure: number,\n    momentum: number,\n    liquidity: number\n  ): {\n    direction: 'bullish' | 'bearish' | 'neutral';\n    strength: number;\n    reason: string;\n  } {\n    // Weighted combination\n    const weights = {\n      imbalance: 0.35, // 35%\n      pressure: 0.35, // 35%\n      momentum: 0.20, // 20%\n      liquidity: 0.10, // 10% (affects strength not direction)\n    };\n\n    const combinedScore =\n      imbalance * weights.imbalance +\n      pressure * weights.pressure +\n      momentum * weights.momentum;\n\n    // Adjust strength based on liquidity\n    const rawStrength = Math.abs(combinedScore);\n    const liquidityFactor = liquidity / 100;\n    const strength = Math.min(100, rawStrength * liquidityFactor);\n\n    // Determine direction\n    let direction: 'bullish' | 'bearish' | 'neutral';\n    let reason: string;\n\n    if (combinedScore > 30) {\n      direction = 'bullish';\n      reason = this.buildReason('bullish', imbalance, pressure, momentum);\n    } else if (combinedScore < -30) {\n      direction = 'bearish';\n      reason = this.buildReason('bearish', imbalance, pressure, momentum);\n    } else {\n      direction = 'neutral';\n      reason = 'Balanced order book - no clear directional bias';\n    }\n\n    return { direction, strength, reason };\n  }\n\n  /**\n   * Build human-readable reason string\n   */\n  private static buildReason(\n    direction: 'bullish' | 'bearish',\n    imbalance: number,\n    pressure: number,\n    momentum: number\n  ): string {\n    const reasons: string[] = [];\n\n    if (direction === 'bullish') {\n      if (imbalance > 30) reasons.push('strong bid imbalance');\n      if (pressure > 30) reasons.push('buying pressure');\n      if (momentum > 20) reasons.push('increasing momentum');\n    } else {\n      if (imbalance < -30) reasons.push('strong ask imbalance');\n      if (pressure < -30) reasons.push('selling pressure');\n      if (momentum < -20) reasons.push('decreasing momentum');\n    }\n\n    if (reasons.length === 0) {\n      return direction === 'bullish' ? 'Moderate bullish bias' : 'Moderate bearish bias';\n    }\n\n    return reasons.join(', ');\n  }\n\n  /**\n   * Calculate confidence score (0-100)\n   */\n  private static calculateConfidence(\n    imbalance: OrderBookImbalance,\n    liquidityScore: LiquidityScore,\n    snapshot: OrderBookSnapshot\n  ): number {\n    let confidence = 50; // Base confidence\n\n    // Factor 1: Liquidity quality (0-25 points)\n    confidence += (liquidityScore.score / 100) * 25;\n\n    // Factor 2: Imbalance consistency across levels (0-25 points)\n    const imbalances = [\n      imbalance.imbalance5,\n      imbalance.imbalance10,\n      imbalance.imbalance20,\n      imbalance.imbalance50,\n    ];\n    const allSameDirection = imbalances.every((i) => i > 0) || imbalances.every((i) => i < 0);\n    if (allSameDirection) {\n      confidence += 25;\n    } else {\n      const avgImbalance = imbalances.reduce((a, b) => a + b, 0) / imbalances.length;\n      const variance =\n        imbalances.reduce((sum, val) => sum + Math.pow(val - avgImbalance, 2), 0) /\n        imbalances.length;\n      const consistency = Math.max(0, 1 - variance * 10);\n      confidence += consistency * 25;\n    }\n\n    // Factor 3: Spread tightness (0-15 points)\n    if (snapshot.spreadPercent && snapshot.spreadPercent < 0.1) {\n      confidence += 15;\n    } else if (snapshot.spreadPercent && snapshot.spreadPercent < 0.5) {\n      confidence += 10;\n    } else if (snapshot.spreadPercent && snapshot.spreadPercent < 1.0) {\n      confidence += 5;\n    }\n\n    // Factor 4: Depth quality (0-10 points)\n    if (snapshot.totalDepth && snapshot.totalDepth > 1000000) {\n      // > $1M\n      confidence += 10;\n    } else if (snapshot.totalDepth && snapshot.totalDepth > 500000) {\n      confidence += 5;\n    }\n\n    return Math.min(100, Math.max(0, confidence));\n  }\n\n  /**\n   * Get signal history for analysis\n   */\n  static async getSignalHistory(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date\n  ): Promise<PulseSignal[]> {\n    try {\n      // Get historical imbalance data\n      const historicalImbalance = await OrderBookImbalanceService.getHistoricalImbalance(\n        exchangeId,\n        symbol,\n        startTime,\n        endTime,\n        1000\n      );\n\n      // Convert to signals (simplified - in production, would store actual signals)\n      const signals: PulseSignal[] = historicalImbalance.map((imbalance) => {\n        const signal = OrderBookImbalanceService.generateSignal(imbalance);\n        return {\n          exchangeId,\n          symbol,\n          timestamp: imbalance.timestamp,\n          direction: signal.direction as 'bullish' | 'bearish' | 'neutral',\n          strength: signal.strength,\n          imbalance: imbalance.imbalance10,\n          pressure: imbalance.pressureScore,\n          momentum: imbalance.imbalanceMomentum || 0,\n          confidence: 50, // Simplified - would need full calculation\n          reason: signal.reason,\n        };\n      });\n\n      return signals;\n    } catch (error) {\n      logger.error('Failed to get signal history', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate signal accuracy over time\n   */\n  static async calculateSignalAccuracy(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date,\n    priceData: { timestamp: Date; price: number }[]\n  ): Promise<{\n    totalSignals: number;\n    correctSignals: number;\n    accuracy: number;\n    bullishAccuracy: number;\n    bearishAccuracy: number;\n  }> {\n    try {\n      const signals = await this.getSignalHistory(exchangeId, symbol, startTime, endTime);\n\n      if (signals.length === 0 || priceData.length === 0) {\n        return {\n          totalSignals: 0,\n          correctSignals: 0,\n          accuracy: 0,\n          bullishAccuracy: 0,\n          bearishAccuracy: 0,\n        };\n      }\n\n      let totalSignals = 0;\n      let correctSignals = 0;\n      let bullishCorrect = 0;\n      let bullishTotal = 0;\n      let bearishCorrect = 0;\n      let bearishTotal = 0;\n\n      // Check each signal\n      signals.forEach((signal, i) => {\n        if (signal.direction === 'neutral') return;\n\n        // Find next price point (5 minutes later)\n        const futureTime = new Date(signal.timestamp.getTime() + 5 * 60 * 1000);\n        const currentPrice = priceData.find(\n          (p) => Math.abs(p.timestamp.getTime() - signal.timestamp.getTime()) < 60000\n        )?.price;\n        const futurePrice = priceData.find(\n          (p) => Math.abs(p.timestamp.getTime() - futureTime.getTime()) < 60000\n        )?.price;\n\n        if (!currentPrice || !futurePrice) return;\n\n        const priceChange = ((futurePrice - currentPrice) / currentPrice) * 100;\n\n        totalSignals++;\n        if (signal.direction === 'bullish') {\n          bullishTotal++;\n          if (priceChange > 0) {\n            correctSignals++;\n            bullishCorrect++;\n          }\n        } else {\n          bearishTotal++;\n          if (priceChange < 0) {\n            correctSignals++;\n            bearishCorrect++;\n          }\n        }\n      });\n\n      const accuracy = totalSignals > 0 ? (correctSignals / totalSignals) * 100 : 0;\n      const bullishAccuracy = bullishTotal > 0 ? (bullishCorrect / bullishTotal) * 100 : 0;\n      const bearishAccuracy = bearishTotal > 0 ? (bearishCorrect / bearishTotal) * 100 : 0;\n\n      logger.info('Calculated signal accuracy', {\n        exchangeId,\n        symbol,\n        accuracy: accuracy.toFixed(2),\n        totalSignals,\n        correctSignals,\n      });\n\n      return {\n        totalSignals,\n        correctSignals,\n        accuracy,\n        bullishAccuracy,\n        bearishAccuracy,\n      };\n    } catch (error) {\n      logger.error('Failed to calculate signal accuracy', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/services/superdom.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DOMDisplayData' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SuperDOM Service (Nelogica-style Trading Interface)\n * Professional depth of market visualization and trading interface\n *\n * Features inspired by Nelogica Profit Ultra:\n * - SuperDOM interface data generation\n * - Volume at Price display\n * - One-Click Trading data structures\n * - AutoOp (automated gain/loss orders)\n * - Ladder interface support\n * - Real-time order book updates\n * - Market depth visualization\n * - Working orders display\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, gte, lte } from 'drizzle-orm';\nimport { orderBookSnapshots, orderBookImbalance } from '../schema/order-book.schema';\nimport { OrderBookSnapshotService } from './order-book-snapshot.service';\nimport { OrderBookAnalyticsService } from './order-book-analytics.service';\nimport logger from '@/utils/logger';\nimport { BadRequestError } from '@/utils/errors';\nimport type {\n  OrderBookSnapshot,\n  DOMDisplayData,\n  DOMLevelData,\n  OrderBookLevel,\n} from '../types/order-book.types';\n\n/**\n * SuperDOM Display Configuration\n */\nexport interface SuperDOMConfig {\n  // Display settings\n  priceLevels: number; // Number of price levels to show (default: 50)\n  priceTickSize: number; // Minimum price movement\n  volumeFormat: 'contracts' | 'lots' | 'usd'; // Volume display format\n\n  // Visualization\n  showCumulative: boolean; // Show cumulative volume\n  showImbalance: boolean; // Show bid/ask imbalance\n  showLiquidityZones: boolean; // Highlight liquidity zones\n  showLargeOrders: boolean; // Highlight whale orders\n\n  // Trading features\n  enableOneClick: boolean; // Enable one-click trading\n  defaultOrderSize: number; // Default order size\n  quickOrderSizes: number[]; // Quick access order sizes\n\n  // AutoOp settings\n  autoOpEnabled: boolean; // Enable automated orders\n  autoOpGainTicks: number; // Ticks for gain target\n  autoOpLossTicks: number; // Ticks for stop loss\n  autoOpTrailing: boolean; // Enable trailing stop\n}\n\n/**\n * SuperDOM Data Point\n * Complete data for a single price level in SuperDOM\n */\nexport interface SuperDOMLevel extends DOMLevelData {\n  // Trading actions\n  canBuy: boolean;\n  canSell: boolean;\n\n  // Working orders (user's orders at this level)\n  workingBuyOrders: number;\n  workingSellOrders: number;\n\n  // Price action indicators\n  isNewHigh?: boolean;\n  isNewLow?: boolean;\n  volumeChange?: number; // Change from previous snapshot\n\n  // AutoOp data\n  isGainTarget?: boolean; // Matches gain target price\n  isStopLoss?: boolean; // Matches stop loss price\n  isTrailingStop?: boolean; // Matches trailing stop price\n}\n\n/**\n * SuperDOM Display Data\n */\nexport interface SuperDOMData {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Price levels (sorted by price desc)\n  levels: SuperDOMLevel[];\n\n  // Current market\n  lastPrice: number;\n  midPrice: number;\n  spread: number;\n  spreadPercent: number;\n\n  // Volume totals\n  totalBidVolume: number;\n  totalAskVolume: number;\n  totalBidOrders: number;\n  totalAskOrders: number;\n\n  // Imbalance\n  overallImbalance: number; // -100 to +100\n\n  // Price boundaries\n  highestBid: number;\n  lowestAsk: number;\n  highestPrice: number; // Top of ladder\n  lowestPrice: number; // Bottom of ladder\n\n  // Statistics\n  avgBidSize: number;\n  avgAskSize: number;\n  largeOrderThreshold: number; // What is considered a \"large\" order\n\n  // Configuration\n  config: SuperDOMConfig;\n}\n\n/**\n * One-Click Trading Action\n */\nexport interface OneClickAction {\n  action: 'buy' | 'sell';\n  price: number;\n  size: number;\n  orderType: 'limit' | 'market' | 'stop';\n  timeInForce: 'GTC' | 'IOC' | 'FOK';\n}\n\n/**\n * AutoOp Order Configuration\n */\nexport interface AutoOpConfig {\n  enabled: boolean;\n\n  // Entry\n  entryPrice: number;\n  entrySize: number;\n  entrySide: 'buy' | 'sell';\n\n  // Exit targets\n  gainTarget?: number; // Price for profit taking\n  stopLoss?: number; // Price for stop loss\n\n  // Trailing stop\n  trailingStopEnabled: boolean;\n  trailingStopDistance?: number; // Ticks from current price\n  trailingStopActivationPrice?: number; // Price to activate trailing\n\n  // OCO (One-Cancels-Other)\n  ocoEnabled: boolean; // Gain cancels stop, stop cancels gain\n}\n\n/**\n * Volume at Price Data\n */\nexport interface VolumeAtPriceData {\n  exchangeId: string;\n  symbol: string;\n  startTime: Date;\n  endTime: Date;\n\n  // Volume by price level\n  levels: {\n    price: number;\n    buyVolume: number;\n    sellVolume: number;\n    totalVolume: number;\n    trades: number;\n    avgTradeSize: number;\n    delta: number; // Buy - Sell\n  }[];\n\n  // Key levels\n  maxVolumePrice: number; // Price with highest volume\n  maxBuyPrice: number; // Price with highest buy volume\n  maxSellPrice: number; // Price with highest sell volume\n}\n\nexport class SuperDOMService {\n  /**\n   * Generate SuperDOM display data\n   */\n  static async generateSuperDOM(\n    exchangeId: string,\n    symbol: string,\n    config: Partial<SuperDOMConfig> = {}\n  ): Promise<SuperDOMData> {\n    try {\n      // Get latest order book snapshot\n      const snapshot = await OrderBookSnapshotService.getLatestSnapshot(exchangeId, symbol);\n\n      if (!snapshot) {\n        throw new BadRequestError('No order book data available');\n      }\n\n      // Get latest imbalance data\n      const imbalanceData = await db\n        .select()\n        .from(orderBookImbalance)\n        .where(\n          and(\n            eq(orderBookImbalance.exchangeId, exchangeId),\n            eq(orderBookImbalance.symbol, symbol)\n          )\n        )\n        .orderBy(desc(orderBookImbalance.timestamp))\n        .limit(1);\n\n      const imbalance = imbalanceData[0];\n\n      // Merge config with defaults\n      const fullConfig: SuperDOMConfig = {\n        priceLevels: config.priceLevels || 50,\n        priceTickSize: config.priceTickSize || 0.01,\n        volumeFormat: config.volumeFormat || 'usd',\n        showCumulative: config.showCumulative ?? true,\n        showImbalance: config.showImbalance ?? true,\n        showLiquidityZones: config.showLiquidityZones ?? true,\n        showLargeOrders: config.showLargeOrders ?? true,\n        enableOneClick: config.enableOneClick ?? true,\n        defaultOrderSize: config.defaultOrderSize || 100,\n        quickOrderSizes: config.quickOrderSizes || [10, 25, 50, 100, 250, 500],\n        autoOpEnabled: config.autoOpEnabled ?? true,\n        autoOpGainTicks: config.autoOpGainTicks || 10,\n        autoOpLossTicks: config.autoOpLossTicks || 5,\n        autoOpTrailing: config.autoOpTrailing ?? false,\n      };\n\n      // Generate DOM display data\n      const domData = OrderBookAnalyticsService.generateDOMDisplayData(snapshot);\n\n      // Calculate large order threshold (2x average size)\n      const avgSize = (domData.totalBidVolume + domData.totalAskVolume) /\n                     (domData.totalBidOrders + domData.totalAskOrders || 1);\n      const largeOrderThreshold = avgSize * 2;\n\n      // Enhance levels with SuperDOM data\n      const superDOMLevels: SuperDOMLevel[] = domData.levels.map((level) => {\n        const isLargeOrder =\n          !!(level.bidSize && level.bidSize > largeOrderThreshold) ||\n          !!(level.askSize && level.askSize > largeOrderThreshold);\n\n        return {\n          ...level,\n          canBuy: !!level.askSize, // Can buy if there's ask liquidity\n          canSell: !!level.bidSize, // Can sell if there's bid liquidity\n          workingBuyOrders: 0, // Would come from user's order tracking\n          workingSellOrders: 0,\n          isLargeOrder: fullConfig.showLargeOrders ? isLargeOrder : undefined,\n        };\n      });\n\n      // Calculate overall imbalance\n      const overallImbalance = imbalance\n        ? parseFloat(imbalance.imbalance10 ?? '0')\n        : this.calculateSimpleImbalance(snapshot);\n\n      // Determine price boundaries\n      const prices = superDOMLevels.map(l => l.price).sort((a, b) => b - a);\n      const highestPrice = prices[0];\n      const lowestPrice = prices[prices.length - 1];\n\n      const result: SuperDOMData = {\n        exchangeId,\n        symbol,\n        timestamp: snapshot.timestamp,\n        levels: superDOMLevels,\n        lastPrice: snapshot.midPrice || ((snapshot.bestBid || 0) + (snapshot.bestAsk || 0)) / 2,\n        midPrice: snapshot.midPrice || 0,\n        spread: snapshot.spread || 0,\n        spreadPercent: snapshot.spreadPercent || 0,\n        totalBidVolume: domData.totalBidVolume,\n        totalAskVolume: domData.totalAskVolume,\n        totalBidOrders: domData.totalBidOrders,\n        totalAskOrders: domData.totalAskOrders,\n        overallImbalance,\n        highestBid: snapshot.bestBid || 0,\n        lowestAsk: snapshot.bestAsk || 0,\n        highestPrice,\n        lowestPrice,\n        avgBidSize: domData.totalBidVolume / (domData.totalBidOrders || 1),\n        avgAskSize: domData.totalAskVolume / (domData.totalAskOrders || 1),\n        largeOrderThreshold,\n        config: fullConfig,\n      };\n\n      logger.debug('Generated SuperDOM data', {\n        exchangeId,\n        symbol,\n        levels: superDOMLevels.length,\n        imbalance: overallImbalance,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to generate SuperDOM data', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate simple imbalance from snapshot\n   */\n  private static calculateSimpleImbalance(snapshot: OrderBookSnapshot): number {\n    const bidVolume = snapshot.bids\n      .slice(0, 10)\n      .reduce((sum, level) => sum + level.price * level.amount, 0);\n\n    const askVolume = snapshot.asks\n      .slice(0, 10)\n      .reduce((sum, level) => sum + level.price * level.amount, 0);\n\n    const total = bidVolume + askVolume;\n    if (total === 0) return 0;\n\n    return ((bidVolume - askVolume) / total) * 100;\n  }\n\n  /**\n   * Generate One-Click Trading action\n   */\n  static generateOneClickAction(\n    side: 'buy' | 'sell',\n    price: number,\n    config: SuperDOMConfig\n  ): OneClickAction {\n    return {\n      action: side,\n      price,\n      size: config.defaultOrderSize,\n      orderType: 'limit',\n      timeInForce: 'GTC',\n    };\n  }\n\n  /**\n   * Calculate AutoOp prices (gain target and stop loss)\n   */\n  static calculateAutoOpPrices(\n    entryPrice: number,\n    entrySide: 'buy' | 'sell',\n    config: SuperDOMConfig,\n    tickSize: number = 0.01\n  ): {\n    gainTarget: number;\n    stopLoss: number;\n  } {\n    const gainDistance = config.autoOpGainTicks * tickSize;\n    const lossDistance = config.autoOpLossTicks * tickSize;\n\n    if (entrySide === 'buy') {\n      return {\n        gainTarget: entryPrice + gainDistance, // Sell higher\n        stopLoss: entryPrice - lossDistance, // Sell lower to cut loss\n      };\n    } else {\n      return {\n        gainTarget: entryPrice - gainDistance, // Buy lower\n        stopLoss: entryPrice + lossDistance, // Buy higher to cut loss\n      };\n    }\n  }\n\n  /**\n   * Generate AutoOp configuration\n   */\n  static generateAutoOpConfig(\n    entryPrice: number,\n    entrySize: number,\n    entrySide: 'buy' | 'sell',\n    config: SuperDOMConfig,\n    tickSize: number = 0.01\n  ): AutoOpConfig {\n    const { gainTarget, stopLoss } = this.calculateAutoOpPrices(\n      entryPrice,\n      entrySide,\n      config,\n      tickSize\n    );\n\n    return {\n      enabled: config.autoOpEnabled,\n      entryPrice,\n      entrySize,\n      entrySide,\n      gainTarget,\n      stopLoss,\n      trailingStopEnabled: config.autoOpTrailing,\n      trailingStopDistance: config.autoOpTrailing ? config.autoOpLossTicks : undefined,\n      ocoEnabled: true, // Always use OCO for safety\n    };\n  }\n\n  /**\n   * Update trailing stop price\n   */\n  static updateTrailingStop(\n    currentPrice: number,\n    autoOpConfig: AutoOpConfig,\n    tickSize: number = 0.01\n  ): AutoOpConfig {\n    if (!autoOpConfig.trailingStopEnabled || !autoOpConfig.trailingStopDistance) {\n      return autoOpConfig;\n    }\n\n    const distance = autoOpConfig.trailingStopDistance * tickSize;\n\n    // For buy positions: move stop up as price goes up\n    if (autoOpConfig.entrySide === 'buy') {\n      const newStopLoss = currentPrice - distance;\n\n      // Only move stop up, never down\n      if (newStopLoss > autoOpConfig.stopLoss!) {\n        return {\n          ...autoOpConfig,\n          stopLoss: newStopLoss,\n        };\n      }\n    }\n    // For sell positions: move stop down as price goes down\n    else {\n      const newStopLoss = currentPrice + distance;\n\n      // Only move stop down, never up\n      if (newStopLoss < autoOpConfig.stopLoss!) {\n        return {\n          ...autoOpConfig,\n          stopLoss: newStopLoss,\n        };\n      }\n    }\n\n    return autoOpConfig;\n  }\n\n  /**\n   * Check if price hit AutoOp target\n   */\n  static checkAutoOpTrigger(\n    currentPrice: number,\n    autoOpConfig: AutoOpConfig\n  ): {\n    triggered: boolean;\n    triggerType?: 'gain' | 'loss';\n    action?: 'buy' | 'sell';\n    price: number;\n  } {\n    if (!autoOpConfig.enabled) {\n      return { triggered: false, price: currentPrice };\n    }\n\n    // Check gain target\n    if (autoOpConfig.gainTarget) {\n      const gainHit = autoOpConfig.entrySide === 'buy'\n        ? currentPrice >= autoOpConfig.gainTarget\n        : currentPrice <= autoOpConfig.gainTarget;\n\n      if (gainHit) {\n        return {\n          triggered: true,\n          triggerType: 'gain',\n          action: autoOpConfig.entrySide === 'buy' ? 'sell' : 'buy',\n          price: autoOpConfig.gainTarget,\n        };\n      }\n    }\n\n    // Check stop loss\n    if (autoOpConfig.stopLoss) {\n      const lossHit = autoOpConfig.entrySide === 'buy'\n        ? currentPrice <= autoOpConfig.stopLoss\n        : currentPrice >= autoOpConfig.stopLoss;\n\n      if (lossHit) {\n        return {\n          triggered: true,\n          triggerType: 'loss',\n          action: autoOpConfig.entrySide === 'buy' ? 'sell' : 'buy',\n          price: autoOpConfig.stopLoss,\n        };\n      }\n    }\n\n    return { triggered: false, price: currentPrice };\n  }\n\n  /**\n   * Generate Volume at Price data\n   */\n  static async generateVolumeAtPrice(\n    exchangeId: string,\n    symbol: string,\n    startTime: Date,\n    endTime: Date\n  ): Promise<VolumeAtPriceData> {\n    try {\n      // Get all snapshots in time range\n      const snapshots = await db\n        .select()\n        .from(orderBookSnapshots)\n        .where(\n          and(\n            eq(orderBookSnapshots.exchangeId, exchangeId),\n            eq(orderBookSnapshots.symbol, symbol),\n            gte(orderBookSnapshots.timestamp, startTime),\n            lte(orderBookSnapshots.timestamp, endTime)\n          )\n        )\n        .orderBy(orderBookSnapshots.timestamp);\n\n      if (snapshots.length === 0) {\n        throw new BadRequestError('No order book data for specified time range');\n      }\n\n      // Aggregate volume by price level\n      const volumeByPrice = new Map<number, {\n        buyVolume: number;\n        sellVolume: number;\n        totalVolume: number;\n        trades: number;\n      }>();\n\n      snapshots.forEach((snapshot) => {\n        const bids = snapshot.bids as any as OrderBookLevel[];\n        const asks = snapshot.asks as any as OrderBookLevel[];\n\n        // Process bids (buy volume)\n        bids.forEach((level) => {\n          const volume = level.price * level.amount;\n          const existing = volumeByPrice.get(level.price);\n\n          if (existing) {\n            existing.buyVolume += volume;\n            existing.totalVolume += volume;\n            existing.trades += 1;\n          } else {\n            volumeByPrice.set(level.price, {\n              buyVolume: volume,\n              sellVolume: 0,\n              totalVolume: volume,\n              trades: 1,\n            });\n          }\n        });\n\n        // Process asks (sell volume)\n        asks.forEach((level) => {\n          const volume = level.price * level.amount;\n          const existing = volumeByPrice.get(level.price);\n\n          if (existing) {\n            existing.sellVolume += volume;\n            existing.totalVolume += volume;\n            existing.trades += 1;\n          } else {\n            volumeByPrice.set(level.price, {\n              buyVolume: 0,\n              sellVolume: volume,\n              totalVolume: volume,\n              trades: 1,\n            });\n          }\n        });\n      });\n\n      // Convert to array and calculate metrics\n      const levels = Array.from(volumeByPrice.entries())\n        .map(([price, data]) => ({\n          price,\n          buyVolume: data.buyVolume,\n          sellVolume: data.sellVolume,\n          totalVolume: data.totalVolume,\n          trades: data.trades,\n          avgTradeSize: data.totalVolume / data.trades,\n          delta: data.buyVolume - data.sellVolume,\n        }))\n        .sort((a, b) => b.price - a.price); // Sort by price desc\n\n      // Find key levels\n      const maxVolumeLevel = levels.reduce((max, level) =>\n        level.totalVolume > max.totalVolume ? level : max\n      );\n\n      const maxBuyLevel = levels.reduce((max, level) =>\n        level.buyVolume > max.buyVolume ? level : max\n      );\n\n      const maxSellLevel = levels.reduce((max, level) =>\n        level.sellVolume > max.sellVolume ? level : max\n      );\n\n      const result: VolumeAtPriceData = {\n        exchangeId,\n        symbol,\n        startTime,\n        endTime,\n        levels,\n        maxVolumePrice: maxVolumeLevel.price,\n        maxBuyPrice: maxBuyLevel.price,\n        maxSellPrice: maxSellLevel.price,\n      };\n\n      logger.info('Generated Volume at Price data', {\n        exchangeId,\n        symbol,\n        priceLevels: levels.length,\n        totalVolume: levels.reduce((sum, l) => sum + l.totalVolume, 0),\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to generate Volume at Price data', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get ladder display (price levels around current price)\n   */\n  static getLadderDisplay(\n    superDOM: SuperDOMData,\n    levelsAbove: number = 25,\n    levelsBelow: number = 25\n  ): SuperDOMLevel[] {\n    const currentPrice = superDOM.lastPrice;\n\n    // Sort levels by distance from current price\n    const sorted = [...superDOM.levels].sort((a, b) => {\n      const distA = Math.abs(a.price - currentPrice);\n      const distB = Math.abs(b.price - currentPrice);\n      return distA - distB;\n    });\n\n    // Get levels above current price\n    const above = sorted\n      .filter(l => l.price > currentPrice)\n      .slice(0, levelsAbove)\n      .sort((a, b) => b.price - a.price); // Sort desc\n\n    // Get levels below current price\n    const below = sorted\n      .filter(l => l.price < currentPrice)\n      .slice(0, levelsBelow)\n      .sort((a, b) => b.price - a.price); // Sort desc\n\n    // Combine: above + current + below\n    return [...above, ...below];\n  }\n\n  /**\n   * Get quick order sizes for one-click trading\n   */\n  static getQuickOrderSizes(config: SuperDOMConfig): number[] {\n    return config.quickOrderSizes;\n  }\n\n  /**\n   * Validate order size\n   */\n  static validateOrderSize(\n    size: number,\n    superDOM: SuperDOMData,\n    side: 'buy' | 'sell'\n  ): {\n    valid: boolean;\n    reason?: string;\n    maxSize?: number;\n  } {\n    if (size <= 0) {\n      return { valid: false, reason: 'Order size must be positive' };\n    }\n\n    // Check against available liquidity\n    const availableLiquidity = side === 'buy'\n      ? superDOM.totalAskVolume\n      : superDOM.totalBidVolume;\n\n    if (size > availableLiquidity * 0.5) {\n      return {\n        valid: false,\n        reason: 'Order size exceeds 50% of available liquidity',\n        maxSize: Math.floor(availableLiquidity * 0.5),\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Calculate market impact for order size\n   */\n  static calculateMarketImpact(\n    orderSize: number,\n    side: 'buy' | 'sell',\n    superDOM: SuperDOMData\n  ): {\n    impactPercent: number;\n    avgPrice: number;\n    worstPrice: number;\n    levels: { price: number; size: number }[];\n  } {\n    const levels = side === 'buy'\n      ? [...superDOM.levels].filter(l => l.askSize).sort((a, b) => a.price - b.price)\n      : [...superDOM.levels].filter(l => l.bidSize).sort((a, b) => b.price - a.price);\n\n    let remainingSize = orderSize;\n    let totalCost = 0;\n    let worstPrice = side === 'buy' ? levels[0].price : levels[0].price;\n    const executedLevels: { price: number; size: number }[] = [];\n\n    // Walk through order book\n    for (const level of levels) {\n      if (remainingSize <= 0) break;\n\n      const availableSize = (side === 'buy' ? level.askSize : level.bidSize) || 0;\n      const executeSize = Math.min(remainingSize, availableSize);\n\n      totalCost += level.price * executeSize;\n      remainingSize -= executeSize;\n      worstPrice = level.price;\n\n      executedLevels.push({\n        price: level.price,\n        size: executeSize,\n      });\n    }\n\n    const avgPrice = totalCost / orderSize;\n    const bestPrice = levels[0].price;\n    const impactPercent = ((avgPrice - bestPrice) / bestPrice) * 100;\n\n    return {\n      impactPercent: Math.abs(impactPercent),\n      avgPrice,\n      worstPrice,\n      levels: executedLevels,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/order-book/types/order-book.types.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'z' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Order Book Types\n * Type definitions for advanced order book analysis\n *\n * Inspired by industry leaders:\n * - Bookmap (acquired by Nelogica) - Liquidity heatmap visualization\n * - ProfitPro - Pulse Indicator & order flow\n * - Institutional trading platforms\n */\n\nimport type { z } from 'zod';\n\n/**\n * Order Book Level\n * Single price level in the order book\n */\nexport interface OrderBookLevel {\n  price: number;\n  amount: number;\n  total?: number; // Cumulative amount (for depth visualization)\n  count?: number; // Number of orders at this level\n}\n\n/**\n * Order Book Snapshot\n * Complete order book state at a point in time\n */\nexport interface OrderBookSnapshot {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Order book levels\n  bids: OrderBookLevel[]; // Sorted desc by price\n  asks: OrderBookLevel[]; // Sorted asc by price\n\n  // Level 1 (best bid/ask)\n  bestBid?: number;\n  bestBidSize?: number;\n  bestAsk?: number;\n  bestAskSize?: number;\n\n  // Spread\n  spread?: number;\n  spreadPercent?: number;\n  midPrice?: number;\n\n  // Depth metrics\n  bidDepth10?: number; // Total USD value in top 10 bid levels\n  askDepth10?: number;\n  bidDepth50?: number;\n  askDepth50?: number;\n  totalDepth?: number;\n\n  // Metadata\n  nonce?: number; // Exchange sequence number\n  bidLevels?: number;\n  askLevels?: number;\n  isComplete?: boolean;\n\n  createdAt?: Date;\n}\n\n/**\n * Order Book Delta\n * Incremental changes to order book\n */\nexport interface OrderBookDelta {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Changes\n  bidChanges?: OrderBookLevel[];\n  askChanges?: OrderBookLevel[];\n\n  changeType: 'add' | 'update' | 'remove';\n  nonce?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Order Book Level 1 (Top-of-Book)\n * Best bid and ask only\n */\nexport interface OrderBookLevel1 {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  bestBid: number;\n  bestBidSize: number;\n  bestAsk: number;\n  bestAskSize: number;\n\n  spread?: number;\n  spreadPercent?: number;\n  midPrice?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Liquidity Heatmap Data Point\n * Single data point for heatmap visualization (Bookmap-style)\n */\nexport interface LiquidityHeatmapPoint {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n  priceLevel: number;\n\n  bidVolume: number;\n  askVolume: number;\n  totalVolume: number;\n\n  intensity: number; // 0-100 (for color mapping)\n\n  createdAt?: Date;\n}\n\n/**\n * Liquidity Heatmap Data\n * Complete heatmap data for a time period\n */\nexport interface LiquidityHeatmap {\n  exchangeId: string;\n  symbol: string;\n  startTime: Date;\n  endTime: Date;\n\n  // 2D array: [timestamp][price_level]\n  data: LiquidityHeatmapPoint[][];\n\n  // Price bounds\n  minPrice: number;\n  maxPrice: number;\n\n  // Intensity scale\n  minIntensity: number;\n  maxIntensity: number;\n}\n\n/**\n * Order Book Imbalance\n * Imbalance metrics at multiple depth levels\n */\nexport interface OrderBookImbalance {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Imbalance at different depths: (bid-ask)/(bid+ask)\n  imbalance5: number; // Top 5 levels\n  imbalance10: number;\n  imbalance20: number;\n  imbalance50: number;\n\n  // Volume imbalance (USD value)\n  volumeImbalance: number;\n\n  // Pressure score (-100 to +100)\n  // Positive = buying pressure, Negative = selling pressure\n  pressureScore: number;\n\n  // Momentum (rate of change)\n  imbalanceMomentum?: number;\n\n  // Cumulative imbalance (over time window)\n  cumulativeImbalance?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Pulse Indicator Signal (ProfitPro-style)\n * Real-time momentum signals from order book\n */\nexport interface PulseSignal {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Signal direction\n  direction: 'bullish' | 'bearish' | 'neutral';\n\n  // Signal strength (0-100)\n  strength: number;\n\n  // Components\n  imbalance: number;\n  pressure: number;\n  momentum: number;\n\n  // Confidence (0-100)\n  confidence: number;\n\n  // Trigger reason\n  reason: string;\n}\n\n/**\n * Liquidity Zone\n * Identified support/resistance based on liquidity clustering\n */\nexport interface LiquidityZone {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n\n  // Zone definition\n  priceLevel: number;\n  priceRange?: number; // +/- range\n  side: 'bid' | 'ask' | 'both';\n\n  // Liquidity metrics\n  totalLiquidity: number;\n  averageSize?: number;\n  orderCount?: number;\n\n  // Classification\n  zoneType: 'support' | 'resistance' | 'accumulation' | 'distribution';\n  strength: number; // 0-100\n\n  // Detection\n  detectedAt: Date;\n  lastSeenAt: Date;\n  confidenceScore?: number;\n\n  // Status\n  isActive: boolean;\n\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\n/**\n * Large Order Detection (Iceberg/Hidden Liquidity)\n */\nexport interface LargeOrder {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Order details\n  side: 'bid' | 'ask';\n  priceLevel: number;\n\n  // Size metrics\n  visibleSize: number;\n  estimatedTotalSize?: number;\n  icebergProbability: number; // 0-100\n\n  // Classification\n  orderType: 'iceberg' | 'whale' | 'market_maker';\n\n  // Impact\n  potentialImpact?: number; // % price impact if filled\n\n  // Status\n  status: 'active' | 'partially_filled' | 'filled' | 'cancelled';\n  filledSize: number;\n\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\n/**\n * Spoofing Event\n * Detected spoofing/layering attempts\n */\nexport interface SpoofingEvent {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  detectedAt: Date;\n\n  // Pattern\n  side: 'bid' | 'ask';\n  priceLevel: number;\n  orderSize?: number;\n\n  // Detection\n  spoofingType: 'layering' | 'quote_stuffing' | 'wash_trading';\n  confidenceScore: number; // 0-100\n\n  // Pattern details\n  orderLifetimeMs?: number;\n  layerCount?: number;\n\n  // Impact\n  marketImpact?: number;\n\n  // Resolution\n  resolved: boolean;\n  resolvedAt?: Date;\n  resolution?: string;\n\n  createdAt?: Date;\n}\n\n/**\n * Order Flow Toxicity (VPIN)\n * Volume-Synchronized Probability of Informed Trading\n */\nexport interface OrderFlowToxicity {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // VPIN metric (0-1)\n  vpin: number;\n\n  // Components\n  volumeBuckets: number;\n  buyVolume?: number;\n  sellVolume?: number;\n  orderImbalance?: number;\n\n  // Classification\n  toxicityLevel: 'low' | 'medium' | 'high' | 'extreme';\n\n  // Moving averages\n  vpinMA5?: number;\n  vpinMA20?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Price Impact Estimate\n * Estimated price impact for different order sizes\n */\nexport interface PriceImpactEstimate {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  calculatedAt: Date;\n\n  // Impact by size tier (% impact)\n  impact1k?: number; // $1,000\n  impact5k?: number;\n  impact10k?: number;\n  impact50k?: number;\n  impact100k?: number;\n  impact500k?: number;\n  impact1m?: number; // $1M\n\n  // Slippage estimates (absolute price)\n  slippage1k?: number;\n  slippage10k?: number;\n  slippage100k?: number;\n\n  // Context\n  liquidityScore?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Liquidity Score\n * Composite liquidity scoring\n */\nexport interface LiquidityScore {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Overall score (0-100)\n  score: number;\n\n  // Component scores\n  depthScore?: number;\n  spreadScore?: number;\n  volumeScore?: number;\n  stabilityScore?: number;\n\n  // Liquidity regime\n  regime: 'abundant' | 'normal' | 'scarce' | 'crisis';\n\n  // Metadata\n  bidDepth?: number;\n  askDepth?: number;\n  spread?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Footprint Chart Data (ProfitPro/Nelogica-style)\n * Order flow visualization data\n */\nexport interface FootprintData {\n  exchangeId: string;\n  symbol: string;\n  timeframe: string; // 1m, 5m, etc\n  timestamp: Date;\n\n  // OHLC\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n\n  // Volume breakdown by price level\n  priceVolumes: FootprintPriceLevel[];\n\n  // Aggregated metrics\n  totalVolume: number;\n  buyVolume: number;\n  sellVolume: number;\n  delta: number; // Buy - Sell\n\n  // Imbalance at high/low\n  highImbalance?: number;\n  lowImbalance?: number;\n\n  // Point of Control (POC)\n  poc?: number; // Price with highest volume\n}\n\n/**\n * Footprint Price Level\n * Volume data for a single price level in footprint chart\n */\nexport interface FootprintPriceLevel {\n  price: number;\n  buyVolume: number;\n  sellVolume: number;\n  totalVolume: number;\n  delta: number; // Buy - Sell\n  imbalance: number; // (Buy-Sell)/(Buy+Sell)\n}\n\n/**\n * Microstructure Metrics\n * Aggregated market microstructure metrics\n */\nexport interface MicrostructureMetrics {\n  id?: string;\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n  intervalMinutes: number; // 1, 5, 15, 60\n\n  // Order flow\n  totalOrders?: number;\n  totalCancels?: number;\n  cancelRate?: number;\n\n  // Liquidity\n  averageSpread?: number;\n  averageDepth?: number;\n  depthVolatility?: number;\n\n  // Price\n  priceVolatility?: number;\n  returnVariance?: number;\n\n  // Noise\n  microstructureNoise?: number;\n  effectiveSpread?: number;\n  realizedSpread?: number;\n\n  // Queue\n  averageQueuePosition?: number;\n  queueJumps?: number;\n\n  createdAt?: Date;\n}\n\n/**\n * Order Book Subscription\n * WebSocket subscription management\n */\nexport interface OrderBookSubscription {\n  id?: string;\n  userId: string;\n  tenantId: string;\n\n  // Subscription\n  exchangeId: string;\n  symbol: string;\n  depth: number; // Number of levels to stream\n\n  // Stream settings\n  updateIntervalMs: number; // 100ms, 1s, etc\n  includeDelta: boolean; // Stream deltas or full snapshots\n\n  // Filters\n  minPrice?: number;\n  maxPrice?: number;\n  minSize?: number;\n\n  // Status\n  status: 'active' | 'paused' | 'stopped';\n  connectionId?: string;\n\n  createdAt?: Date;\n  updatedAt?: Date;\n  lastMessageAt?: Date;\n}\n\n/**\n * Order Book Query Options\n */\nexport interface OrderBookQueryOptions {\n  exchangeId: string;\n  symbol: string;\n  limit?: number; // Number of levels per side\n  depth?: number; // Depth in levels (5, 10, 20, 50, 100, 200)\n}\n\n/**\n * Order Book Historical Query Options\n */\nexport interface OrderBookHistoricalQuery extends OrderBookQueryOptions {\n  startTime: Date;\n  endTime: Date;\n  interval?: number; // Milliseconds between snapshots\n}\n\n/**\n * Order Book Analytics Response\n */\nexport interface OrderBookAnalytics {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Current state\n  snapshot: OrderBookSnapshot;\n\n  // Metrics\n  imbalance: OrderBookImbalance;\n  liquidityScore: LiquidityScore;\n  toxicity?: OrderFlowToxicity;\n\n  // Zones\n  liquidityZones: LiquidityZone[];\n  largeOrders: LargeOrder[];\n\n  // Signals\n  pulseSignal?: PulseSignal;\n}\n\n/**\n * Multi-Exchange Order Book Aggregation\n */\nexport interface AggregatedOrderBook {\n  symbol: string;\n  timestamp: Date;\n\n  // Aggregated levels\n  bids: OrderBookLevel[];\n  asks: OrderBookLevel[];\n\n  // Best across exchanges\n  bestBid: number;\n  bestBidExchange: string;\n  bestAsk: number;\n  bestAskExchange: string;\n\n  // Spread\n  spread: number;\n  spreadPercent: number;\n\n  // Depth\n  totalDepth: number;\n\n  // Liquidity fragmentation\n  fragmentationIndex: number; // 0-1 (0 = all on one exchange, 1 = evenly distributed)\n\n  // Exchange breakdown\n  exchanges: {\n    exchangeId: string;\n    bidDepth: number;\n    askDepth: number;\n    spread: number;\n    liquidityShare: number; // % of total liquidity\n  }[];\n}\n\n/**\n * DOM (Depth of Market) Display Data (Nelogica-style)\n * Data structure for DOM visualization\n */\nexport interface DOMDisplayData {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Levels (sorted)\n  levels: DOMLevelData[];\n\n  // Summary\n  totalBidVolume: number;\n  totalAskVolume: number;\n  totalBidOrders: number;\n  totalAskOrders: number;\n\n  // Spread highlight\n  midPrice: number;\n  spread: number;\n  spreadPercent: number;\n}\n\n/**\n * DOM Level Data\n * Single level in DOM display\n */\nexport interface DOMLevelData {\n  price: number;\n\n  // Bid side\n  bidSize?: number;\n  bidOrders?: number;\n  bidIntensity?: number; // 0-100 for visualization\n\n  // Ask side\n  askSize?: number;\n  askOrders?: number;\n  askIntensity?: number;\n\n  // Cumulative\n  cumulativeBidSize?: number;\n  cumulativeAskSize?: number;\n\n  // Highlights\n  isLiquidityZone?: boolean;\n  isLargeOrder?: boolean;\n  imbalance?: number;\n}\n\n/**\n * Volume Profile Data (for Order Flow analysis)\n */\nexport interface VolumeProfileData {\n  exchangeId: string;\n  symbol: string;\n  startTime: Date;\n  endTime: Date;\n\n  // Profile\n  priceLevels: VolumeProfileLevel[];\n\n  // Key levels\n  poc: number; // Point of Control (highest volume price)\n  vah: number; // Value Area High\n  val: number; // Value Area Low\n\n  // Statistics\n  totalVolume: number;\n  valueAreaVolume: number; // 70% of volume\n  valueAreaPercent: number; // % of price range in value area\n}\n\n/**\n * Volume Profile Level\n */\nexport interface VolumeProfileLevel {\n  price: number;\n  volume: number;\n  volumePercent: number; // % of total volume\n  buyVolume: number;\n  sellVolume: number;\n  delta: number;\n}\n\n/**\n * Order Book Stream Event (WebSocket)\n */\nexport type OrderBookStreamEvent =\n  | { type: 'snapshot'; data: OrderBookSnapshot }\n  | { type: 'delta'; data: OrderBookDelta }\n  | { type: 'level1'; data: OrderBookLevel1 }\n  | { type: 'imbalance'; data: OrderBookImbalance }\n  | { type: 'pulse_signal'; data: PulseSignal }\n  | { type: 'large_order'; data: LargeOrder }\n  | { type: 'spoofing'; data: SpoofingEvent };\n\n/**\n * Order Book Depth Chart Data\n * Data for depth chart visualization\n */\nexport interface DepthChartData {\n  exchangeId: string;\n  symbol: string;\n  timestamp: Date;\n\n  // Cumulative data points\n  bids: { price: number; cumulative: number }[];\n  asks: { price: number; cumulative: number }[];\n\n  // Highlights\n  bestBid: number;\n  bestAsk: number;\n  midPrice: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/routes/orders.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/schema/orders.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/services/order.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/services/position.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/orders/types/orders.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/chat.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/disputes.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/orders.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/payment.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/reputation.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/routes/trading.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/schema/p2p.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/chat.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/dispute.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/escrow.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/matching.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/order.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/payment.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/reputation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/services/trade.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/types/p2p.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/utils/dispute-resolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/utils/escrow-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/utils/order-matching.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/p2p-marketplace/utils/reputation-score.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/positions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/positions/routes/positions.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/positions/schema/positions.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/positions/services/position.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/positions/types/positions.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/middleware/__tests__/rate-limit.middleware.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/middleware/rate-limit.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/routes/rate-limit.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/services/__tests__/rate-limit.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/services/rate-limit.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/rate-limiting/types/rate-limit.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/__tests__/endpoints-test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":69,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Risk Endpoints Test\n * Complete test suite for all REST endpoints\n *\n * This test validates:\n * - All 17 Risk endpoints\n * - Request/response structure\n * - Error handling\n * - Performance\n */\n\nconsole.log('🧪 Testing All Risk Endpoints\\n');\nconsole.log('='.repeat(80));\n\nconst RISK_BASE_URL = 'http://localhost:3000';\nconst RISK_TEST_USER_ID = 'test-user-endpoint';\nconst RISK_TEST_TENANT_ID = 'test-tenant-endpoint';\n\ninterface RiskTestResult {\n  endpoint: string;\n  method: string;\n  status: 'PASSED' | 'FAILED' | 'SKIPPED';\n  statusCode?: number;\n  responseTime?: number;\n  error?: string;\n}\n\nconst riskResults: RiskTestResult[] = [];\n\n/**\n * Helper to test endpoint\n */\nasync function testRiskEndpoint(\n  method: string,\n  path: string,\n  body?: any,\n  description?: string\n): Promise<RiskTestResult> {\n  const startTime = Date.now();\n  const fullPath = `${RISK_BASE_URL}${path}`;\n\n  console.log(`\\n🔄 Testing: ${method} ${path}`);\n  if (description) {\n    console.log(`   ${description}`);\n  }\n\n  try {\n    const options: RequestInit = {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'x-user-id': RISK_TEST_USER_ID,\n        'x-tenant-id': RISK_TEST_TENANT_ID,\n      },\n    };\n\n    if (body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(fullPath, options);\n    const responseTime = Date.now() - startTime;\n\n    const isSuccess = response.status >= 200 && response.status < 300;\n\n    let data: any;\n    try {\n      data = await response.json();\n    } catch (e) {\n      data = await response.text();\n    }\n\n    if (isSuccess) {\n      console.log(`   ✅ Status: ${response.status}`);\n      console.log(`   ⏱️  Response Time: ${responseTime}ms`);\n\n      // Show sample of response\n      if (typeof data === 'object' && data !== null) {\n        const keys = Object.keys(data);\n        console.log(`   📦 Response Keys: ${keys.slice(0, 5).join(', ')}${keys.length > 5 ? '...' : ''}`);\n      }\n\n      return {\n        endpoint: path,\n        method,\n        status: 'PASSED',\n        statusCode: response.status,\n        responseTime,\n      };\n    } else {\n      console.log(`   ❌ Failed with status: ${response.status}`);\n      console.log(`   Error: ${JSON.stringify(data).substring(0, 100)}`);\n\n      return {\n        endpoint: path,\n        method,\n        status: 'FAILED',\n        statusCode: response.status,\n        responseTime,\n        error: `HTTP ${response.status}`,\n      };\n    }\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n    console.log(`   ❌ Request Failed: ${error instanceof Error ? error.message : String(error)}`);\n\n    return {\n      endpoint: path,\n      method,\n      status: 'FAILED',\n      responseTime,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Check if server is running\n */\nasync function checkRiskServer(): Promise<boolean> {\n  console.log('\\n🔍 Checking if server is running...');\n\n  try {\n    const response = await fetch(`${RISK_BASE_URL}/health`, { method: 'GET' });\n    if (response.ok) {\n      console.log('✅ Server is running\\n');\n      return true;\n    }\n  } catch (error) {\n    // Server not running\n  }\n\n  console.log('❌ Server is NOT running');\n  console.log('⚠️  Please start the server first: bun run dev\\n');\n  return false;\n}\n\n/**\n * Run all endpoint tests\n */\nasync function runRiskEndpointTests() {\n  const startTime = Date.now();\n\n  console.log('\\n🚀 Starting Endpoint Tests...\\n');\n\n  // Check if server is running\n  const serverRunning = await checkRiskServer();\n  if (!serverRunning) {\n    console.log('💡 To start the server: bun run dev');\n    console.log('💡 Then run this test again');\n    return;\n  }\n\n  console.log('='.repeat(80));\n  console.log('📋 RISK PROFILE ENDPOINTS');\n  console.log('='.repeat(80));\n\n  // Test 1: Create Risk Profile\n  riskResults.push(await testRiskEndpoint(\n    'POST',\n    '/risk/profile',\n    {\n      riskTolerance: 'moderate',\n      maxPortfolioRisk: 10,\n      maxPositionRisk: 5,\n      maxDrawdown: 20,\n      defaultPositionSize: 2,\n      maxLeverage: 5,\n      enableRiskAlerts: true,\n      requireConfirmation: false,\n      autoStopLoss: true,\n      stopLossPercent: 2,\n      autoTakeProfit: false,\n    },\n    'Create risk profile'\n  ));\n\n  // Test 2: Get Risk Profile\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/profile',\n    undefined,\n    'Get user risk profile'\n  ));\n\n  // Test 3: Update Risk Profile\n  riskResults.push(await testRiskEndpoint(\n    'PUT',\n    '/risk/profile',\n    {\n      riskTolerance: 'aggressive',\n      maxPortfolioRisk: 15,\n    },\n    'Update risk profile'\n  ));\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📋 RISK METRICS ENDPOINTS');\n  console.log('='.repeat(80));\n\n  // Test 4: Calculate Risk Metrics\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/metrics',\n    undefined,\n    'Calculate current risk metrics'\n  ));\n\n  // Test 5: Get Risk Metrics History\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/metrics/history?days=30',\n    undefined,\n    'Get 30-day risk metrics history'\n  ));\n\n  // Test 6: Get Latest Risk Metrics\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/metrics/latest',\n    undefined,\n    'Get latest cached risk metrics'\n  ));\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📋 RISK LIMITS ENDPOINTS');\n  console.log('='.repeat(80));\n\n  // Test 7: Create Risk Limit\n  riskResults.push(await testRiskEndpoint(\n    'POST',\n    '/risk/limits',\n    {\n      limitType: 'max_loss',\n      limitValue: 5000,\n      timeframe: 'daily',\n      enabled: true,\n    },\n    'Create risk limit'\n  ));\n\n  // Test 8: List Risk Limits\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/limits',\n    undefined,\n    'List all risk limits'\n  ));\n\n  // Test 9: Update Risk Limit\n  riskResults.push(await testRiskEndpoint(\n    'PUT',\n    '/risk/limits/test-limit-id',\n    {\n      limitValue: 6000,\n      enabled: true,\n    },\n    'Update risk limit'\n  ));\n\n  // Test 10: Delete Risk Limit\n  riskResults.push(await testRiskEndpoint(\n    'DELETE',\n    '/risk/limits/test-limit-id',\n    undefined,\n    'Delete risk limit'\n  ));\n\n  // Test 11: Check Limit Violations\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/limits/violations',\n    undefined,\n    'Check for limit violations'\n  ));\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📋 RISK ALERTS ENDPOINTS');\n  console.log('='.repeat(80));\n\n  // Test 12: List Risk Alerts\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/alerts',\n    undefined,\n    'List all risk alerts'\n  ));\n\n  // Test 13: Get Unread Alerts\n  riskResults.push(await testRiskEndpoint(\n    'GET',\n    '/risk/alerts/unread',\n    undefined,\n    'Get unread alerts'\n  ));\n\n  // Test 14: Mark Alert as Read\n  riskResults.push(await testRiskEndpoint(\n    'PUT',\n    '/risk/alerts/test-alert-id/read',\n    undefined,\n    'Mark alert as read'\n  ));\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📋 POSITION SIZING ENDPOINTS');\n  console.log('='.repeat(80));\n\n  // Test 15: Calculate Position Size - Fixed Method\n  riskResults.push(await testRiskEndpoint(\n    'POST',\n    '/risk/position-size',\n    {\n      symbol: 'BTC/USDT',\n      entryPrice: 50000,\n      stopLoss: 49000,\n      method: 'fixed',\n      riskAmount: 1000,\n    },\n    'Calculate position size (fixed method)'\n  ));\n\n  // Test 16: Calculate Position Size - Kelly Criterion\n  riskResults.push(await testRiskEndpoint(\n    'POST',\n    '/risk/position-size',\n    {\n      symbol: 'ETH/USDT',\n      entryPrice: 3000,\n      stopLoss: 2900,\n      method: 'kelly',\n      winRate: 0.6,\n      avgWin: 150,\n      avgLoss: 100,\n    },\n    'Calculate position size (Kelly criterion)'\n  ));\n\n  // Test 17: Validate Trade\n  riskResults.push(await testRiskEndpoint(\n    'POST',\n    '/risk/validate-trade',\n    {\n      symbol: 'BTC/USDT',\n      side: 'long',\n      size: 0.5,\n      entryPrice: 50000,\n      stopLoss: 49000,\n      takeProfit: 52000,\n    },\n    'Validate trade against risk rules'\n  ));\n\n  // Final Summary\n  const duration = Date.now() - startTime;\n  const passed = riskResults.filter((r) => r.status === 'PASSED').length;\n  const failed = riskResults.filter((r) => r.status === 'FAILED').length;\n  const skipped = riskResults.filter((r) => r.status === 'SKIPPED').length;\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📊 TEST SUMMARY');\n  console.log('='.repeat(80));\n  console.log(`Total Endpoints: ${riskResults.length}`);\n  console.log(`✅ Passed: ${passed}`);\n  console.log(`❌ Failed: ${failed}`);\n  console.log(`⏭️  Skipped: ${skipped}`);\n  console.log(`\\n⏱️  Total Time: ${(duration / 1000).toFixed(2)}s`);\n  console.log('='.repeat(80));\n\n  // Detailed Results\n  if (failed > 0) {\n    console.log('\\n❌ FAILED TESTS:');\n    riskResults\n      .filter((r) => r.status === 'FAILED')\n      .forEach((r) => {\n        console.log(`\\n  ${r.method} ${r.endpoint}`);\n        console.log(`  Error: ${r.error}`);\n        if (r.statusCode) {\n          console.log(`  Status Code: ${r.statusCode}`);\n        }\n      });\n  }\n\n  // Performance Summary\n  const avgResponseTime =\n    riskResults\n      .filter((r) => r.responseTime !== undefined)\n      .reduce((sum, r) => sum + (r.responseTime || 0), 0) / riskResults.length;\n\n  console.log('\\n📈 PERFORMANCE:');\n  console.log(`Average Response Time: ${avgResponseTime.toFixed(0)}ms`);\n\n  const fastestEndpoint = riskResults.reduce((fastest, current) => {\n    if (!current.responseTime) return fastest;\n    if (!fastest.responseTime) return current;\n    return current.responseTime < fastest.responseTime ? current : fastest;\n  }, riskResults[0]);\n\n  const slowestEndpoint = riskResults.reduce((slowest, current) => {\n    if (!current.responseTime) return slowest;\n    if (!slowest.responseTime) return current;\n    return current.responseTime > slowest.responseTime ? current : slowest;\n  }, riskResults[0]);\n\n  console.log(`Fastest: ${fastestEndpoint.method} ${fastestEndpoint.endpoint} (${fastestEndpoint.responseTime}ms)`);\n  console.log(`Slowest: ${slowestEndpoint.method} ${slowestEndpoint.endpoint} (${slowestEndpoint.responseTime}ms)`);\n\n  console.log('\\n' + '='.repeat(80));\n\n  if (passed === riskResults.length) {\n    console.log('🎉 ALL TESTS PASSED!');\n  } else if (passed > 0) {\n    console.log(`⚠️  PARTIAL SUCCESS: ${passed}/${riskResults.length} tests passed`);\n  } else {\n    console.log('💥 ALL TESTS FAILED');\n  }\n\n  console.log('='.repeat(80));\n\n  // Pass rate\n  const passRate = (passed / riskResults.length) * 100;\n  console.log(`\\n📊 Pass Rate: ${passRate.toFixed(1)}%`);\n\n  if (passRate >= 95) {\n    console.log('🏆 EXCELLENT - Production ready!');\n  } else if (passRate >= 80) {\n    console.log('✅ GOOD - Minor issues to fix');\n  } else if (passRate >= 60) {\n    console.log('⚠️  FAIR - Several issues need attention');\n  } else {\n    console.log('🚨 POOR - Major issues need immediate attention');\n  }\n\n  console.log('='.repeat(80));\n}\n\n// Run tests\nrunRiskEndpointTests().catch((error) => {\n  console.error('\\n💥 Test Suite Failed:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/__tests__/risk-lock.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/__tests__/risk-performance-ratios.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/__tests__/risk-retention.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'beforeAll' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Risk Data Retention Service Tests\n * Tests for archival and cleanup functionality\n */\n\nimport { describe, test, expect, beforeAll } from 'bun:test';\nimport { RiskRetentionService, RETENTION_CONFIG } from '../services/risk-retention.service';\n\ndescribe('RiskRetentionService', () => {\n  const service = new RiskRetentionService();\n\n  // ==============================================================================\n  // CONFIGURATION TESTS\n  // ==============================================================================\n\n  describe('Configuration', () => {\n    test('should have correct retention configuration', () => {\n      expect(RETENTION_CONFIG.retentionDays).toBe(90);\n      expect(RETENTION_CONFIG.archiveBatchSize).toBe(10000);\n      expect(RETENTION_CONFIG.compressionLevel).toBeGreaterThanOrEqual(0);\n      expect(RETENTION_CONFIG.compressionLevel).toBeLessThanOrEqual(9);\n      expect(RETENTION_CONFIG.schedule).toBe('0 2 * * *'); // Daily at 2 AM\n    });\n  });\n\n  // ==============================================================================\n  // RETENTION STATS TESTS\n  // ==============================================================================\n\n  describe('Retention Statistics', () => {\n    test('should get retention statistics', async () => {\n      const stats = await service.getRetentionStats();\n\n      // Verify structure\n      expect(stats).toHaveProperty('totalRecords');\n      expect(stats).toHaveProperty('oldRecords');\n      expect(stats).toHaveProperty('recentRecords');\n      expect(stats).toHaveProperty('oldestRecord');\n      expect(stats).toHaveProperty('newestRecord');\n      expect(stats).toHaveProperty('cutoffDate');\n\n      // Verify types\n      expect(typeof stats.totalRecords).toBe('number');\n      expect(typeof stats.oldRecords).toBe('number');\n      expect(typeof stats.recentRecords).toBe('number');\n      expect(stats.cutoffDate).toBeInstanceOf(Date);\n\n      // Verify logic\n      expect(stats.totalRecords).toBeGreaterThanOrEqual(0);\n      expect(stats.oldRecords).toBeGreaterThanOrEqual(0);\n      expect(stats.recentRecords).toBeGreaterThanOrEqual(0);\n      expect(stats.totalRecords).toBe(stats.oldRecords + stats.recentRecords);\n    });\n\n    test('should calculate correct cutoff date', async () => {\n      const stats = await service.getRetentionStats();\n      const today = new Date();\n      const expectedCutoff = new Date();\n      expectedCutoff.setDate(today.getDate() - RETENTION_CONFIG.retentionDays);\n\n      // Allow 1 day tolerance for test execution time\n      const diff = Math.abs(stats.cutoffDate.getTime() - expectedCutoff.getTime());\n      const oneDayMs = 24 * 60 * 60 * 1000;\n      expect(diff).toBeLessThan(oneDayMs);\n    });\n  });\n\n  // ==============================================================================\n  // DRY RUN TESTS\n  // ==============================================================================\n\n  describe('Dry Run Mode', () => {\n    test('should perform dry run without archiving or deleting', async () => {\n      const statsBefore = await service.getRetentionStats();\n\n      // Run in dry run mode\n      const archiveStats = await service.archiveOldMetrics(true);\n\n      const statsAfter = await service.getRetentionStats();\n\n      // Verify dry run didn't modify data\n      expect(statsAfter.totalRecords).toBe(statsBefore.totalRecords);\n      expect(statsAfter.oldRecords).toBe(statsBefore.oldRecords);\n\n      // Verify stats structure\n      expect(archiveStats).toHaveProperty('totalRecords');\n      expect(archiveStats).toHaveProperty('recordsArchived');\n      expect(archiveStats).toHaveProperty('recordsDeleted');\n      expect(archiveStats).toHaveProperty('batches');\n      expect(archiveStats).toHaveProperty('duration');\n      expect(archiveStats).toHaveProperty('bytesArchived');\n      expect(archiveStats).toHaveProperty('errors');\n\n      // Dry run should not archive or delete\n      expect(archiveStats.recordsArchived).toBe(0);\n      expect(archiveStats.recordsDeleted).toBe(0);\n      expect(archiveStats.bytesArchived).toBe(0);\n    });\n\n    test('should count records correctly in dry run', async () => {\n      const stats = await service.getRetentionStats();\n      const archiveStats = await service.archiveOldMetrics(true);\n\n      expect(archiveStats.totalRecords).toBe(stats.oldRecords);\n    });\n  });\n\n  // ==============================================================================\n  // ARCHIVE STATS STRUCTURE TESTS\n  // ==============================================================================\n\n  describe('Archive Statistics Structure', () => {\n    test('should return complete archive statistics', async () => {\n      const stats = await service.archiveOldMetrics(true);\n\n      // Required fields\n      expect(stats).toHaveProperty('totalRecords');\n      expect(stats).toHaveProperty('recordsArchived');\n      expect(stats).toHaveProperty('recordsDeleted');\n      expect(stats).toHaveProperty('batches');\n      expect(stats).toHaveProperty('startTime');\n      expect(stats).toHaveProperty('endTime');\n      expect(stats).toHaveProperty('duration');\n      expect(stats).toHaveProperty('bytesArchived');\n      expect(stats).toHaveProperty('errors');\n\n      // Type validation\n      expect(typeof stats.totalRecords).toBe('number');\n      expect(typeof stats.recordsArchived).toBe('number');\n      expect(typeof stats.recordsDeleted).toBe('number');\n      expect(typeof stats.batches).toBe('number');\n      expect(stats.startTime).toBeInstanceOf(Date);\n      expect(stats.endTime).toBeInstanceOf(Date);\n      expect(typeof stats.duration).toBe('number');\n      expect(typeof stats.bytesArchived).toBe('number');\n      expect(Array.isArray(stats.errors)).toBe(true);\n\n      // Logic validation\n      expect(stats.endTime.getTime()).toBeGreaterThanOrEqual(stats.startTime.getTime());\n      expect(stats.duration).toBeGreaterThanOrEqual(0);\n      expect(stats.totalRecords).toBeGreaterThanOrEqual(0);\n      expect(stats.batches).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should calculate duration correctly', async () => {\n      const stats = await service.archiveOldMetrics(true);\n\n      const calculatedDuration = stats.endTime.getTime() - stats.startTime.getTime();\n\n      // Allow small tolerance for calculation differences\n      expect(Math.abs(stats.duration - calculatedDuration)).toBeLessThan(100);\n    });\n  });\n\n  // ==============================================================================\n  // COMPRESSION TESTS\n  // ==============================================================================\n\n  describe('Data Compression', () => {\n    test('should use valid compression level', () => {\n      const level = RETENTION_CONFIG.compressionLevel;\n\n      // gzip compression levels are 0-9\n      expect(level).toBeGreaterThanOrEqual(0);\n      expect(level).toBeLessThanOrEqual(9);\n    });\n\n    test('should compress data before archiving', async () => {\n      // This is implicitly tested by archiveBatch\n      // Compression level 6 is a good balance between speed and compression ratio\n      expect(RETENTION_CONFIG.compressionLevel).toBe(6);\n    });\n  });\n\n  // ==============================================================================\n  // BATCH PROCESSING TESTS\n  // ==============================================================================\n\n  describe('Batch Processing', () => {\n    test('should use reasonable batch size', () => {\n      const batchSize = RETENTION_CONFIG.archiveBatchSize;\n\n      // Batch size should be large enough for efficiency but small enough for memory\n      expect(batchSize).toBeGreaterThan(0);\n      expect(batchSize).toBeLessThanOrEqual(50000);\n    });\n\n    test('should process zero records gracefully', async () => {\n      // If no old records exist, should complete without errors\n      const stats = await service.archiveOldMetrics(true);\n\n      expect(stats.totalRecords).toBeGreaterThanOrEqual(0);\n      expect(stats.errors).toHaveLength(0);\n    });\n  });\n\n  // ==============================================================================\n  // ERROR HANDLING TESTS\n  // ==============================================================================\n\n  describe('Error Handling', () => {\n    test('should initialize errors array', async () => {\n      const stats = await service.archiveOldMetrics(true);\n\n      expect(Array.isArray(stats.errors)).toBe(true);\n      expect(stats.errors.length).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should track errors during processing', async () => {\n      const stats = await service.archiveOldMetrics(true);\n\n      // Errors should be strings\n      stats.errors.forEach(error => {\n        expect(typeof error).toBe('string');\n      });\n    });\n  });\n\n  // ==============================================================================\n  // DATE HANDLING TESTS\n  // ==============================================================================\n\n  describe('Date Calculations', () => {\n    test('should calculate cutoff date correctly', () => {\n      const today = new Date();\n      const cutoff = new Date();\n      cutoff.setDate(today.getDate() - RETENTION_CONFIG.retentionDays);\n\n      // Cutoff should be exactly 90 days ago\n      const diffDays = Math.floor((today.getTime() - cutoff.getTime()) / (1000 * 60 * 60 * 24));\n\n      expect(diffDays).toBe(RETENTION_CONFIG.retentionDays);\n    });\n\n    test('should handle month boundaries correctly', () => {\n      const today = new Date('2025-03-15');\n      const cutoff = new Date(today);\n      cutoff.setDate(today.getDate() - 90);\n\n      // 90 days before March 15 is December 15 (previous year)\n      expect(cutoff.getMonth()).toBe(11); // December (0-indexed)\n      expect(cutoff.getFullYear()).toBe(2024);\n    });\n  });\n\n  // ==============================================================================\n  // ARCHIVE FORMAT TESTS\n  // ==============================================================================\n\n  describe('Archive Format', () => {\n    test('should use JSON Lines format (.jsonl)', () => {\n      // JSON Lines: one JSON object per line\n      // This format is efficient for streaming and processing large datasets\n      // File extension: .jsonl.gz (compressed)\n\n      const expectedExtension = '.jsonl.gz';\n      const testFilename = `risk-metrics-archive_2025-01-15_${Date.now()}.jsonl.gz`;\n\n      expect(testFilename.endsWith(expectedExtension)).toBe(true);\n    });\n\n    test('should include timestamp in filename', () => {\n      const now = Date.now();\n      const filename = `risk-metrics-archive_2025-01-15_${now}.jsonl.gz`;\n\n      expect(filename).toContain(String(now));\n      expect(filename).toMatch(/risk-metrics-archive_\\d{4}-\\d{2}-\\d{2}_\\d+\\.jsonl\\.gz/);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/__tests__/risk.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletService' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":161,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":161,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":173,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":173,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":185,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":197,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":197,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":209,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":209,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":221,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":228,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":228,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":235,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":235,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'testWalletId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":252,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":252,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":315,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Risk Module Integration Tests\n * Tests real database operations, concurrent requests, and system integration\n *\n * Coverage:\n * - Concurrent metric calculations\n * - Wallet integration\n * - Large portfolio performance\n * - Race condition prevention\n * - Error handling and graceful degradation\n * - Real database queries and transactions\n */\n\nimport { describe, test, expect, beforeAll, afterAll, beforeEach } from 'bun:test';\nimport { db } from '@/db';\nimport { riskService } from '../services/risk.service';\nimport { walletService } from '../../banco/services/wallet.service';\nimport { eq, and, sql } from 'drizzle-orm';\nimport {\n  riskProfiles,\n  riskLimits,\n  riskMetrics,\n  riskAlerts\n} from '../schema/risk.schema';\nimport { positions } from '../../positions/schema/positions.schema';\nimport { wallets } from '../../banco/schema/wallet.schema';\nimport { users } from '../../auth/schema/auth.schema';\nimport { tenants } from '../../tenants/schema/tenants.schema';\n\n/**\n * Test Configuration\n */\nconst TEST_CONFIG = {\n  TENANT_ID: 'test-tenant-risk-integration',\n  USER_ID: 'test-user-risk-integration',\n  LARGE_PORTFOLIO_SIZE: 100, // Test with 100 positions (reduced from 1000 for faster tests)\n  CONCURRENT_REQUESTS: 10,\n  MAX_RESPONSE_TIME: 2000, // 2 seconds max\n};\n\n/**\n * Test Setup Utilities\n */\nclass RiskTestSetup {\n  /**\n   * Create test user with wallet\n   */\n  static async createTestUser(): Promise<{ userId: string; tenantId: string; walletId: string }> {\n    const userId = TEST_CONFIG.USER_ID;\n    const tenantId = TEST_CONFIG.TENANT_ID;\n\n    // Create user first (required for foreign key constraints)\n    await db.insert(users).values({\n      id: userId,\n      name: 'Test User',\n      email: `${userId}@test.com`,\n      emailVerified: true,\n    }).onConflictDoNothing();\n\n    // Create tenant (required for foreign key constraints)\n    await db.insert(tenants).values({\n      id: tenantId,\n      name: 'Test Tenant',\n      slug: tenantId,\n      type: 'empresa',\n      status: 'active',\n    }).onConflictDoNothing();\n\n    // Create wallet for user\n    const [wallet] = await db.insert(wallets).values({\n      userId,\n      tenantId,\n      name: 'Test Wallet',\n      type: 'spot',\n      description: 'Test wallet for risk integration tests',\n      isActive: true,\n      isLocked: false,\n    }).onConflictDoUpdate({\n      target: wallets.id,\n      set: {\n        isActive: true,\n        isLocked: false,\n      }\n    }).returning();\n\n    return { userId, tenantId, walletId: wallet.id };\n  }\n\n  /**\n   * Create test risk profile\n   */\n  static async createTestRiskProfile(userId: string, tenantId: string) {\n    await db.insert(riskProfiles).values({\n      userId,\n      tenantId,\n      riskTolerance: 'moderate',\n      maxPortfolioRisk: 10,\n      maxPositionRisk: 5,\n      maxDrawdown: 20,\n      defaultPositionSize: 2,\n      maxLeverage: 5,\n      enableRiskAlerts: true,\n      requireConfirmation: false,\n      autoStopLoss: true,\n      stopLossPercent: 2,\n      autoTakeProfit: false,\n    });\n  }\n\n  /**\n   * Create test positions\n   */\n  static async createTestPositions(\n    userId: string,\n    tenantId: string,\n    count: number\n  ): Promise<string[]> {\n    const positionIds: string[] = [];\n\n    for (let i = 0; i < count; i++) {\n      const symbol = i < 5 ? ['BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'SOL/USDT', 'ADA/USDT'][i] : `TEST${i}/USDT`;\n      const [position] = await db.insert(positions).values({\n        userId,\n        tenantId,\n        strategyId: null,\n        symbol,\n        side: i % 2 === 0 ? 'long' : 'short',\n        entryPrice: (1000 + i * 10).toString(),\n        currentPrice: (1000 + i * 10 + (i % 2 === 0 ? 50 : -50)).toString(),\n        quantity: (1 + i * 0.1).toString(),\n        remainingQuantity: (1 + i * 0.1).toString(),\n        leverage: '1',\n        unrealizedPnl: ((i % 2 === 0 ? 1 : -1) * (50 * (1 + i * 0.1))).toString(),\n        status: 'open',\n      }).returning();\n\n      positionIds.push(position.id);\n    }\n\n    return positionIds;\n  }\n\n  /**\n   * Cleanup test data\n   * Uses try-catch to handle tables that might not exist\n   */\n  static async cleanup() {\n    const userId = TEST_CONFIG.USER_ID;\n    const tenantId = TEST_CONFIG.TENANT_ID;\n\n    // Try to delete from each table, ignoring errors if table doesn't exist\n    const cleanupTasks = [\n      async () => {\n        try {\n          await db.delete(riskAlerts).where(\n            and(\n              eq(riskAlerts.userId, userId),\n              eq(riskAlerts.tenantId, tenantId)\n            )\n          );\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(riskMetrics).where(\n            and(\n              eq(riskMetrics.userId, userId),\n              eq(riskMetrics.tenantId, tenantId)\n            )\n          );\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(riskLimits).where(\n            and(\n              eq(riskLimits.userId, userId),\n              eq(riskLimits.tenantId, tenantId)\n            )\n          );\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(positions).where(\n            and(\n              eq(positions.userId, userId),\n              eq(positions.tenantId, tenantId)\n            )\n          );\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(riskProfiles).where(\n            and(\n              eq(riskProfiles.userId, userId),\n              eq(riskProfiles.tenantId, tenantId)\n            )\n          );\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(wallets).where(\n            and(\n              eq(wallets.userId, userId),\n              eq(wallets.tenantId, tenantId)\n            )\n          );\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(tenants).where(eq(tenants.id, tenantId));\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n      async () => {\n        try {\n          await db.delete(users).where(eq(users.id, userId));\n        } catch (e) {\n          // Table might not exist, ignore\n        }\n      },\n    ];\n\n    // Run all cleanup tasks in parallel\n    await Promise.all(cleanupTasks.map(task => task()));\n  }\n}\n\n/**\n * Test Suite\n */\ndescribe('Risk Module Integration Tests', () => {\n  let testUserId: string;\n  let testTenantId: string;\n  let testWalletId: string;\n\n  beforeAll(async () => {\n    // Setup test environment\n    console.log('🔧 Setting up Risk integration tests...');\n    const setup = await RiskTestSetup.createTestUser();\n    testUserId = setup.userId;\n    testTenantId = setup.tenantId;\n    testWalletId = setup.walletId;\n\n    await RiskTestSetup.createTestRiskProfile(testUserId, testTenantId);\n    console.log('✅ Test environment ready');\n  });\n\n  afterAll(async () => {\n    // Cleanup test data\n    console.log('🧹 Cleaning up test data...');\n    await RiskTestSetup.cleanup();\n    console.log('✅ Cleanup complete');\n  });\n\n  beforeEach(async () => {\n    // Clean positions before each test\n    await db.delete(positions).where(\n      and(\n        eq(positions.userId, testUserId),\n        eq(positions.tenantId, testTenantId)\n      )\n    );\n\n    await db.delete(riskMetrics).where(\n      and(\n        eq(riskMetrics.userId, testUserId),\n        eq(riskMetrics.tenantId, testTenantId)\n      )\n    );\n  });\n\n  /**\n   * Test 1: Concurrent Metric Calculations\n   * Verifies: No race conditions, all requests return consistent results\n   */\n  test('should handle concurrent metric calculations without race conditions', async () => {\n    console.log('\\n🧪 Test 1: Concurrent Metric Calculations');\n\n    // Create test positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 10);\n\n    // Simulate 10 concurrent requests\n    console.log(`   Sending ${TEST_CONFIG.CONCURRENT_REQUESTS} concurrent requests...`);\n    const startTime = Date.now();\n\n    const promises = Array(TEST_CONFIG.CONCURRENT_REQUESTS)\n      .fill(null)\n      .map(() => riskService.calculateRiskMetrics(testUserId, testTenantId));\n\n    const results = await Promise.all(promises);\n    const elapsed = Date.now() - startTime;\n\n    console.log(`   ✅ All requests completed in ${elapsed}ms`);\n    console.log(`   📊 Average time per request: ${(elapsed / TEST_CONFIG.CONCURRENT_REQUESTS).toFixed(0)}ms`);\n\n    // Verify all results are valid\n    results.forEach((result, index) => {\n      expect(result.userId).toBe(testUserId);\n      expect(result.tenantId).toBe(testTenantId);\n      expect(result.portfolioValue).toBeGreaterThan(0);\n      expect(result.overallRiskScore).toBeGreaterThanOrEqual(0);\n      expect(result.overallRiskScore).toBeLessThanOrEqual(100);\n    });\n\n    // Verify consistency: all calculations should produce same risk score\n    // (since they're running on the same data at nearly the same time)\n    const uniqueRiskScores = new Set(results.map(r => r.overallRiskScore.toFixed(2)));\n    console.log(`   🎯 Unique risk scores: ${uniqueRiskScores.size}`);\n    expect(uniqueRiskScores.size).toBeLessThanOrEqual(2); // Allow slight timing variations\n\n    // Verify metrics were saved to database\n    const savedMetrics = await db\n      .select()\n      .from(riskMetrics)\n      .where(\n        and(\n          eq(riskMetrics.userId, testUserId),\n          eq(riskMetrics.tenantId, testTenantId)\n        )\n      );\n\n    console.log(`   💾 Metrics saved to DB: ${savedMetrics.length}`);\n    expect(savedMetrics.length).toBeGreaterThan(0);\n  });\n\n  /**\n   * Test 2: Wallet Integration\n   * Verifies: Correct cash balance and margin calculation from wallet service\n   */\n  test('should integrate correctly with wallet service for cash balance and margin', async () => {\n    console.log('\\n🧪 Test 2: Wallet Integration');\n\n    // Create test positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 5);\n\n    // Calculate metrics\n    const metrics = await riskService.calculateRiskMetrics(testUserId, testTenantId);\n\n    console.log(`   📊 Portfolio Value: $${metrics.portfolioValue.toFixed(2)}`);\n    console.log(`   💰 Cash Balance: $${metrics.cashBalance.toFixed(2)}`);\n    console.log(`   📈 Margin Available: $${metrics.marginAvailable.toFixed(2)}`);\n    console.log(`   📉 Margin Utilization: ${metrics.marginUtilization.toFixed(2)}%`);\n\n    // Verify wallet integration\n    expect(metrics.cashBalance).toBeGreaterThanOrEqual(0);\n    expect(metrics.marginAvailable).toBeGreaterThanOrEqual(0);\n    expect(metrics.marginUtilization).toBeGreaterThanOrEqual(0);\n    expect(metrics.marginUtilization).toBeLessThanOrEqual(100);\n\n    // Margin available should be less than or equal to total portfolio value\n    expect(metrics.marginAvailable).toBeLessThanOrEqual(metrics.portfolioValue);\n  });\n\n  /**\n   * Test 3: Wallet Integration Failure\n   * Verifies: Graceful degradation when wallet service fails\n   */\n  test('should handle wallet integration failure gracefully', async () => {\n    console.log('\\n🧪 Test 3: Wallet Integration Failure Handling');\n\n    // Create positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 3);\n\n    // Mock wallet service to fail (by using non-existent user)\n    const fakeUserId = 'non-existent-user-id';\n\n    // Calculate metrics with fake user (wallet won't be found)\n    const metrics = await riskService.calculateRiskMetrics(fakeUserId, testTenantId);\n\n    console.log(`   ✅ Service handled missing wallet gracefully`);\n    console.log(`   💰 Cash Balance: $${metrics.cashBalance.toFixed(2)} (fallback to 0)`);\n    console.log(`   📈 Margin Available: $${metrics.marginAvailable.toFixed(2)} (fallback to 0)`);\n\n    // Should fallback to 0 for wallet-related metrics\n    expect(metrics.cashBalance).toBe(0);\n    expect(metrics.marginAvailable).toBe(0);\n\n    // But should still calculate portfolio value from positions\n    expect(metrics.portfolioValue).toBeGreaterThanOrEqual(0);\n  });\n\n  /**\n   * Test 4: Large Portfolio Performance\n   * Verifies: System can handle portfolios with many positions efficiently\n   */\n  test('should calculate metrics for large portfolio in acceptable time', async () => {\n    console.log('\\n🧪 Test 4: Large Portfolio Performance');\n\n    // Create large portfolio\n    console.log(`   📦 Creating ${TEST_CONFIG.LARGE_PORTFOLIO_SIZE} test positions...`);\n    await RiskTestSetup.createTestPositions(\n      testUserId,\n      testTenantId,\n      TEST_CONFIG.LARGE_PORTFOLIO_SIZE\n    );\n\n    // Measure performance\n    const startTime = Date.now();\n    const metrics = await riskService.calculateRiskMetrics(testUserId, testTenantId);\n    const elapsed = Date.now() - startTime;\n\n    console.log(`   ⏱️  Calculation time: ${elapsed}ms`);\n    console.log(`   📊 Portfolio Value: $${metrics.portfolioValue.toFixed(2)}`);\n    console.log(`   🎯 Risk Score: ${metrics.overallRiskScore.toFixed(2)}`);\n    console.log(`   📍 Open Positions: ${metrics.openPositions}`);\n\n    // Verify performance\n    expect(elapsed).toBeLessThan(TEST_CONFIG.MAX_RESPONSE_TIME);\n    expect(metrics.openPositions).toBe(TEST_CONFIG.LARGE_PORTFOLIO_SIZE);\n\n    // Verify calculations are valid\n    expect(metrics.portfolioValue).toBeGreaterThan(0);\n    expect(metrics.overallRiskScore).toBeGreaterThanOrEqual(0);\n    expect(metrics.overallRiskScore).toBeLessThanOrEqual(100);\n\n    console.log(`   ✅ Performance within acceptable limits (<${TEST_CONFIG.MAX_RESPONSE_TIME}ms)`);\n  });\n\n  /**\n   * Test 5: Risk Profile Integration\n   * Verifies: Risk calculations respect user's risk profile settings\n   */\n  test('should respect risk profile settings in calculations', async () => {\n    console.log('\\n🧪 Test 5: Risk Profile Integration');\n\n    // Create positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 5);\n\n    // Get risk profile\n    const profile = await riskService.getRiskProfile(testUserId, testTenantId);\n\n    console.log(`   👤 Risk Tolerance: ${profile.riskTolerance}`);\n    console.log(`   📊 Max Portfolio Risk: ${profile.maxPortfolioRisk}%`);\n    console.log(`   📍 Max Position Risk: ${profile.maxPositionRisk}%`);\n\n    // Calculate metrics\n    const metrics = await riskService.calculateRiskMetrics(testUserId, testTenantId);\n\n    console.log(`   🎯 Overall Risk Score: ${metrics.overallRiskScore.toFixed(2)}`);\n\n    // Verify profile is being used\n    expect(profile.riskTolerance).toBe('moderate');\n    expect(profile.maxPortfolioRisk).toBe(10);\n\n    // Risk score should be calculated\n    expect(metrics.overallRiskScore).toBeGreaterThanOrEqual(0);\n    expect(metrics.overallRiskScore).toBeLessThanOrEqual(100);\n  });\n\n  /**\n   * Test 6: VaR Calculation with Position Breakdown\n   * Verifies: VaR includes position-level breakdown\n   */\n  test('should calculate VaR with position breakdown', async () => {\n    console.log('\\n🧪 Test 6: VaR Calculation');\n\n    // Create diverse positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 5);\n\n    // Calculate VaR with breakdown\n    const varResult = await riskService.calculateVaR(testUserId, testTenantId, {\n      confidence: 0.95,\n      timeHorizon: 1,\n      method: 'historical',\n      includeBreakdown: true,\n    });\n\n    console.log(`   📊 VaR (95%): $${varResult.valueAtRisk.toFixed(2)}`);\n    console.log(`   📍 Method: ${varResult.method}`);\n    console.log(`   📍 Position Breakdown: ${varResult.breakdown?.length || 0} positions`);\n\n    // Verify VaR calculation\n    expect(varResult.valueAtRisk).toBeGreaterThanOrEqual(0);\n    expect(varResult.confidence).toBe(0.95);\n\n    // Verify breakdown exists\n    if (varResult.breakdown && varResult.breakdown.length > 0) {\n      console.log(`   🔍 Top risk contributors:`);\n      varResult.breakdown.slice(0, 3).forEach((item, index) => {\n        console.log(`      ${index + 1}. ${item.symbol}: $${item.contribution.toFixed(2)} (${item.contributionPercent.toFixed(1)}%)`);\n      });\n\n      // Verify structure\n      expect(varResult.breakdown[0]).toHaveProperty('positionId');\n      expect(varResult.breakdown[0]).toHaveProperty('symbol');\n      expect(varResult.breakdown[0]).toHaveProperty('contribution');\n      expect(varResult.breakdown[0]).toHaveProperty('contributionPercent');\n\n      // Verify contributions sum to 100% (or close due to rounding)\n      const totalPercent = varResult.breakdown.reduce(\n        (sum, item) => sum + item.contributionPercent,\n        0\n      );\n      expect(totalPercent).toBeGreaterThan(95);\n      expect(totalPercent).toBeLessThanOrEqual(105); // Allow slight rounding errors\n    }\n  });\n\n  /**\n   * Test 7: Performance Ratios Calculation\n   * Verifies: Sharpe, Sortino, and Calmar ratios are calculated correctly\n   */\n  test('should calculate performance ratios (Sharpe, Sortino, Calmar)', async () => {\n    console.log('\\n🧪 Test 7: Performance Ratios');\n\n    // Create positions with profit/loss\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 10);\n\n    // Calculate metrics multiple times to build history\n    for (let i = 0; i < 3; i++) {\n      await riskService.calculateRiskMetrics(testUserId, testTenantId);\n      await new Promise(resolve => setTimeout(resolve, 100)); // Small delay\n    }\n\n    // Get latest metrics\n    const metrics = await riskService.calculateRiskMetrics(testUserId, testTenantId);\n\n    console.log(`   📊 Sharpe Ratio: ${metrics.sharpeRatio?.toFixed(2) || 'N/A'}`);\n    console.log(`   📊 Sortino Ratio: ${metrics.sortinoRatio?.toFixed(2) || 'N/A'}`);\n    console.log(`   📊 Calmar Ratio: ${metrics.calmarRatio?.toFixed(2) || 'N/A'}`);\n\n    // Verify ratios are calculated (may be null if insufficient history)\n    if (metrics.sharpeRatio !== null) {\n      expect(typeof metrics.sharpeRatio).toBe('number');\n      expect(isNaN(metrics.sharpeRatio)).toBe(false);\n    }\n\n    if (metrics.sortinoRatio !== null) {\n      expect(typeof metrics.sortinoRatio).toBe('number');\n      expect(isNaN(metrics.sortinoRatio)).toBe(false);\n    }\n\n    if (metrics.calmarRatio !== null) {\n      expect(typeof metrics.calmarRatio).toBe('number');\n      expect(isNaN(metrics.calmarRatio)).toBe(false);\n    }\n  });\n\n  /**\n   * Test 8: Risk Limits Violation Detection\n   * Verifies: System detects when risk limits are exceeded\n   */\n  test('should detect risk limit violations', async () => {\n    console.log('\\n🧪 Test 8: Risk Limit Violations');\n\n    // Create positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 5);\n\n    // Create strict risk limit\n    await db.insert(riskLimits).values({\n      userId: testUserId,\n      tenantId: testTenantId,\n      limitType: 'max_drawdown',\n      limitValue: 1, // Very low threshold to trigger violation\n      timeframe: 'daily',\n      enabled: true,\n    });\n\n    console.log(`   🚨 Created strict risk limit (max_drawdown: 1%)`);\n\n    // Check for violations\n    const violations = await riskService.checkLimitViolations(testUserId, testTenantId);\n\n    console.log(`   📊 Violations detected: ${violations.length}`);\n\n    if (violations.length > 0) {\n      violations.forEach((violation, index) => {\n        console.log(`      ${index + 1}. ${violation.limitType}: ${violation.currentValue.toFixed(2)} > ${violation.limitValue}`);\n      });\n    }\n\n    // Verify violations structure\n    if (violations.length > 0) {\n      expect(violations[0]).toHaveProperty('limitType');\n      expect(violations[0]).toHaveProperty('limitValue');\n      expect(violations[0]).toHaveProperty('currentValue');\n      expect(violations[0]).toHaveProperty('severity');\n    }\n  });\n\n  /**\n   * Test 9: Alert Creation on Violations\n   * Verifies: Alerts are created when violations are detected\n   */\n  test('should create alerts for risk violations', async () => {\n    console.log('\\n🧪 Test 9: Alert Creation');\n\n    // Create positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 5);\n\n    // Create risk limit\n    await db.insert(riskLimits).values({\n      userId: testUserId,\n      tenantId: testTenantId,\n      limitType: 'max_loss',\n      limitValue: 100, // Low threshold\n      timeframe: 'daily',\n      enabled: true,\n    });\n\n    // Check violations (should create alerts)\n    await riskService.checkLimitViolations(testUserId, testTenantId);\n\n    // Query alerts\n    const alerts = await db\n      .select()\n      .from(riskAlerts)\n      .where(\n        and(\n          eq(riskAlerts.userId, testUserId),\n          eq(riskAlerts.tenantId, testTenantId)\n        )\n      );\n\n    console.log(`   🔔 Alerts created: ${alerts.length}`);\n\n    if (alerts.length > 0) {\n      alerts.forEach((alert, index) => {\n        console.log(`      ${index + 1}. [${alert.severity}] ${alert.title}: ${alert.message}`);\n      });\n\n      // Verify alert structure\n      expect(alerts[0]).toHaveProperty('alertType');\n      expect(alerts[0]).toHaveProperty('severity');\n      expect(alerts[0]).toHaveProperty('title');\n      expect(alerts[0]).toHaveProperty('message');\n      expect(['low', 'medium', 'high', 'critical']).toContain(alerts[0].severity);\n    }\n  });\n\n  /**\n   * Test 10: Position Sizing Recommendations\n   * Verifies: System provides position sizing recommendations\n   */\n  test('should calculate position sizing recommendations', async () => {\n    console.log('\\n🧪 Test 10: Position Sizing');\n\n    // Create positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 3);\n\n    // Calculate position size for new trade\n    const sizing = await riskService.calculatePositionSize(\n      testUserId,\n      testTenantId,\n      {\n        symbol: 'BTC/USDT',\n        side: 'long',\n        entryPrice: 50000,\n        stopLoss: 49000, // 2% risk\n        method: 'fixed',\n      }\n    );\n\n    console.log(`   💰 Recommended Size: ${sizing.recommendedSize.toFixed(4)}`);\n    console.log(`   📈 Risk Amount: $${sizing.riskAmount.toFixed(2)}`);\n    console.log(`   📉 Risk Percent: ${sizing.riskPercent.toFixed(2)}%`);\n    console.log(`   🎯 Method: ${sizing.method}`);\n\n    // Verify sizing calculation\n    expect(sizing.recommendedSize).toBeGreaterThan(0);\n    expect(sizing.riskAmount).toBeGreaterThan(0);\n    expect(sizing.riskPercent).toBeGreaterThan(0);\n    expect(sizing.riskPercent).toBeLessThanOrEqual(100);\n  });\n\n  /**\n   * Test 11: Database Transaction Integrity\n   * Verifies: Metrics are saved correctly to database\n   */\n  test('should save metrics to database with correct data types', async () => {\n    console.log('\\n🧪 Test 11: Database Integrity');\n\n    // Create positions\n    await RiskTestSetup.createTestPositions(testUserId, testTenantId, 5);\n\n    // Calculate and save metrics\n    const calculated = await riskService.calculateRiskMetrics(testUserId, testTenantId);\n\n    // Query saved metrics\n    const [saved] = await db\n      .select()\n      .from(riskMetrics)\n      .where(\n        and(\n          eq(riskMetrics.userId, testUserId),\n          eq(riskMetrics.tenantId, testTenantId)\n        )\n      )\n      .orderBy(riskMetrics.calculatedAt)\n      .limit(1);\n\n    console.log(`   💾 Metrics saved to database`);\n    console.log(`   🆔 Metric ID: ${saved.id}`);\n    console.log(`   📊 Portfolio Value: $${parseFloat(saved.portfolioValue).toFixed(2)}`);\n    console.log(`   🎯 Risk Score: ${saved.overallRiskScore}`);\n\n    // Verify data integrity\n    expect(saved).toBeDefined();\n    expect(saved.userId).toBe(testUserId);\n    expect(saved.tenantId).toBe(testTenantId);\n    expect(parseFloat(saved.portfolioValue)).toBeCloseTo(calculated.portfolioValue, 2);\n    expect(saved.overallRiskScore).toBeCloseTo(calculated.overallRiskScore, 2);\n\n    // Verify numeric fields are valid\n    expect(isNaN(parseFloat(saved.portfolioValue))).toBe(false);\n    expect(isNaN(saved.overallRiskScore)).toBe(false);\n  });\n});\n\n/**\n * Summary Report\n */\nconsole.log('\\n' + '='.repeat(80));\nconsole.log('📊 RISK MODULE INTEGRATION TESTS');\nconsole.log('='.repeat(80));\nconsole.log('Tests cover:');\nconsole.log('  ✅ Concurrent request handling (race condition prevention)');\nconsole.log('  ✅ Wallet service integration');\nconsole.log('  ✅ Graceful degradation on failures');\nconsole.log('  ✅ Large portfolio performance');\nconsole.log('  ✅ Risk profile integration');\nconsole.log('  ✅ VaR calculation with breakdown');\nconsole.log('  ✅ Performance ratios (Sharpe, Sortino, Calmar)');\nconsole.log('  ✅ Risk limit violation detection');\nconsole.log('  ✅ Alert creation');\nconsole.log('  ✅ Position sizing recommendations');\nconsole.log('  ✅ Database transaction integrity');\nconsole.log('='.repeat(80));\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/__tests__/risk.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'riskService' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletId' is defined but never used. Allowed unused args must match /^_/u.","line":42,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'walletId' is defined but never used. Allowed unused args must match /^_/u.","line":65,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asset' is defined but never used. Allowed unused args must match /^_/u.","line":65,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'portfolioValue' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":666,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":666,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'meanY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":762,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":762,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Risk Service Tests\n * Comprehensive test suite for risk management service with wallet integration\n */\n\nimport { describe, test, expect, beforeEach, mock } from 'bun:test';\nimport { riskService } from '../services/risk.service';\nimport { db } from '@/db';\n\n// Mock dependencies\nmock.module('@/db', () => ({\n  db: {\n    select: mock(() => ({\n      from: mock(() => ({\n        where: mock(() => ({\n          limit: mock(() => []),\n          orderBy: mock(() => []),\n        })),\n      })),\n    })),\n    insert: mock(() => ({\n      values: mock(() => ({\n        returning: mock(() => [{}]),\n      })),\n    })),\n    update: mock(() => ({\n      set: mock(() => ({\n        where: mock(() => ({\n          returning: mock(() => [{}]),\n        })),\n      })),\n    })),\n    delete: mock(() => ({\n      where: mock(() => ({})),\n    })),\n  },\n}));\n\n// Mock wallet service\nmock.module('../../banco/services/wallet.service', () => ({\n  walletService: {\n    getWalletSummary: mock((walletId: string) =>\n      Promise.resolve({\n        totalValueUsd: '100000',\n        totalValueBtc: '2.5',\n        assets: [\n          {\n            asset: 'USDT',\n            balance: '50000',\n            availableBalance: '45000',\n            lockedBalance: '5000',\n            valueUsd: '50000',\n          },\n          {\n            asset: 'BTC',\n            balance: '1.5',\n            availableBalance: '1.4',\n            lockedBalance: '0.1',\n            valueUsd: '50000',\n          },\n        ],\n        assetCount: 2,\n      })\n    ),\n    getAssetBalance: mock((walletId: string, asset: string) =>\n      Promise.resolve({\n        balance: '50000',\n        availableBalance: '45000',\n        lockedBalance: '5000',\n        valueUsd: '50000',\n      })\n    ),\n  },\n}));\n\n// Test data generators\nconst createTestRiskProfile = () => ({\n  id: 'profile-1',\n  userId: 'user-1',\n  tenantId: 'tenant-1',\n  riskTolerance: 'moderate' as const,\n  maxPortfolioRisk: 2.0,\n  maxPositionRisk: 1.0,\n  maxDrawdown: 10.0,\n  defaultPositionSize: 2.0,\n  maxPositionSize: 5.0,\n  useKellyCriterion: false,\n  kellyFraction: 0.5,\n  maxLeverage: 3.0,\n  maxMarginUtilization: 80.0,\n  maxTotalExposure: 100.0,\n  maxLongExposure: 80.0,\n  maxShortExposure: 50.0,\n  maxSingleAssetExposure: 20.0,\n  maxCorrelatedExposure: 40.0,\n  minDiversification: 3,\n  defaultStopLoss: 2.0,\n  useTrailingStop: true,\n  defaultTrailingStop: 3.0,\n  minRiskRewardRatio: 2.0,\n  alertOnLimitViolation: true,\n  alertOnDrawdown: true,\n  alertOnLargePosition: true,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n});\n\nconst createTestWallet = () => ({\n  id: 'wallet-1',\n  userId: 'user-1',\n  tenantId: 'tenant-1',\n  exchangeId: 'binance',\n  type: 'spot' as const,\n  status: 'active' as const,\n  balances: {},\n  lastSync: new Date(),\n  createdAt: new Date(),\n  updatedAt: new Date(),\n});\n\nconst createTestPosition = () => ({\n  id: 'position-1',\n  userId: 'user-1',\n  tenantId: 'tenant-1',\n  strategyId: 'strategy-1',\n  exchangeId: 'binance',\n  symbol: 'BTC/USDT',\n  side: 'long' as const,\n  type: 'market' as const,\n  status: 'open' as const,\n  entryPrice: '50000',\n  currentPrice: '51000',\n  quantity: '1',\n  remainingQuantity: '1',\n  stopLoss: '48000',\n  takeProfit: '55000',\n  leverage: '2',\n  marginUsed: '25000',\n  unrealizedPnl: '1000',\n  realizedPnl: '0',\n  fees: '50',\n  openedAt: new Date(),\n  createdAt: new Date(),\n  updatedAt: new Date(),\n});\n\ndescribe('RiskService - Wallet Integration', () => {\n  beforeEach(() => {\n    // Reset mocks\n    mock.restore();\n  });\n\n  test('should calculate cashBalance from wallet', async () => {\n    // Mock db.select to return wallet\n    const mockWallet = createTestWallet();\n    db.select = mock(() => ({\n      from: mock(() => ({\n        where: mock(() => ({\n          limit: mock(() => [mockWallet]),\n        })),\n      })),\n    })) as any;\n\n    // Mock positions\n    db.select = mock(() => ({\n      from: mock(() => ({\n        where: mock(() => []),\n      })),\n    })) as any;\n\n    // Note: In a real test, we'd verify the wallet service was called\n    // and returned the expected totalValueUsd\n    expect(true).toBe(true);\n  });\n\n  test('should calculate marginAvailable correctly', async () => {\n    // marginAvailable = totalBalance - marginUsed - lockedFunds\n    const totalBalance = 100000;\n    const marginUsed = 25000;\n    const lockedFunds = 5000;\n    const expectedMarginAvailable = 70000;\n\n    const result = totalBalance - marginUsed - lockedFunds;\n\n    expect(result).toBe(expectedMarginAvailable);\n  });\n\n  test('should handle wallet not found gracefully', async () => {\n    // Mock db.select to return empty array\n    db.select = mock(() => ({\n      from: mock(() => ({\n        where: mock(() => ({\n          limit: mock(() => []),\n        })),\n      })),\n    })) as any;\n\n    // cashBalance should default to 0\n    // marginAvailable should default to 0\n    expect(true).toBe(true);\n  });\n\n  test('should calculate marginUtilization percentage', async () => {\n    const marginUsed = 25000;\n    const totalBalance = 100000;\n    const expectedUtilization = 25; // 25%\n\n    const utilization = (marginUsed / totalBalance) * 100;\n\n    expect(utilization).toBe(expectedUtilization);\n  });\n\n  test('should handle zero balance gracefully', async () => {\n    const marginUsed = 0;\n    const totalBalance = 0;\n\n    // Should not divide by zero\n    const utilization = totalBalance > 0 ? (marginUsed / totalBalance) * 100 : 0;\n\n    expect(utilization).toBe(0);\n  });\n});\n\ndescribe('RiskService - Position Breakdown', () => {\n  test('should create position breakdown for VaR', () => {\n    const position = createTestPosition();\n    const positionValue = parseFloat(position.currentPrice) * parseFloat(position.remainingQuantity);\n    const unrealizedPnl = parseFloat(position.unrealizedPnl);\n    const riskAmount = Math.abs(unrealizedPnl);\n    const riskPercent = (riskAmount / positionValue) * 100;\n\n    const breakdown = {\n      symbol: position.symbol,\n      side: position.side,\n      size: positionValue,\n      unrealizedPnl,\n      leverage: parseFloat(position.leverage),\n      riskAmount,\n      riskPercent,\n    };\n\n    expect(breakdown.symbol).toBe('BTC/USDT');\n    expect(breakdown.side).toBe('long');\n    expect(breakdown.size).toBe(51000); // 51000 * 1\n    expect(breakdown.unrealizedPnl).toBe(1000);\n    expect(breakdown.leverage).toBe(2);\n    expect(breakdown.riskAmount).toBe(1000);\n    expect(breakdown.riskPercent).toBeCloseTo(1.96, 2); // (1000/51000)*100\n  });\n\n  test('should sort breakdown by risk descending', () => {\n    const breakdowns = [\n      { symbol: 'BTC/USDT', riskAmount: 1000, riskPercent: 2 },\n      { symbol: 'ETH/USDT', riskAmount: 500, riskPercent: 1 },\n      { symbol: 'BNB/USDT', riskAmount: 1500, riskPercent: 3 },\n    ];\n\n    breakdowns.sort((a, b) => b.riskAmount - a.riskAmount);\n\n    expect(breakdowns[0].symbol).toBe('BNB/USDT');\n    expect(breakdowns[1].symbol).toBe('BTC/USDT');\n    expect(breakdowns[2].symbol).toBe('ETH/USDT');\n  });\n\n  test('should handle positions with no leverage', () => {\n    const position = { ...createTestPosition(), leverage: null };\n\n    const leverage = position.leverage ? parseFloat(position.leverage) : undefined;\n\n    expect(leverage).toBeUndefined();\n  });\n\n  test('should calculate risk percent correctly for zero value', () => {\n    const positionValue = 0;\n    const riskAmount = 1000;\n\n    const riskPercent = positionValue > 0 ? (riskAmount / positionValue) * 100 : 0;\n\n    expect(riskPercent).toBe(0);\n  });\n});\n\ndescribe('RiskService - Risk Score Calculation', () => {\n  test('should calculate risk score for high leverage', () => {\n    const params = {\n      leverage: 15,\n      exposurePercent: 90,\n      drawdown: 8,\n      positionCount: 5,\n      marginUtilization: 0,\n    };\n\n    let score = 0;\n\n    // Leverage scoring\n    if (params.leverage > 10) score += 30;\n    else if (params.leverage > 5) score += 20;\n    else if (params.leverage > 3) score += 10;\n\n    // Exposure scoring\n    if (params.exposurePercent > 100) score += 25;\n    else if (params.exposurePercent > 80) score += 15;\n    else if (params.exposurePercent > 50) score += 5;\n\n    expect(score).toBe(45); // 30 + 15\n  });\n\n  test('should cap risk score at 100', () => {\n    const params = {\n      leverage: 15,\n      exposurePercent: 150,\n      drawdown: 25,\n      positionCount: 1,\n      marginUtilization: 0,\n    };\n\n    let score = 0;\n    if (params.leverage > 10) score += 30;\n    if (params.exposurePercent > 100) score += 25;\n    if (params.drawdown > 20) score += 25;\n    if (params.positionCount < 3) score += 20;\n\n    score = Math.min(100, score);\n\n    expect(score).toBe(100);\n  });\n\n  test('should give low score for conservative portfolio', () => {\n    const params = {\n      leverage: 1.5,\n      exposurePercent: 40,\n      drawdown: 2,\n      positionCount: 10,\n      marginUtilization: 0,\n    };\n\n    let score = 0;\n\n    // No scoring triggers for conservative setup\n    if (params.leverage > 10) score += 30;\n    else if (params.leverage > 5) score += 20;\n    else if (params.leverage > 3) score += 10;\n\n    expect(score).toBe(0);\n  });\n});\n\ndescribe('RiskService - Position Sizing', () => {\n  test('should calculate fixed position size', () => {\n    const portfolioValue = 100000;\n    const defaultPositionSize = 2; // 2%\n    const entryPrice = 50000;\n\n    const recommendedSize = (portfolioValue * defaultPositionSize) / 100 / entryPrice;\n\n    expect(recommendedSize).toBeCloseTo(0.04, 4); // 0.04 BTC\n  });\n\n  test('should apply Kelly criterion', () => {\n    const portfolioValue = 100000;\n    const maxPositionRisk = 1; // 1%\n    const kellyFraction = 0.5;\n    const riskPerUnit = 2000;\n\n    const riskAmount = (portfolioValue * maxPositionRisk) / 100;\n    const recommendedSize = (riskAmount / riskPerUnit) * kellyFraction;\n\n    expect(recommendedSize).toBe(0.25); // 0.25 BTC\n  });\n\n  test('should cap position size at maximum', () => {\n    const portfolioValue = 100000;\n    const maxPositionSize = 5; // 5%\n    const entryPrice = 50000;\n\n    const recommendedSize = 10; // Calculated size exceeds max\n    const maxSize = (portfolioValue * maxPositionSize) / 100 / entryPrice;\n\n    const finalSize = Math.min(recommendedSize, maxSize);\n\n    expect(finalSize).toBe(0.1); // 0.1 BTC (capped)\n  });\n});\n\ndescribe('RiskService - Risk/Reward Analysis', () => {\n  test('should calculate risk/reward ratio', () => {\n    const entryPrice = 50000;\n    const stopLoss = 48000;\n    const takeProfit = 56000;\n\n    const riskAmount = Math.abs(entryPrice - stopLoss);\n    const rewardAmount = Math.abs(takeProfit - entryPrice);\n    const riskRewardRatio = rewardAmount / riskAmount;\n\n    expect(riskRewardRatio).toBe(3); // 6000/2000 = 3:1\n  });\n\n  test('should calculate expected value', () => {\n    const winProbability = 0.6;\n    const riskAmount = 2000;\n    const rewardAmount = 6000;\n\n    const expectedValue = winProbability * rewardAmount - (1 - winProbability) * riskAmount;\n\n    expect(expectedValue).toBe(2800); // 0.6*6000 - 0.4*2000\n  });\n\n  test('should recommend skip for negative expected value', () => {\n    const winProbability = 0.3;\n    const riskAmount = 2000;\n    const rewardAmount = 3000;\n\n    const expectedValue = winProbability * rewardAmount - (1 - winProbability) * riskAmount;\n\n    expect(expectedValue).toBeLessThan(0);\n  });\n\n  test('should recommend skip for low R:R ratio', () => {\n    const minRiskRewardRatio = 2.0;\n    const actualRatio = 1.5;\n\n    const shouldSkip = actualRatio < minRiskRewardRatio;\n\n    expect(shouldSkip).toBe(true);\n  });\n});\n\ndescribe('RiskService - Drawdown Analysis', () => {\n  test('should calculate current drawdown', () => {\n    const peakValue = 110000;\n    const currentValue = 100000;\n\n    const drawdown = ((peakValue - currentValue) / peakValue) * 100;\n\n    expect(drawdown).toBeCloseTo(9.09, 2);\n  });\n\n  test('should calculate drawdown duration', () => {\n    const peakDate = new Date('2025-01-01');\n    const currentDate = new Date('2025-01-15');\n\n    const durationMs = currentDate.getTime() - peakDate.getTime();\n    const durationDays = Math.floor(durationMs / (1000 * 60 * 60 * 24));\n\n    expect(durationDays).toBe(14);\n  });\n\n  test('should identify prolonged drawdown', () => {\n    const durationDays = 45;\n    const threshold = 30;\n\n    const isProlonged = durationDays > threshold;\n\n    expect(isProlonged).toBe(true);\n  });\n\n  test('should handle zero drawdown', () => {\n    const peakValue = 100000;\n    const currentValue = 100000;\n\n    const drawdown = ((peakValue - currentValue) / peakValue) * 100;\n\n    expect(drawdown).toBe(0);\n  });\n});\n\ndescribe('RiskService - VaR Calculation', () => {\n  test('should calculate historical VaR', () => {\n    const returns = [-0.05, -0.03, -0.02, -0.01, 0, 0.01, 0.02, 0.03, 0.04, 0.05];\n    const confidence = 0.95;\n    const portfolioValue = 100000;\n\n    returns.sort((a, b) => a - b);\n    const index = Math.floor(returns.length * (1 - confidence));\n    const var95 = Math.abs(returns[index] * portfolioValue);\n\n    expect(var95).toBe(5000); // -0.05 * 100000\n  });\n\n  test('should scale VaR by time horizon', () => {\n    const oneDayVaR = 1000;\n    const timeHorizon = 10; // 10 days\n\n    const scaledVaR = oneDayVaR * Math.sqrt(timeHorizon);\n\n    expect(scaledVaR).toBeCloseTo(3162.28, 2);\n  });\n\n  test('should use correct z-score for 99% confidence', () => {\n    const confidence = 0.99;\n    const zScore = confidence === 0.99 ? 2.326 : 1.645;\n\n    expect(zScore).toBe(2.326);\n  });\n\n  test('should use correct z-score for 95% confidence', () => {\n    const confidence = 0.95;\n    const zScore = confidence === 0.99 ? 2.326 : 1.645;\n\n    expect(zScore).toBe(1.645);\n  });\n});\n\ndescribe('RiskService - Performance Ratios', () => {\n  test('should calculate Sharpe ratio', () => {\n    const annualizedReturn = 0.15; // 15%\n    const annualizedStdDev = 0.20; // 20%\n    const riskFreeRate = 0.02; // 2%\n\n    const sharpeRatio = (annualizedReturn - riskFreeRate) / annualizedStdDev;\n\n    expect(sharpeRatio).toBe(0.65);\n  });\n\n  test('should calculate Sortino ratio', () => {\n    const annualizedReturn = 0.15;\n    const downsideDeviation = 0.15;\n    const riskFreeRate = 0.02;\n\n    const sortinoRatio = (annualizedReturn - riskFreeRate) / downsideDeviation;\n\n    expect(sortinoRatio).toBeCloseTo(0.867, 3);\n  });\n\n  test('should calculate Calmar ratio', () => {\n    const annualizedReturn = 0.15;\n    const maxDrawdown = 10; // 10%\n\n    const calmarRatio = annualizedReturn / (maxDrawdown / 100);\n\n    expect(calmarRatio).toBeCloseTo(1.5, 1);\n  });\n\n  test('should handle zero max drawdown', () => {\n    const annualizedReturn = 0.15;\n    const maxDrawdown = 0;\n\n    const calmarRatio = maxDrawdown > 0 ? annualizedReturn / (maxDrawdown / 100) : 0;\n\n    expect(calmarRatio).toBe(0);\n  });\n});\n\ndescribe('RiskService - Advanced Risk Metrics', () => {\n  test('should calculate concentration risk (HHI) for single position', () => {\n    // Single position = 100% concentration\n    const positions = [\n      { currentPrice: '50000', remainingQuantity: '1' },\n    ];\n    const portfolioValue = 50000;\n\n    let hhi = 0;\n    for (const pos of positions) {\n      const posValue = parseFloat(pos.currentPrice) * parseFloat(pos.remainingQuantity);\n      const share = posValue / portfolioValue;\n      hhi += share * share;\n    }\n\n    const concentrationRisk = hhi * 100;\n\n    expect(concentrationRisk).toBe(100); // Fully concentrated\n  });\n\n  test('should calculate concentration risk (HHI) for equal positions', () => {\n    // 4 equal positions = 25% each\n    const positions = [\n      { currentPrice: '50000', remainingQuantity: '0.25' },\n      { currentPrice: '40000', remainingQuantity: '0.3125' },\n      { currentPrice: '30000', remainingQuantity: '0.4167' },\n      { currentPrice: '20000', remainingQuantity: '0.625' },\n    ];\n    const portfolioValue = 50000;\n\n    let hhi = 0;\n    for (const pos of positions) {\n      const posValue = parseFloat(pos.currentPrice) * parseFloat(pos.remainingQuantity);\n      const share = posValue / portfolioValue;\n      hhi += share * share;\n    }\n\n    const concentrationRisk = hhi * 100;\n\n    expect(concentrationRisk).toBeCloseTo(25, 0); // Low concentration\n  });\n\n  test('should calculate concentration risk (HHI) for unequal positions', () => {\n    // Unequal positions: 50%, 30%, 20%\n    const positions = [\n      { currentPrice: '50000', remainingQuantity: '0.5' }, // 25000 (50%)\n      { currentPrice: '30000', remainingQuantity: '0.5' }, // 15000 (30%)\n      { currentPrice: '20000', remainingQuantity: '0.5' }, // 10000 (20%)\n    ];\n    const portfolioValue = 50000;\n\n    let hhi = 0;\n    for (const pos of positions) {\n      const posValue = parseFloat(pos.currentPrice) * parseFloat(pos.remainingQuantity);\n      const share = posValue / portfolioValue;\n      hhi += share * share;\n    }\n\n    const concentrationRisk = hhi * 100;\n\n    expect(concentrationRisk).toBeCloseTo(38, 0); // 0.5^2 + 0.3^2 + 0.2^2 = 0.38\n  });\n\n  test('should handle empty positions for concentration risk', () => {\n    const positions: any[] = [];\n    const portfolioValue = 0;\n\n    const concentrationRisk = positions.length === 0 || portfolioValue === 0 ? 0 : 50;\n\n    expect(concentrationRisk).toBe(0);\n  });\n\n  test('should calculate CVaR from historical returns', () => {\n    // Simulate returns: worst 5% beyond VaR (need more data points)\n    const returns = Array(100).fill(0).map((_, i) => {\n      if (i < 5) return -0.10; // Worst 5%\n      if (i < 10) return -0.05;\n      return (i - 50) / 1000; // Normal distribution around 0\n    });\n    const confidence = 0.95;\n    const portfolioValue = 100000;\n\n    // Sort returns ascending (worst first)\n    returns.sort((a, b) => a - b);\n\n    // Get returns worse than VaR threshold (worst 5%)\n    const varIndex = Math.floor(returns.length * (1 - confidence));\n    const tailReturns = returns.slice(0, Math.max(1, varIndex)); // Ensure at least 1 element\n\n    // Average of tail losses\n    const avgTailLoss = tailReturns.reduce((sum, r) => sum + r, 0) / tailReturns.length;\n    const cvar = Math.abs(avgTailLoss * portfolioValue);\n\n    expect(cvar).toBeGreaterThan(5000); // Significant tail loss\n    expect(cvar).toBeLessThan(15000);\n  });\n\n  test('should calculate CVaR for multiple tail losses', () => {\n    // Use 50 data points so 10% confidence gives us 5 tail values\n    const returns = Array(50).fill(0).map((_, i) => {\n      if (i < 5) return -0.10; // Worst 5 (10%)\n      if (i < 10) return -0.05;\n      if (i < 15) return -0.02;\n      return (i - 25) / 1000; // Normal distribution\n    });\n    const confidence = 0.90; // 90% confidence = worst 10%\n    const portfolioValue = 100000;\n\n    returns.sort((a, b) => a - b);\n    const varIndex = Math.floor(returns.length * (1 - confidence));\n    const tailReturns = returns.slice(0, Math.max(1, varIndex));\n\n    const avgTailLoss = tailReturns.reduce((sum, r) => sum + r, 0) / tailReturns.length;\n    const cvar = Math.abs(avgTailLoss * portfolioValue);\n\n    expect(cvar).toBeGreaterThan(5000); // Should be significant\n    expect(cvar).toBeLessThan(15000);\n    expect(tailReturns.length).toBeGreaterThan(1); // Multiple tail values\n  });\n\n  test('should handle insufficient data for CVaR', () => {\n    const returns: number[] = [];\n    const portfolioValue = 100000;\n\n    const cvar = returns.length === 0 ? 0 : 1000;\n\n    expect(cvar).toBe(0);\n  });\n\n  test('should calculate correlation average for diversified portfolio', () => {\n    // More positions = lower average correlation (simplified)\n    const positionCount = 10;\n\n    const correlationAverage = positionCount > 1\n      ? Math.max(0, 1 - (positionCount / 20))\n      : 0;\n\n    expect(correlationAverage).toBe(0.5); // 1 - 10/20 = 0.5\n  });\n\n  test('should calculate correlation average for concentrated portfolio', () => {\n    const positionCount = 2;\n\n    const correlationAverage = positionCount > 1\n      ? Math.max(0, 1 - (positionCount / 20))\n      : 0;\n\n    expect(correlationAverage).toBe(0.9); // 1 - 2/20 = 0.9\n  });\n\n  test('should handle single position for correlation', () => {\n    const positionCount = 1;\n\n    const correlationAverage = positionCount > 1\n      ? Math.max(0, 1 - (positionCount / 20))\n      : 0;\n\n    expect(correlationAverage).toBe(0);\n  });\n\n  test('should calculate Pearson correlation coefficient', () => {\n    const x = [1, 2, 3, 4, 5];\n    const y = [2, 4, 6, 8, 10];\n\n    const n = Math.min(x.length, y.length);\n    const meanX = x.slice(0, n).reduce((a, b) => a + b, 0) / n;\n    const meanY = y.slice(0, n).reduce((a, b) => a + b, 0) / n;\n\n    let numerator = 0;\n    let denomX = 0;\n    let denomY = 0;\n\n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      const dy = y[i] - meanY;\n      numerator += dx * dy;\n      denomX += dx * dx;\n      denomY += dy * dy;\n    }\n\n    const denominator = Math.sqrt(denomX * denomY);\n    const correlation = denominator > 0 ? numerator / denominator : 0;\n\n    expect(correlation).toBe(1); // Perfect positive correlation\n  });\n\n  test('should calculate Pearson correlation for uncorrelated series', () => {\n    const x = [1, 2, 3, 4, 5];\n    const y = [5, 3, 2, 4, 1]; // Random order\n\n    const n = Math.min(x.length, y.length);\n    const meanX = x.slice(0, n).reduce((a, b) => a + b, 0) / n;\n    const meanY = y.slice(0, n).reduce((a, b) => a + b, 0) / n;\n\n    let numerator = 0;\n    let denomX = 0;\n    let denomY = 0;\n\n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      const dy = y[i] - meanY;\n      numerator += dx * dy;\n      denomX += dx * dx;\n      denomY += dy * dy;\n    }\n\n    const denominator = Math.sqrt(denomX * denomY);\n    const correlation = denominator > 0 ? numerator / denominator : 0;\n\n    expect(Math.abs(correlation)).toBeLessThan(1); // Not perfectly correlated\n  });\n\n  test('should handle zero denominator in Pearson correlation', () => {\n    const x = [1, 1, 1]; // Constant values\n    const y = [2, 3, 4];\n\n    const n = Math.min(x.length, y.length);\n    const meanX = x.slice(0, n).reduce((a, b) => a + b, 0) / n;\n    const meanY = y.slice(0, n).reduce((a, b) => a + b, 0) / n;\n\n    let denomX = 0;\n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      denomX += dx * dx;\n    }\n\n    const denominator = Math.sqrt(denomX);\n    const correlation = denominator > 0 ? 1 : 0; // Would be division by zero\n\n    expect(correlation).toBe(0);\n  });\n});\n\ndescribe('RiskService - Trade Validation', () => {\n  test('should allow valid trade', () => {\n    const profile = createTestRiskProfile();\n    const tradeValue = 2000;\n    const portfolioValue = 100000;\n\n    const positionSizePercent = (tradeValue / portfolioValue) * 100;\n    const allowed = positionSizePercent <= profile.maxPositionSize;\n\n    expect(allowed).toBe(true);\n  });\n\n  test('should reject oversized trade', () => {\n    const profile = createTestRiskProfile();\n    const tradeValue = 10000; // 10% of portfolio\n    const portfolioValue = 100000;\n\n    const positionSizePercent = (tradeValue / portfolioValue) * 100;\n    const allowed = positionSizePercent <= profile.maxPositionSize; // max 5%\n\n    expect(allowed).toBe(false);\n  });\n\n  test('should check total exposure limit', () => {\n    const profile = createTestRiskProfile();\n    const currentExposure = 85; // 85%\n    const newPositionSize = 20; // 20%\n\n    const newExposure = currentExposure + newPositionSize;\n    const allowed = newExposure <= profile.maxTotalExposure;\n\n    expect(allowed).toBe(false);\n  });\n\n  test('should warn on high position risk', () => {\n    const profile = createTestRiskProfile();\n    const price = 50000;\n    const stopLoss = 45000;\n\n    const riskPerUnit = Math.abs(price - stopLoss);\n    const riskPercent = (riskPerUnit / price) * 100;\n    const isHighRisk = riskPercent > profile.maxPositionRisk;\n\n    expect(isHighRisk).toBe(true); // 10% > 1%\n  });\n});\n\ndescribe('RiskService - Diversification', () => {\n  test('should calculate diversification score', () => {\n    const positionCount = 5;\n    const maxScore = 100;\n    const optimalCount = 10;\n\n    const score = (positionCount / optimalCount) * maxScore;\n\n    expect(score).toBe(50);\n  });\n\n  test('should cap diversification score at 100', () => {\n    const positionCount = 15;\n    const optimalCount = 10;\n\n    const score = positionCount >= optimalCount ? 100 : (positionCount / optimalCount) * 100;\n\n    expect(score).toBe(100);\n  });\n\n  test('should return 0 for no positions', () => {\n    const positionCount = 0;\n\n    const score = positionCount === 0 ? 0 : (positionCount / 10) * 100;\n\n    expect(score).toBe(0);\n  });\n});\n\ndescribe('RiskService - Volatility Analysis', () => {\n  test('should annualize volatility', () => {\n    const dailyVolatility = 0.02; // 2%\n    const tradingDays = 252;\n\n    const annualizedVolatility = dailyVolatility * Math.sqrt(tradingDays) * 100;\n\n    expect(annualizedVolatility).toBeCloseTo(31.75, 2);\n  });\n\n  test('should identify elevated volatility', () => {\n    const currentVolatility = 45;\n    const historicalVolatility = 25;\n    const threshold = 1.5;\n\n    const isElevated = currentVolatility > historicalVolatility * threshold;\n\n    expect(isElevated).toBe(true);\n  });\n\n  test('should identify decreasing volatility', () => {\n    const currentVolatility = 15;\n    const historicalVolatility = 25;\n    const threshold = 0.8;\n\n    const isDecreasing = currentVolatility < historicalVolatility * threshold;\n\n    expect(isDecreasing).toBe(true);\n  });\n\n  test('should identify stable volatility', () => {\n    const currentVolatility = 25;\n    const historicalVolatility = 24;\n\n    const isElevated = currentVolatility > historicalVolatility * 1.2;\n    const isDecreasing = currentVolatility < historicalVolatility * 0.8;\n    const isStable = !isElevated && !isDecreasing;\n\n    expect(isStable).toBe(true);\n  });\n});\n\ndescribe('RiskService - Edge Cases', () => {\n  test('should handle negative unrealized PnL', () => {\n    const unrealizedPnl = -1000;\n    const riskAmount = Math.abs(unrealizedPnl);\n\n    expect(riskAmount).toBe(1000);\n  });\n\n  test('should handle very small numbers', () => {\n    const value = 0.0001;\n    const formatted = parseFloat(value.toString());\n\n    expect(formatted).toBe(0.0001);\n  });\n\n  test('should handle very large numbers', () => {\n    const value = 1000000000;\n    const formatted = parseFloat(value.toString());\n\n    expect(formatted).toBe(1000000000);\n  });\n\n  test('should handle division by zero gracefully', () => {\n    const numerator = 100;\n    const denominator = 0;\n\n    const result = denominator > 0 ? numerator / denominator : 0;\n\n    expect(result).toBe(0);\n  });\n\n  test('should handle empty arrays', () => {\n    const arr: number[] = [];\n    const sum = arr.reduce((a, b) => a + b, 0);\n\n    expect(sum).toBe(0);\n  });\n\n  test('should handle NaN values', () => {\n    const value = parseFloat('invalid');\n\n    expect(isNaN(value)).toBe(true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/jobs/data-retention.job.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/routes/risk.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/schema/risk.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/services/risk-cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/services/risk-lock.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/services/risk-retention.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'and' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eq' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pipeline' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Readable' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cutoffDate' is defined but never used. Allowed unused args must match /^_/u.","line":185,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'importError' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":322,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":322,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Risk Data Retention Service\n * Manages archival and cleanup of old risk metrics data\n *\n * Policy:\n * - Keep 90 days in PostgreSQL\n * - Archive to S3 before deletion\n * - Compress with gzip\n * - Run daily at 2 AM\n */\n\nimport { db } from '@/db';\nimport { riskMetrics } from '../schema/risk.schema';\nimport { lt, sql, and, eq } from 'drizzle-orm';\nimport { logInfo, logError, logWarn, logDebug } from '@/utils/logger';\nimport { createGzip } from 'zlib';\nimport { pipeline } from 'stream/promises';\nimport { Readable } from 'stream';\n\n/**\n * Data Retention Configuration\n */\nexport const RETENTION_CONFIG = {\n  retentionDays: 90,\n  archiveBatchSize: 10000, // Process in batches to avoid memory issues\n  compressionLevel: 6, // gzip compression (0-9)\n  schedule: '0 2 * * *', // Daily at 2 AM (cron format)\n} as const;\n\n/**\n * Archive Statistics\n */\nexport interface ArchiveStats {\n  totalRecords: number;\n  recordsArchived: number;\n  recordsDeleted: number;\n  batches: number;\n  startTime: Date;\n  endTime: Date;\n  duration: number; // milliseconds\n  bytesArchived: number;\n  errors: string[];\n}\n\n/**\n * Risk Retention Service\n * Handles data archival and cleanup\n */\nexport class RiskRetentionService {\n  /**\n   * Archive and delete old risk metrics\n   * @param dryRun - If true, only count records without archiving/deleting\n   * @returns Archive statistics\n   */\n  async archiveOldMetrics(dryRun = false): Promise<ArchiveStats> {\n    const startTime = new Date();\n    const stats: ArchiveStats = {\n      totalRecords: 0,\n      recordsArchived: 0,\n      recordsDeleted: 0,\n      batches: 0,\n      startTime,\n      endTime: new Date(),\n      duration: 0,\n      bytesArchived: 0,\n      errors: [],\n    };\n\n    try {\n      logInfo('📦 Starting data retention process...', {\n        dryRun,\n        retentionDays: RETENTION_CONFIG.retentionDays,\n      });\n\n      // Calculate cutoff date (90 days ago)\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - RETENTION_CONFIG.retentionDays);\n\n      // Count total records to archive\n      const countResult = await db\n        .select({ count: sql<number>`count(*)` })\n        .from(riskMetrics)\n        .where(lt(riskMetrics.calculatedAt, cutoffDate));\n\n      stats.totalRecords = Number(countResult[0]?.count || 0);\n\n      if (stats.totalRecords === 0) {\n        logInfo('✅ No records to archive');\n        stats.endTime = new Date();\n        stats.duration = stats.endTime.getTime() - startTime.getTime();\n        return stats;\n      }\n\n      logInfo(`📊 Found ${stats.totalRecords} records to archive`, {\n        cutoffDate: cutoffDate.toISOString(),\n      });\n\n      if (dryRun) {\n        logInfo('🏃 Dry run - skipping archive and delete operations');\n        stats.endTime = new Date();\n        stats.duration = stats.endTime.getTime() - startTime.getTime();\n        return stats;\n      }\n\n      // Process in batches\n      let offset = 0;\n      while (offset < stats.totalRecords) {\n        try {\n          stats.batches++;\n          logInfo(`📦 Processing batch ${stats.batches}...`, {\n            offset,\n            batchSize: RETENTION_CONFIG.archiveBatchSize,\n          });\n\n          // Fetch batch of old records\n          const batch = await db\n            .select()\n            .from(riskMetrics)\n            .where(lt(riskMetrics.calculatedAt, cutoffDate))\n            .limit(RETENTION_CONFIG.archiveBatchSize)\n            .offset(offset);\n\n          if (batch.length === 0) break;\n\n          // Archive to S3 (or file system if S3 not configured)\n          const archiveResult = await this.archiveBatch(batch, cutoffDate);\n          stats.bytesArchived += archiveResult.bytes;\n          stats.recordsArchived += batch.length;\n\n          // Delete archived records from database\n          const idsToDelete = batch.map(r => r.id);\n          await this.deleteBatch(idsToDelete);\n          stats.recordsDeleted += batch.length;\n\n          logInfo(`✅ Batch ${stats.batches} completed`, {\n            archived: batch.length,\n            totalArchived: stats.recordsArchived,\n            totalDeleted: stats.recordsDeleted,\n          });\n\n          offset += RETENTION_CONFIG.archiveBatchSize;\n        } catch (error) {\n          const errorMsg = `Batch ${stats.batches} failed: ${error instanceof Error ? error.message : String(error)}`;\n          const err = error instanceof Error ? error : new Error(errorMsg);\n          logError(err, { batch: stats.batches });\n          stats.errors.push(errorMsg);\n\n          // Continue with next batch even if one fails\n          offset += RETENTION_CONFIG.archiveBatchSize;\n        }\n      }\n\n      stats.endTime = new Date();\n      stats.duration = stats.endTime.getTime() - startTime.getTime();\n\n      logInfo('✅ Data retention process completed', {\n        totalRecords: stats.totalRecords,\n        recordsArchived: stats.recordsArchived,\n        recordsDeleted: stats.recordsDeleted,\n        batches: stats.batches,\n        duration: `${(stats.duration / 1000).toFixed(2)}s`,\n        bytesArchived: `${(stats.bytesArchived / 1024 / 1024).toFixed(2)} MB`,\n        errors: stats.errors.length,\n      });\n\n      return stats;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logError(err, { message: '❌ Data retention process failed' });\n      stats.errors.push(`Fatal error: ${err.message}`);\n      stats.endTime = new Date();\n      stats.duration = stats.endTime.getTime() - startTime.getTime();\n      throw error;\n    }\n  }\n\n  /**\n   * Archive a batch of records to storage\n   * @param batch - Records to archive\n   * @param cutoffDate - Cutoff date for filename\n   * @returns Archive result with byte count\n   */\n  private async archiveBatch(\n    batch: any[],\n    cutoffDate: Date\n  ): Promise<{ bytes: number }> {\n    try {\n      // Create JSON Lines format (one JSON object per line)\n      const jsonLines = batch.map(record => JSON.stringify(record)).join('\\n');\n      const buffer = Buffer.from(jsonLines, 'utf-8');\n\n      // Compress with gzip\n      const compressed = await this.compressData(buffer);\n\n      // Generate filename\n      const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n      const filename = `risk-metrics-archive_${timestamp}_${Date.now()}.jsonl.gz`;\n\n      // Save to storage (file system for now, S3 later)\n      await this.saveToStorage(filename, compressed);\n\n      return { bytes: compressed.length };\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to archive batch');\n      logError(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Compress data with gzip\n   */\n  private async compressData(buffer: Buffer): Promise<Buffer> {\n    return new Promise((resolve, reject) => {\n      const chunks: Buffer[] = [];\n      const gzip = createGzip({ level: RETENTION_CONFIG.compressionLevel });\n\n      gzip.on('data', (chunk) => chunks.push(chunk));\n      gzip.on('end', () => resolve(Buffer.concat(chunks)));\n      gzip.on('error', reject);\n\n      gzip.write(buffer);\n      gzip.end();\n    });\n  }\n\n  /**\n   * Save compressed data to storage\n   * Supports both local filesystem and S3\n   */\n  private async saveToStorage(filename: string, data: Buffer): Promise<void> {\n    // Always save to local filesystem first (as backup)\n    await this.saveToLocalFilesystem(filename, data);\n\n    // Upload to S3 if configured\n    if (process.env.AWS_S3_BUCKET && process.env.AWS_S3_ENABLED === 'true') {\n      try {\n        await this.uploadToS3(filename, data);\n      } catch (error) {\n        logWarn('S3 upload failed, file saved locally only', {\n          error: error instanceof Error ? error.message : String(error),\n          filename,\n        });\n      }\n    }\n  }\n\n  /**\n   * Save to local filesystem\n   */\n  private async saveToLocalFilesystem(filename: string, data: Buffer): Promise<void> {\n    const archivePath = process.env.RISK_ARCHIVE_PATH || './data/archives';\n\n    // Ensure directory exists\n    const fs = await import('fs/promises');\n    await fs.mkdir(archivePath, { recursive: true });\n\n    // Write file\n    const fullPath = `${archivePath}/${filename}`;\n    await fs.writeFile(fullPath, data);\n\n    logInfo('📁 Archive saved to local filesystem', {\n      filename,\n      path: fullPath,\n      size: `${(data.length / 1024).toFixed(2)} KB`,\n    });\n  }\n\n  /**\n   * Upload archive to S3\n   * Requires AWS SDK to be installed: bun add @aws-sdk/client-s3\n   */\n  private async uploadToS3(filename: string, data: Buffer): Promise<void> {\n    try {\n      const bucket = process.env.AWS_S3_BUCKET;\n      const region = process.env.AWS_REGION || 'us-east-1';\n      const prefix = process.env.AWS_S3_PREFIX || 'risk-archives';\n\n      if (!bucket) {\n        throw new Error('AWS_S3_BUCKET not configured');\n      }\n\n      // Check if AWS SDK is available\n      try {\n        const { S3Client, PutObjectCommand } = await import('@aws-sdk/client-s3');\n\n        const s3Client = new S3Client({\n          region,\n          credentials: {\n            accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',\n            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',\n          },\n        });\n\n        const key = `${prefix}/${filename}`;\n\n        const command = new PutObjectCommand({\n          Bucket: bucket,\n          Key: key,\n          Body: data,\n          ContentType: 'application/gzip',\n          ContentEncoding: 'gzip',\n          ServerSideEncryption: 'AES256',\n          Metadata: {\n            'service': 'risk-management',\n            'type': 'metrics-archive',\n            'compressed': 'true',\n            'timestamp': new Date().toISOString(),\n          },\n        });\n\n        await s3Client.send(command);\n\n        logInfo('☁️  Archive uploaded to S3', {\n          filename,\n          bucket,\n          key,\n          size: `${(data.length / 1024).toFixed(2)} KB`,\n          region,\n        });\n\n      } catch (importError) {\n        logWarn('AWS SDK not installed - S3 upload skipped', {\n          filename,\n          hint: 'Run: bun add @aws-sdk/client-s3',\n        });\n      }\n\n    } catch (error) {\n      logError(\n        error instanceof Error ? error : new Error('S3 upload failed'),\n        {\n          filename,\n          bucket: process.env.AWS_S3_BUCKET,\n        }\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a batch of records by IDs\n   */\n  private async deleteBatch(ids: string[]): Promise<void> {\n    if (ids.length === 0) return;\n\n    await db\n      .delete(riskMetrics)\n      .where(sql`${riskMetrics.id} = ANY(${ids})`);\n\n    logDebug(`🗑️  Deleted ${ids.length} records from database`);\n  }\n\n  /**\n   * Get retention statistics\n   */\n  async getRetentionStats(): Promise<{\n    totalRecords: number;\n    oldRecords: number;\n    recentRecords: number;\n    oldestRecord: Date | null;\n    newestRecord: Date | null;\n    cutoffDate: Date;\n  }> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - RETENTION_CONFIG.retentionDays);\n\n    const [totalResult, oldResult, recentResult, oldestResult, newestResult] = await Promise.all([\n      db.select({ count: sql<number>`count(*)` }).from(riskMetrics),\n      db.select({ count: sql<number>`count(*)` }).from(riskMetrics).where(lt(riskMetrics.calculatedAt, cutoffDate)),\n      db.select({ count: sql<number>`count(*)` }).from(riskMetrics).where(sql`${riskMetrics.calculatedAt} >= ${cutoffDate}`),\n      db.select({ oldest: sql<Date>`min(${riskMetrics.calculatedAt})` }).from(riskMetrics),\n      db.select({ newest: sql<Date>`max(${riskMetrics.calculatedAt})` }).from(riskMetrics),\n    ]);\n\n    return {\n      totalRecords: Number(totalResult[0]?.count || 0),\n      oldRecords: Number(oldResult[0]?.count || 0),\n      recentRecords: Number(recentResult[0]?.count || 0),\n      oldestRecord: oldestResult[0]?.oldest || null,\n      newestRecord: newestResult[0]?.newest || null,\n      cutoffDate,\n    };\n  }\n}\n\n// Export singleton instance\nexport const riskRetentionService = new RiskRetentionService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/services/risk.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/risk/types/risk.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/__tests__/forecasting-algorithm.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/__tests__/pipeline-calculator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/routes/activities.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/routes/analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/routes/contacts.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/routes/deals.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/routes/pipeline.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/activities.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/contacts.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/deals.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/notes.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/pipeline-stages.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/sales-forecasts.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/schema/sales-targets.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/activities.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/contacts.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/deals.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/forecasting.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/pipeline.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/services/targets.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/types/sales.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/utils/forecasting-algorithm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sales/utils/pipeline-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/middleware/rbac.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/routes/security.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/schema/security.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/services/anomaly-detection.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/services/permission.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/services/role.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/security/types/security.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/agent-integration-test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/endpoints-test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_|error/u.","line":59,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentiment Endpoints Test\n * Complete test suite for all REST + WebSocket endpoints\n */\n\nconsole.log('🧪 Testing All Sentiment Endpoints\\n');\nconsole.log('='.repeat(80));\n\nconst SENTIMENT_BASE_URL = 'http://localhost:3000';\n\ninterface SentimentTestResult {\n  endpoint: string;\n  method: string;\n  status: 'PASSED' | 'FAILED' | 'SKIPPED';\n  statusCode?: number;\n  responseTime?: number;\n  error?: string;\n}\n\nconst sentimentResults: SentimentTestResult[] = [];\n\n/**\n * Helper to test endpoint\n */\nasync function testSentimentEndpoint(\n  method: string,\n  path: string,\n  body?: any,\n  description?: string\n): Promise<SentimentTestResult> {\n  const startTime = Date.now();\n  const fullPath = `${SENTIMENT_BASE_URL}${path}`;\n\n  console.log(`\\n🔄 Testing: ${method} ${path}`);\n  if (description) {\n    console.log(`   ${description}`);\n  }\n\n  try {\n    const options: RequestInit = {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (body) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(fullPath, options);\n    const responseTime = Date.now() - startTime;\n\n    const isSuccess = response.status >= 200 && response.status < 300;\n\n    let data: any;\n    try {\n      data = await response.json();\n    } catch (e) {\n      data = await response.text();\n    }\n\n    if (isSuccess) {\n      console.log(`   ✅ Status: ${response.status}`);\n      console.log(`   ⏱️  Response Time: ${responseTime}ms`);\n\n      // Show sample of response\n      if (typeof data === 'object' && data !== null) {\n        const keys = Object.keys(data);\n        console.log(`   📦 Response Keys: ${keys.slice(0, 5).join(', ')}${keys.length > 5 ? '...' : ''}`);\n      }\n\n      return {\n        endpoint: path,\n        method,\n        status: 'PASSED',\n        statusCode: response.status,\n        responseTime,\n      };\n    } else {\n      console.log(`   ❌ Failed with status: ${response.status}`);\n      console.log(`   Error: ${JSON.stringify(data).substring(0, 100)}`);\n\n      return {\n        endpoint: path,\n        method,\n        status: 'FAILED',\n        statusCode: response.status,\n        responseTime,\n        error: `HTTP ${response.status}`,\n      };\n    }\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n    console.log(`   ❌ Request Failed: ${error instanceof Error ? error.message : String(error)}`);\n\n    return {\n      endpoint: path,\n      method,\n      status: 'FAILED',\n      responseTime,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Test WebSocket\n */\nasync function testSentimentWebSocket(): Promise<SentimentTestResult> {\n  console.log(`\\n🔄 Testing: WebSocket /sentiment/stream`);\n\n  return new Promise((resolve) => {\n    const startTime = Date.now();\n\n    try {\n      const ws = new WebSocket('ws://localhost:3000/sentiment/stream');\n      let messageReceived = false;\n\n      ws.onopen = () => {\n        console.log('   ✅ WebSocket Connected');\n\n        // Subscribe to sentiment updates\n        ws.send(JSON.stringify({\n          type: 'subscribe',\n          channels: ['sentiment', 'trending'],\n        }));\n\n        // Wait for response\n        setTimeout(() => {\n          if (messageReceived) {\n            console.log('   ✅ Messages received successfully');\n            ws.close();\n          } else {\n            console.log('   ⚠️  No messages received (expected for empty data)');\n            ws.close();\n          }\n        }, 2000);\n      };\n\n      ws.onmessage = (event) => {\n        messageReceived = true;\n        const data = JSON.parse(event.data);\n        console.log(`   📨 Received: ${data.type}`);\n      };\n\n      ws.onclose = () => {\n        const responseTime = Date.now() - startTime;\n        console.log(`   🔌 WebSocket Closed (${responseTime}ms)`);\n\n        resolve({\n          endpoint: '/sentiment/stream',\n          method: 'WebSocket',\n          status: 'PASSED',\n          responseTime,\n        });\n      };\n\n      ws.onerror = (error) => {\n        const responseTime = Date.now() - startTime;\n        console.log(`   ❌ WebSocket Error: ${error}`);\n\n        resolve({\n          endpoint: '/sentiment/stream',\n          method: 'WebSocket',\n          status: 'FAILED',\n          responseTime,\n          error: String(error),\n        });\n      };\n\n      // Timeout after 5 seconds\n      setTimeout(() => {\n        if (ws.readyState !== WebSocket.CLOSED) {\n          ws.close();\n        }\n      }, 5000);\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      console.log(`   ❌ Failed to create WebSocket: ${error}`);\n\n      resolve({\n        endpoint: '/sentiment/stream',\n        method: 'WebSocket',\n        status: 'FAILED',\n        responseTime,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  });\n}\n\n/**\n * Check if server is running\n */\nasync function checkSentimentServer(): Promise<boolean> {\n  console.log('\\n🔍 Checking if server is running...');\n\n  try {\n    const response = await fetch(`${SENTIMENT_BASE_URL}/health`, { method: 'GET' });\n    if (response.ok) {\n      console.log('✅ Server is running\\n');\n      return true;\n    }\n  } catch (error) {\n    // Server not running\n  }\n\n  console.log('❌ Server is NOT running');\n  console.log('⚠️  Please start the server first: bun run dev\\n');\n  return false;\n}\n\n/**\n * Run all endpoint tests\n */\nasync function runSentimentEndpointTests() {\n  const startTime = Date.now();\n\n  console.log('\\n🚀 Starting Endpoint Tests...\\n');\n\n  // Check if server is running\n  const serverRunning = await checkSentimentServer();\n  if (!serverRunning) {\n    console.log('💡 To start the server: bun run dev');\n    console.log('💡 Then run this test again');\n    return;\n  }\n\n  console.log('='.repeat(80));\n  console.log('📋 REST ENDPOINTS');\n  console.log('='.repeat(80));\n\n  // Test 1: Health Check\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/health',\n    undefined,\n    'Check service health status'\n  ));\n\n  // Test 2: Get Sentiment for Symbol\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/BTC',\n    undefined,\n    'Get aggregated sentiment for BTC'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/ETH?timeWindow=3600000',\n    undefined,\n    'Get sentiment for ETH with custom time window'\n  ));\n\n  // Test 3: Trending Topics\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/trending',\n    undefined,\n    'Get all trending topics'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/trending?symbol=BTC&limit=10',\n    undefined,\n    'Get trending topics for BTC'\n  ));\n\n  // Test 4: News Articles\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/news?limit=10',\n    undefined,\n    'Get recent news articles'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/news?symbol=BTC&source=cryptopanic&limit=5',\n    undefined,\n    'Get BTC news from CryptoPanic'\n  ));\n\n  // Test 5: Social Media\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/social/twitter?symbol=BTC&limit=10',\n    undefined,\n    'Get Twitter mentions for BTC'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/social/reddit?symbol=ETH&limit=10',\n    undefined,\n    'Get Reddit mentions for ETH'\n  ));\n\n  // Test 6: Analyze Text\n  sentimentResults.push(await testSentimentEndpoint(\n    'POST',\n    '/sentiment/analyze',\n    {\n      text: 'Bitcoin is going to the moon! 🚀 This is bullish AF! HODL strong!',\n      options: {\n        context: {\n          symbol: 'BTC',\n          source: 'twitter',\n        },\n      },\n    },\n    'Analyze bullish text'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'POST',\n    '/sentiment/analyze',\n    {\n      text: 'Market crash incoming! Dump everything! Bear market confirmed 📉',\n      options: {\n        context: {\n          symbol: 'BTC',\n        },\n      },\n    },\n    'Analyze bearish text'\n  ));\n\n  // Test 7: Batch Analyze\n  sentimentResults.push(await testSentimentEndpoint(\n    'POST',\n    '/sentiment/analyze/batch',\n    {\n      texts: [\n        { id: '1', text: 'Bitcoin hitting new ATH! 🚀' },\n        { id: '2', text: 'Ethereum is pumping hard!' },\n        { id: '3', text: 'Market looking bearish today 📉' },\n      ],\n    },\n    'Batch analyze multiple texts'\n  ));\n\n  // Test 8: Correlation\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/correlation/BTC',\n    undefined,\n    'Get sentiment-price correlation for BTC'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/correlation/ETH?timeframe=24h',\n    undefined,\n    'Get correlation with timeframe'\n  ));\n\n  // Test 9: Signals\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/signals/BTC',\n    undefined,\n    'Get trading signals for BTC'\n  ));\n\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/signals/ETH',\n    undefined,\n    'Get trading signals for ETH'\n  ));\n\n  // Test 10: Stats\n  sentimentResults.push(await testSentimentEndpoint(\n    'GET',\n    '/sentiment/stats',\n    undefined,\n    'Get service statistics'\n  ));\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📡 WEBSOCKET ENDPOINT');\n  console.log('='.repeat(80));\n\n  // Test 11: WebSocket\n  sentimentResults.push(await testSentimentWebSocket());\n\n  // Final Summary\n  const duration = Date.now() - startTime;\n  const passed = sentimentResults.filter((r) => r.status === 'PASSED').length;\n  const failed = sentimentResults.filter((r) => r.status === 'FAILED').length;\n  const skipped = sentimentResults.filter((r) => r.status === 'SKIPPED').length;\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('📊 TEST SUMMARY');\n  console.log('='.repeat(80));\n  console.log(`Total Endpoints: ${sentimentResults.length}`);\n  console.log(`✅ Passed: ${passed}`);\n  console.log(`❌ Failed: ${failed}`);\n  console.log(`⏭️  Skipped: ${skipped}`);\n  console.log(`\\n⏱️  Total Time: ${(duration / 1000).toFixed(2)}s`);\n  console.log('='.repeat(80));\n\n  // Detailed Results\n  if (failed > 0) {\n    console.log('\\n❌ FAILED TESTS:');\n    sentimentResults\n      .filter((r) => r.status === 'FAILED')\n      .forEach((r) => {\n        console.log(`\\n  ${r.method} ${r.endpoint}`);\n        console.log(`  Error: ${r.error}`);\n        if (r.statusCode) {\n          console.log(`  Status Code: ${r.statusCode}`);\n        }\n      });\n  }\n\n  // Performance Summary\n  const avgResponseTime =\n    sentimentResults\n      .filter((r) => r.responseTime !== undefined)\n      .reduce((sum, r) => sum + (r.responseTime || 0), 0) / sentimentResults.length;\n\n  console.log('\\n📈 PERFORMANCE:');\n  console.log(`Average Response Time: ${avgResponseTime.toFixed(0)}ms`);\n\n  const fastestEndpoint = sentimentResults.reduce((fastest, current) => {\n    if (!current.responseTime) return fastest;\n    if (!fastest.responseTime) return current;\n    return current.responseTime < fastest.responseTime ? current : fastest;\n  }, sentimentResults[0]);\n\n  const slowestEndpoint = sentimentResults.reduce((slowest, current) => {\n    if (!current.responseTime) return slowest;\n    if (!slowest.responseTime) return current;\n    return current.responseTime > slowest.responseTime ? current : slowest;\n  }, sentimentResults[0]);\n\n  console.log(`Fastest: ${fastestEndpoint.method} ${fastestEndpoint.endpoint} (${fastestEndpoint.responseTime}ms)`);\n  console.log(`Slowest: ${slowestEndpoint.method} ${slowestEndpoint.endpoint} (${slowestEndpoint.responseTime}ms)`);\n\n  console.log('\\n' + '='.repeat(80));\n\n  if (passed === sentimentResults.length) {\n    console.log('🎉 ALL TESTS PASSED!');\n  } else if (passed > 0) {\n    console.log(`⚠️  PARTIAL SUCCESS: ${passed}/${sentimentResults.length} tests passed`);\n  } else {\n    console.log('💥 ALL TESTS FAILED');\n  }\n\n  console.log('='.repeat(80));\n}\n\n// Run tests\nrunSentimentEndpointTests().catch((error) => {\n  console.error('\\n💥 Test Suite Failed:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/integration-test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'articles' is defined but never used. Allowed unused args must match /^_/u.","line":227,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":227,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentiment Module Integration Test\n * Tests complete workflow with real RSS feed\n */\n\nimport { RSSFeedsService } from '../services/sources/rss-feeds.service';\nimport { SentimentLocalService } from '../services/analysis/sentiment-local.service';\nimport { SentimentHybridService } from '../services/analysis/sentiment-hybrid.service';\nimport { TrendingTopicsService } from '../services/analyzer/trending-topics.service';\n\nconsole.log('🧪 Starting Sentiment Module Integration Test\\n');\nconsole.log('=' .repeat(80));\n\n/**\n * Test 1: RSS Feed Parsing\n */\nasync function testRSSFeed() {\n  console.log('\\n📰 TEST 1: RSS Feed Parsing (Investing.com)');\n  console.log('-'.repeat(80));\n\n  try {\n    const rssService = new RSSFeedsService({\n      customFeeds: [\n        {\n          name: 'Investing.com',\n          url: 'https://www.investing.com/rss/news.rss',\n          source: 'custom',\n          enabled: true,\n          pollInterval: 300000,\n        },\n      ],\n    });\n\n    console.log('🔄 Fetching RSS feed...');\n    const articles = await rssService.fetchFeed('https://www.investing.com/rss/news.rss');\n\n    console.log(`✅ Successfully fetched ${articles.length} articles`);\n\n    if (articles.length > 0) {\n      console.log('\\n📋 Sample Articles:');\n      articles.slice(0, 5).forEach((article, index) => {\n        console.log(`\\n[${index + 1}] ${article.title}`);\n        console.log(`    Source: ${article.source}`);\n        console.log(`    Symbols: ${article.symbols.join(', ') || 'None detected'}`);\n        console.log(`    URL: ${article.url}`);\n        console.log(`    Published: ${article.publishedAt.toISOString()}`);\n      });\n    }\n\n    return { success: true, articles };\n  } catch (error) {\n    console.error('❌ RSS Feed Test Failed:', error instanceof Error ? error.message : String(error));\n    return { success: false, articles: [] };\n  }\n}\n\n/**\n * Test 2: Symbol Extraction\n */\nfunction testSymbolExtraction(articles: any[]) {\n  console.log('\\n\\n🔍 TEST 2: Symbol Extraction');\n  console.log('-'.repeat(80));\n\n  const symbolStats: Record<string, number> = {};\n  let articlesWithSymbols = 0;\n\n  articles.forEach((article) => {\n    if (article.symbols.length > 0) {\n      articlesWithSymbols++;\n      article.symbols.forEach((symbol: string) => {\n        symbolStats[symbol] = (symbolStats[symbol] || 0) + 1;\n      });\n    }\n  });\n\n  console.log(`📊 Articles with symbols: ${articlesWithSymbols}/${articles.length}`);\n  console.log(`📊 Unique symbols detected: ${Object.keys(symbolStats).length}`);\n\n  if (Object.keys(symbolStats).length > 0) {\n    console.log('\\n🏆 Top Symbols Mentioned:');\n    const sortedSymbols = Object.entries(symbolStats)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10);\n\n    sortedSymbols.forEach(([symbol, count], index) => {\n      console.log(`  ${index + 1}. ${symbol}: ${count} mentions`);\n    });\n  }\n\n  return { success: true, symbolStats, articlesWithSymbols };\n}\n\n/**\n * Test 3: Local Sentiment Analysis\n */\nasync function testLocalSentiment(articles: any[]) {\n  console.log('\\n\\n💭 TEST 3: Local Sentiment Analysis');\n  console.log('-'.repeat(80));\n\n  try {\n    const sentimentService = new SentimentLocalService();\n\n    const articlesToAnalyze = articles.slice(0, 10);\n    console.log(`🔄 Analyzing sentiment for ${articlesToAnalyze.length} articles...\\n`);\n\n    const results = [];\n\n    for (const article of articlesToAnalyze) {\n      const text = `${article.title} ${article.description || ''}`;\n      const analysis = await sentimentService.analyze(text);\n\n      results.push({\n        title: article.title.substring(0, 80) + '...',\n        score: analysis.score,\n        label: analysis.label,\n        confidence: analysis.confidence,\n        keywords: analysis.keywords?.slice(0, 3).map((k) => k.word),\n      });\n\n      console.log(`📝 \"${article.title.substring(0, 60)}...\"`);\n      console.log(`   Score: ${analysis.score.toFixed(2)} | Label: ${analysis.label} | Confidence: ${(analysis.confidence * 100).toFixed(1)}%`);\n      if (analysis.keywords && analysis.keywords.length > 0) {\n        console.log(`   Keywords: ${analysis.keywords.slice(0, 3).map((k) => k.word).join(', ')}`);\n      }\n      console.log();\n    }\n\n    // Statistics\n    const avgScore = results.reduce((sum, r) => sum + r.score, 0) / results.length;\n    const avgConfidence = results.reduce((sum, r) => sum + r.confidence, 0) / results.length;\n\n    const labelCounts = results.reduce((acc, r) => {\n      acc[r.label] = (acc[r.label] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    console.log('📊 Sentiment Statistics:');\n    console.log(`   Average Score: ${avgScore.toFixed(2)}`);\n    console.log(`   Average Confidence: ${(avgConfidence * 100).toFixed(1)}%`);\n    console.log('   Label Distribution:');\n    Object.entries(labelCounts).forEach(([label, count]) => {\n      console.log(`     - ${label}: ${count}`);\n    });\n\n    return { success: true, results, avgScore, avgConfidence };\n  } catch (error) {\n    console.error('❌ Sentiment Analysis Failed:', error instanceof Error ? error.message : String(error));\n    return { success: false, results: [] };\n  }\n}\n\n/**\n * Test 4: Hybrid Sentiment Analysis (with AI fallback)\n */\nasync function testHybridSentiment(articles: any[]) {\n  console.log('\\n\\n🤖 TEST 4: Hybrid Sentiment Analysis (AI + Local)');\n  console.log('-'.repeat(80));\n\n  try {\n    // Check if AI service is configured\n    const hasAnthropicKey = !!process.env.ANTHROPIC_API_KEY;\n\n    if (!hasAnthropicKey) {\n      console.log('⚠️  No ANTHROPIC_API_KEY found - will use local NLP only');\n    } else {\n      console.log('✅ ANTHROPIC_API_KEY configured - AI analysis available');\n    }\n\n    const hybridService = new SentimentHybridService({\n      confidenceThreshold: 0.7,\n      alwaysUseAI: {\n        forInfluencers: true,\n        forImportantNews: true,\n      },\n      cache: {\n        enabled: true,\n        ttl: 3600000,\n        maxSize: 1000,\n      },\n    });\n\n    const articlesToAnalyze = articles.slice(0, 5);\n    console.log(`🔄 Analyzing ${articlesToAnalyze.length} articles with hybrid approach...\\n`);\n\n    for (const article of articlesToAnalyze) {\n      const text = `${article.title} ${article.description || ''}`;\n      const analysis = await hybridService.analyze(text, {\n        context: {\n          source: article.source,\n        },\n      });\n\n      console.log(`📝 \"${article.title.substring(0, 60)}...\"`);\n      console.log(`   Provider: ${analysis.provider.toUpperCase()}`);\n      console.log(`   Score: ${analysis.score.toFixed(2)} | Label: ${analysis.label} | Confidence: ${(analysis.confidence * 100).toFixed(1)}%`);\n\n      if (analysis.aspects) {\n        const aspects = Object.entries(analysis.aspects)\n          .filter(([, value]) => value !== undefined)\n          .map(([key, value]) => `${key}:${value?.toFixed(2)}`)\n          .join(', ');\n        if (aspects) {\n          console.log(`   Aspects: ${aspects}`);\n        }\n      }\n      console.log();\n    }\n\n    // Get usage stats\n    const stats = hybridService.getUsageStats();\n    console.log('📊 Hybrid Service Statistics:');\n    console.log(`   Local analyses: ${stats.localAnalyses}`);\n    console.log(`   AI analyses: ${stats.aiAnalyses}`);\n    console.log(`   Cache hits: ${stats.cacheHits}`);\n    console.log(`   Total requests: ${stats.totalAnalyses}`);\n\n    return { success: true, stats };\n  } catch (error) {\n    console.error('❌ Hybrid Sentiment Failed:', error instanceof Error ? error.message : String(error));\n    return { success: false };\n  }\n}\n\n/**\n * Test 5: Trending Topics Detection\n */\nfunction testTrendingTopics(articles: any[]) {\n  console.log('\\n\\n🔥 TEST 5: Trending Topics Detection');\n  console.log('-'.repeat(80));\n\n  try {\n    const trendingService = new TrendingTopicsService({\n      minMentions: 2,\n      timeWindow: 86400000, // 24h\n      recencyDecay: 0.7,\n    });\n\n    // Note: TrendingTopicsService processes SocialMention objects\n    // For now we'll just check if the service is working\n    const trendingTopics = trendingService.getTrendingTopics();\n    console.log(`📊 Detected ${trendingTopics.length} trending topics\\n`);\n\n    if (trendingTopics.length > 0) {\n      console.log('🏆 Top Trending Topics:');\n      trendingTopics.slice(0, 10).forEach((topic: any, index: number) => {\n        console.log(`\\n${index + 1}. ${topic.keyword || topic.topic || 'Unknown'}`);\n        console.log(`   Mentions: ${topic.mentionCount || topic.mentions || 0}`);\n        if (topic.averageSentiment !== undefined) {\n          console.log(`   Sentiment: ${topic.averageSentiment.toFixed(2)}`);\n        }\n      });\n    } else {\n      console.log('⚠️  No trending topics detected (service needs social mentions)');\n    }\n\n    const stats = trendingService.getStats();\n    console.log('\\n📊 Trending Service Statistics:');\n    console.log(`   Total topics tracked: ${stats.totalTopics}`);\n    console.log(`   Trending topics: ${stats.trendingTopics}`);\n\n    return { success: true, trendingTopics, stats };\n  } catch (error) {\n    console.error('❌ Trending Topics Failed:', error instanceof Error ? error.message : String(error));\n    return { success: false };\n  }\n}\n\n/**\n * Main Test Runner\n */\nasync function runIntegrationTests() {\n  const startTime = Date.now();\n\n  console.log('\\n🚀 Starting Integration Tests...\\n');\n\n  // Test 1: RSS Feed\n  const rssResult = await testRSSFeed();\n  if (!rssResult.success || rssResult.articles.length === 0) {\n    console.log('\\n❌ Cannot continue without RSS data');\n    return;\n  }\n\n  // Test 2: Symbol Extraction\n  const symbolResult = testSymbolExtraction(rssResult.articles);\n\n  // Test 3: Local Sentiment\n  const localSentimentResult = await testLocalSentiment(rssResult.articles);\n\n  // Test 4: Hybrid Sentiment\n  const hybridSentimentResult = await testHybridSentiment(rssResult.articles);\n\n  // Test 5: Trending Topics\n  const trendingResult = testTrendingTopics(rssResult.articles);\n\n  // Final Summary\n  const duration = Date.now() - startTime;\n  console.log('\\n\\n' + '='.repeat(80));\n  console.log('📊 TEST SUMMARY');\n  console.log('='.repeat(80));\n  console.log(`✅ RSS Feed Parsing: ${rssResult.success ? 'PASSED' : 'FAILED'}`);\n  console.log(`✅ Symbol Extraction: ${symbolResult.success ? 'PASSED' : 'FAILED'}`);\n  console.log(`✅ Local Sentiment: ${localSentimentResult.success ? 'PASSED' : 'FAILED'}`);\n  console.log(`✅ Hybrid Sentiment: ${hybridSentimentResult.success ? 'PASSED' : 'FAILED'}`);\n  console.log(`✅ Trending Topics: ${trendingResult.success ? 'PASSED' : 'FAILED'}`);\n  console.log(`\\n⏱️  Total execution time: ${(duration / 1000).toFixed(2)}s`);\n  console.log('='.repeat(80));\n}\n\n// Run tests\nrunIntegrationTests().catch((error) => {\n  console.error('\\n💥 Integration Test Failed:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/price-correlation.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/sentiment-aggregator.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/sentiment-local.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/__tests__/trending-topics.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/routes/sentiment.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'newsArticles' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'socialMentions' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sentimentAlerts' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'priceCorrelationService' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentiment Routes\n * REST API + WebSocket endpoints for sentiment analysis\n *\n * @module sentiment/routes\n */\n\nimport { Elysia, t } from 'elysia';\nimport { db } from '@/db';\nimport { eq, and, gte, lte, desc, sql, inArray } from 'drizzle-orm';\nimport {\n  newsArticles,\n  socialMentions,\n  sentimentScores,\n  sentimentHistory,\n  sentimentAlerts,\n} from '../schema/sentiment.schema';\nimport { websocketStreamingService } from '../services/streaming/websocket-streaming.service';\nimport { hybridSentimentService } from '../services/analysis/sentiment-hybrid.service';\nimport { sentimentAggregator } from '../services/aggregator/sentiment-aggregator.service';\nimport { trendingTopicsService } from '../services/analyzer/trending-topics.service';\nimport { priceCorrelationService } from '../services/analyzer/price-correlation.service';\nimport { rssFeedsService } from '../services/sources/rss-feeds.service';\nimport { cryptoPanicService } from '../services/sources/cryptopanic.service';\nimport { twitterService } from '../services/sources/twitter.service';\nimport { redditService } from '../services/sources/reddit.service';\n\n/**\n * Helper: Parse timeframe string to milliseconds\n */\nfunction parseTimeframe(timeframe: string): number {\n  const match = timeframe.match(/^(\\d+)([mhd])$/);\n  if (!match) return 86400000; // Default 24h\n\n  const value = parseInt(match[1], 10);\n  const unit = match[2];\n\n  switch (unit) {\n    case 'm': return value * 60 * 1000; // minutes\n    case 'h': return value * 60 * 60 * 1000; // hours\n    case 'd': return value * 24 * 60 * 60 * 1000; // days\n    default: return 86400000;\n  }\n}\n\n/**\n * Helper: Calculate Pearson correlation coefficient\n */\nfunction calculatePearsonCorrelation(x: number[], y: number[]): number {\n  if (x.length !== y.length || x.length === 0) return 0;\n\n  const n = x.length;\n  const sumX = x.reduce((a, b) => a + b, 0);\n  const sumY = y.reduce((a, b) => a + b, 0);\n  const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n  const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n  const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n\n  return denominator === 0 ? 0 : numerator / denominator;\n}\n\n/**\n * Sentiment Routes Plugin\n */\nexport const sentimentRoutes = new Elysia({ prefix: '/sentiment' })\n  /**\n   * GET /sentiment/health\n   * Health check for sentiment services\n   */\n  .get('/health', async () => {\n    const health = {\n      sentiment: {\n        hybrid: await hybridSentimentService?.healthCheck() || { local: true, ai: false, cache: true },\n      },\n      sources: {\n        rss: rssFeedsService ? true : false,\n        cryptopanic: cryptoPanicService ? await cryptoPanicService.healthCheck() : false,\n        twitter: twitterService ? await twitterService.healthCheck() : false,\n        reddit: redditService ? await redditService.healthCheck() : false,\n      },\n      streaming: {\n        active: true,\n        stats: websocketStreamingService.getStats(),\n      },\n    };\n\n    return {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      services: health,\n    };\n  })\n\n  /**\n   * GET /sentiment/trending\n   * Get trending topics\n   * IMPORTANT: Must come BEFORE /:symbol to avoid conflicts\n   */\n  .get('/trending', async ({ query }) => {\n    const { limit, symbol } = query as { limit?: string; symbol?: string };\n\n    const trending = symbol\n      ? trendingTopicsService.getTrendingForSymbol(symbol.toUpperCase())\n      : trendingTopicsService.getTrendingTopics();\n\n    const limitNum = parseInt(limit || '50', 10);\n\n    return {\n      trending: trending.slice(0, limitNum),\n      total: trending.length,\n      timestamp: new Date().toISOString(),\n    };\n  })\n\n  /**\n   * GET /sentiment/news\n   * Get recent news articles\n   */\n  .get('/news', async ({ query }) => {\n    const { symbol, source, limit, filter } = query as {\n      symbol?: string;\n      source?: string;\n      limit?: string;\n      filter?: string;\n    };\n\n    try {\n      let articles: any[] = [];\n\n      // Fetch from appropriate source\n      if (source === 'cryptopanic' && cryptoPanicService) {\n        if (symbol) {\n          articles = await cryptoPanicService.fetchForCurrency(symbol.toUpperCase());\n        } else if (filter) {\n          articles = await cryptoPanicService.fetchPosts({ filter: filter as any });\n        } else {\n          articles = await cryptoPanicService.fetchRecent();\n        }\n      } else if (rssFeedsService) {\n        // Fetch from all RSS feeds\n        articles = await rssFeedsService.fetchAllFeeds();\n\n        // Filter by symbol if provided\n        if (symbol) {\n          articles = articles.filter((a) => a.symbols.includes(symbol.toUpperCase()));\n        }\n      }\n\n      const limitNum = parseInt(limit || '50', 10);\n\n      return {\n        articles: articles.slice(0, limitNum),\n        total: articles.length,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error fetching news:', error);\n      throw new Error('Failed to fetch news articles');\n    }\n  })\n\n  /**\n   * GET /sentiment/social/:platform\n   * Get social mentions from specific platform\n   */\n  .get('/social/:platform', async ({ params, query }) => {\n    const { platform } = params;\n    const { symbol, limit } = query as { symbol?: string; limit?: string };\n\n    try {\n      let mentions: any[] = [];\n\n      if (platform === 'twitter' && twitterService && symbol) {\n        mentions = await twitterService.searchCryptoTweets(symbol.toUpperCase(), {\n          maxResults: parseInt(limit || '100', 10),\n        });\n      } else if (platform === 'reddit' && redditService && symbol) {\n        mentions = await redditService.searchCrypto(symbol.toUpperCase(), {\n          limit: parseInt(limit || '100', 10),\n        });\n      }\n\n      return {\n        platform,\n        mentions,\n        total: mentions.length,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error(`Error fetching ${platform} mentions:`, error);\n      throw new Error(`Failed to fetch ${platform} mentions`);\n    }\n  }, {\n    params: t.Object({\n      platform: t.Union([t.Literal('twitter'), t.Literal('reddit')]),\n    }),\n    query: t.Object({\n      symbol: t.Optional(t.String()),\n      limit: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * POST /sentiment/analyze\n   * Analyze custom text\n   */\n  .post('/analyze', async ({ body }) => {\n    const { text, options } = body as {\n      text: string;\n      options?: {\n        forceAI?: boolean;\n        forceLocal?: boolean;\n        context?: {\n          symbol?: string;\n          author?: string;\n          source?: string;\n          isInfluencer?: boolean;\n          isImportant?: boolean;\n        };\n      };\n    };\n\n    if (!hybridSentimentService) {\n      throw new Error('Sentiment service not available');\n    }\n\n    const result = await hybridSentimentService.analyze(text, options);\n\n    return {\n      result,\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    body: t.Object({\n      text: t.String({ minLength: 1, maxLength: 5000 }),\n      options: t.Optional(t.Object({\n        forceAI: t.Optional(t.Boolean()),\n        forceLocal: t.Optional(t.Boolean()),\n        context: t.Optional(t.Object({\n          symbol: t.Optional(t.String()),\n          author: t.Optional(t.String()),\n          source: t.Optional(t.String()),\n          isInfluencer: t.Optional(t.Boolean()),\n          isImportant: t.Optional(t.Boolean()),\n        })),\n      })),\n    }),\n  })\n\n  /**\n   * POST /sentiment/analyze/batch\n   * Batch analyze multiple texts\n   */\n  .post('/analyze/batch', async ({ body }) => {\n    const { texts, options } = body as {\n      texts: Array<{ id: string; text: string }>;\n      options?: any;\n    };\n\n    if (!hybridSentimentService) {\n      throw new Error('Sentiment service not available');\n    }\n\n    const result = await hybridSentimentService.analyzeBatch({\n      texts,\n      options,\n    });\n\n    return {\n      result,\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    body: t.Object({\n      texts: t.Array(t.Object({\n        id: t.String(),\n        text: t.String({ minLength: 1, maxLength: 5000 }),\n      })),\n      options: t.Optional(t.Any()),\n    }),\n  })\n\n  /**\n   * GET /sentiment/correlation/:symbol\n   * Get sentiment-price correlation for symbol\n   */\n  .get('/correlation/:symbol', async ({ params, query }) => {\n    const { symbol } = params;\n    const { timeframe } = query as { timeframe?: string };\n\n    try {\n      const symbolUpper = symbol.toUpperCase();\n      const timeMs = parseTimeframe(timeframe || '7d');\n      const cutoffDate = new Date(Date.now() - timeMs);\n\n      // Fetch sentiment history from database\n      const history = await db\n        .select()\n        .from(sentimentHistory)\n        .where(\n          and(\n            eq(sentimentHistory.symbol, symbolUpper),\n            gte(sentimentHistory.timestamp, cutoffDate)\n          )\n        )\n        .orderBy(sentimentHistory.timestamp);\n\n      if (history.length < 2) {\n        return {\n          symbol: symbolUpper,\n          correlations: [],\n          message: 'Insufficient data for correlation analysis',\n          timestamp: new Date().toISOString(),\n        };\n      }\n\n      // Extract sentiment scores and prices (if available)\n      const sentimentScores = history\n        .filter((h) => h.score !== null)\n        .map((h) => parseFloat(h.score as any));\n\n      const prices = history\n        .filter((h) => h.price !== null)\n        .map((h) => parseFloat(h.price as any));\n\n      let correlation = null;\n\n      // Calculate correlation if we have price data\n      if (prices.length === sentimentScores.length && prices.length >= 2) {\n        const coefficient = calculatePearsonCorrelation(sentimentScores, prices);\n\n        // Simple significance test (t-test approximation)\n        const n = sentimentScores.length;\n        const tStat = coefficient * Math.sqrt((n - 2) / (1 - coefficient * coefficient));\n        const pValue = 2 * (1 - 0.5 * (1 + Math.sign(tStat) * Math.sqrt(1 - Math.exp(-2.77 * tStat * tStat / n))));\n\n        correlation = {\n          coefficient: parseFloat(coefficient.toFixed(4)),\n          pValue: parseFloat(pValue.toFixed(4)),\n          significance: pValue < 0.05 ? 'significant' : 'not_significant',\n          direction: coefficient > 0 ? 'positive' : coefficient < 0 ? 'negative' : 'none',\n          strength:\n            Math.abs(coefficient) > 0.7 ? 'strong' :\n            Math.abs(coefficient) > 0.4 ? 'moderate' : 'weak',\n          dataPoints: n,\n        };\n      }\n\n      return {\n        symbol: symbolUpper,\n        correlation,\n        timeframe: timeframe || '7d',\n        dataPoints: history.length,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error fetching correlation data:', error);\n      return {\n        symbol: symbol.toUpperCase(),\n        correlations: [],\n        error: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: new Date().toISOString(),\n      };\n    }\n  }, {\n    params: t.Object({\n      symbol: t.String(),\n    }),\n    query: t.Object({\n      timeframe: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * GET /sentiment/signals/:symbol\n   * Get trading signals based on sentiment\n   */\n  .get('/signals/:symbol', async ({ params }) => {\n    const { symbol } = params;\n\n    try {\n      const symbolUpper = symbol.toUpperCase();\n\n      // Fetch current sentiment score\n      const currentSentiment = await db\n        .select()\n        .from(sentimentScores)\n        .where(\n          and(\n            eq(sentimentScores.symbol, symbolUpper),\n            eq(sentimentScores.timeframe, '24h')\n          )\n        )\n        .limit(1);\n\n      if (currentSentiment.length === 0) {\n        return {\n          symbol: symbolUpper,\n          signal: 'HOLD',\n          confidence: 0,\n          reasoning: ['No sentiment data available'],\n          timestamp: new Date().toISOString(),\n        };\n      }\n\n      const sentiment = currentSentiment[0];\n      const score = parseFloat(sentiment.overallScore as any);\n      const totalMentions = sentiment.totalMentions || 0;\n      const trendPercentage = parseFloat(sentiment.trendPercentage as any) || 0;\n\n      // Fetch recent history for trend analysis\n      const recentHistory = await db\n        .select()\n        .from(sentimentHistory)\n        .where(\n          and(\n            eq(sentimentHistory.symbol, symbolUpper),\n            gte(sentimentHistory.timestamp, new Date(Date.now() - 3600000)) // Last 1 hour\n          )\n        )\n        .orderBy(desc(sentimentHistory.timestamp))\n        .limit(12); // 12 x 5m = 1 hour\n\n      // Calculate velocity (rate of change)\n      let velocity = 0;\n      if (recentHistory.length >= 2) {\n        const scores = recentHistory.map((h) => parseFloat(h.score as any));\n        velocity = (scores[0] - scores[scores.length - 1]) / scores.length;\n      }\n\n      // Determine signal based on score, trend, velocity, and volume\n      let signal: 'STRONG_BUY' | 'BUY' | 'HOLD' | 'SELL' | 'STRONG_SELL' = 'HOLD';\n      let confidence = 50;\n      const reasoning: string[] = [];\n\n      // Strong bullish sentiment\n      if (score > 70 && trendPercentage > 0) {\n        signal = 'STRONG_BUY';\n        confidence = 85;\n        reasoning.push(`Very positive sentiment (${score.toFixed(1)})`);\n        reasoning.push(`Improving trend (+${trendPercentage.toFixed(1)}%)`);\n      }\n      // Moderate bullish sentiment\n      else if (score > 50 && trendPercentage > 0) {\n        signal = 'BUY';\n        confidence = 70;\n        reasoning.push(`Positive sentiment (${score.toFixed(1)})`);\n        reasoning.push(`Improving trend (+${trendPercentage.toFixed(1)}%)`);\n      }\n      // Strong bearish sentiment\n      else if (score < -70 && trendPercentage < 0) {\n        signal = 'STRONG_SELL';\n        confidence = 85;\n        reasoning.push(`Very negative sentiment (${score.toFixed(1)})`);\n        reasoning.push(`Deteriorating trend (${trendPercentage.toFixed(1)}%)`);\n      }\n      // Moderate bearish sentiment\n      else if (score < -50 && trendPercentage < 0) {\n        signal = 'SELL';\n        confidence = 70;\n        reasoning.push(`Negative sentiment (${score.toFixed(1)})`);\n        reasoning.push(`Deteriorating trend (${trendPercentage.toFixed(1)}%)`);\n      }\n      // Neutral\n      else {\n        signal = 'HOLD';\n        confidence = 60;\n        reasoning.push(`Neutral sentiment (${score.toFixed(1)})`);\n      }\n\n      // Adjust confidence based on volume\n      if (totalMentions > 1000) {\n        confidence = Math.min(95, confidence + 10);\n        reasoning.push(`High volume (${totalMentions} mentions)`);\n      } else if (totalMentions < 50) {\n        confidence = Math.max(30, confidence - 15);\n        reasoning.push(`Low volume (${totalMentions} mentions)`);\n      }\n\n      // Adjust confidence based on velocity\n      if (Math.abs(velocity) > 10) {\n        confidence = Math.min(95, confidence + 5);\n        reasoning.push(`Rapid ${velocity > 0 ? 'improvement' : 'deterioration'} detected`);\n      }\n\n      return {\n        symbol: symbolUpper,\n        signal,\n        confidence,\n        reasoning,\n        metrics: {\n          sentimentScore: score,\n          trendPercentage,\n          velocity: parseFloat(velocity.toFixed(2)),\n          totalMentions,\n          fearGreedIndex: parseFloat(sentiment.fearGreedIndex as any) || null,\n        },\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error generating trading signals:', error);\n      return {\n        symbol: symbol.toUpperCase(),\n        signal: 'HOLD',\n        confidence: 0,\n        reasoning: ['Error generating signal'],\n        error: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: new Date().toISOString(),\n      };\n    }\n  }, {\n    params: t.Object({\n      symbol: t.String(),\n    }),\n  })\n\n  /**\n   * GET /sentiment/stats\n   * Get service statistics\n   */\n  .get('/stats', async () => {\n    try {\n      const sentiment = hybridSentimentService?.getUsageStats?.() || {\n        totalAnalyses: 0,\n        localAnalyses: 0,\n        aiAnalyses: 0,\n        cacheHits: 0,\n        averageTime: 0,\n      };\n\n      const trending = trendingTopicsService?.getStats?.() || {\n        topics: 0,\n        symbols: 0,\n      };\n\n      const streaming = websocketStreamingService?.getStats?.() || {\n        connections: 0,\n        subscriptions: 0,\n        messagesPerMinute: 0,\n      };\n\n      const rss = rssFeedsService?.getStats?.() || {\n        feeds: 0,\n        articles: 0,\n      };\n\n      return {\n        sentiment,\n        trending,\n        streaming,\n        rss,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error getting sentiment stats:', error);\n      // Return default stats on error\n      return {\n        sentiment: { totalAnalyses: 0, localAnalyses: 0, aiAnalyses: 0, cacheHits: 0, averageTime: 0 },\n        trending: { topics: 0, symbols: 0 },\n        streaming: { connections: 0, subscriptions: 0, messagesPerMinute: 0 },\n        rss: { feeds: 0, articles: 0 },\n        timestamp: new Date().toISOString(),\n      };\n    }\n  })\n\n  /**\n   * GET /sentiment/aggregate\n   * Get aggregated sentiment for multiple symbols\n   */\n  .get('/aggregate', async ({ query }) => {\n    const { symbols, timeframe } = query as { symbols?: string; timeframe?: string };\n\n    if (!symbols) {\n      throw new Error('symbols parameter is required');\n    }\n\n    const symbolsArray = symbols.split(',').map(s => s.trim());\n    const results = await Promise.all(\n      symbolsArray.map(async (symbol) => {\n        const sentiment = await sentimentAggregator.getAggregatedSentiment(\n          symbol,\n          timeframe || '24h'\n        );\n        return {\n          symbol: symbol.toUpperCase(),\n          ...sentiment,\n        };\n      })\n    );\n\n    return {\n      success: true,\n      data: results,\n      timeframe: timeframe || '24h',\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    query: t.Object({\n      symbols: t.String(),\n      timeframe: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * GET /sentiment/sources\n   * Get list of available sentiment sources\n   */\n  .get('/sources', async () => {\n    const sources = [\n      {\n        id: 'local',\n        name: 'Local VADER',\n        type: 'local',\n        available: true,\n        latency: 5,\n      },\n      {\n        id: 'cryptopanic',\n        name: 'CryptoPanic API',\n        type: 'news',\n        available: await cryptoPanicService?.healthCheck() || false,\n        latency: 200,\n      },\n      {\n        id: 'twitter',\n        name: 'Twitter/X API',\n        type: 'social',\n        available: await twitterService?.healthCheck() || false,\n        latency: 500,\n      },\n      {\n        id: 'reddit',\n        name: 'Reddit API',\n        type: 'social',\n        available: await redditService?.healthCheck() || false,\n        latency: 300,\n      },\n      {\n        id: 'rss',\n        name: 'RSS Feeds',\n        type: 'news',\n        available: rssFeedsService ? true : false,\n        latency: 100,\n      },\n    ];\n\n    return {\n      success: true,\n      data: sources,\n      timestamp: new Date().toISOString(),\n    };\n  })\n\n  /**\n   * POST /sentiment/multi-source\n   * Analyze sentiment from multiple sources\n   */\n  .post('/multi-source', async ({ body }) => {\n    const { symbol, sources, timeframe } = body as {\n      symbol: string;\n      sources?: string[];\n      timeframe?: string;\n    };\n\n    const result = await sentimentAggregator.analyzeMultiSource(\n      symbol,\n      sources || ['local'],\n      timeframe || '24h'\n    );\n\n    return {\n      success: true,\n      data: result,\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    body: t.Object({\n      symbol: t.String(),\n      sources: t.Optional(t.Array(t.String())),\n      timeframe: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * POST /sentiment/batch\n   * Batch analyze sentiment for multiple symbols\n   */\n  .post('/batch', async ({ body }) => {\n    const { symbols, options } = body as {\n      symbols: string[];\n      options?: {\n        timeframe?: string;\n        sources?: string[];\n      };\n    };\n\n    const results = await Promise.all(\n      symbols.map(async (symbol) => {\n        try {\n          const sentiment = await sentimentAggregator.getAggregatedSentiment(\n            symbol,\n            options?.timeframe || '24h'\n          );\n          return {\n            symbol: symbol.toUpperCase(),\n            status: 'success',\n            data: sentiment,\n          };\n        } catch (error) {\n          return {\n            symbol: symbol.toUpperCase(),\n            status: 'error',\n            error: error instanceof Error ? error.message : 'Unknown error',\n          };\n        }\n      })\n    );\n\n    return {\n      success: true,\n      data: results,\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    body: t.Object({\n      symbols: t.Array(t.String()),\n      options: t.Optional(t.Object({\n        timeframe: t.Optional(t.String()),\n        sources: t.Optional(t.Array(t.String())),\n      })),\n    }),\n  })\n\n  /**\n   * GET /sentiment/:symbol\n   * Get aggregated sentiment for a symbol\n   * (Must be LAST to avoid path conflicts with specific routes)\n   */\n  .get('/:symbol', async ({ params, query }) => {\n    const { symbol } = params;\n    const { timeWindow } = query as { timeWindow?: string };\n\n    try {\n      const symbolUpper = symbol.toUpperCase();\n      const timeframe = timeWindow || '24h';\n\n      // Fetch current sentiment score from database\n      const currentSentiment = await db\n        .select()\n        .from(sentimentScores)\n        .where(\n          and(\n            eq(sentimentScores.symbol, symbolUpper),\n            eq(sentimentScores.timeframe, timeframe)\n          )\n        )\n        .limit(1);\n\n      if (currentSentiment.length === 0) {\n        // Return default neutral sentiment if no data\n        return {\n          symbol: symbolUpper,\n          score: 0,\n          magnitude: 0,\n          label: 'neutral' as const,\n          confidence: 0.5,\n          trend: {\n            direction: 'stable' as const,\n            strength: 0,\n            velocity: 0,\n          },\n          volume: 0,\n          change: 0,\n          sourceBreakdown: {\n            news: { score: 0, count: 0 },\n            social: { score: 0, count: 0 },\n          },\n          timeWindow: parseTimeframe(timeframe),\n          dataPoints: 0,\n          lastUpdated: new Date(),\n        };\n      }\n\n      const sentiment = currentSentiment[0];\n\n      // Calculate velocity from recent history\n      const recentHistory = await db\n        .select()\n        .from(sentimentHistory)\n        .where(\n          and(\n            eq(sentimentHistory.symbol, symbolUpper),\n            gte(sentimentHistory.timestamp, new Date(Date.now() - 3600000)) // Last hour\n          )\n        )\n        .orderBy(desc(sentimentHistory.timestamp))\n        .limit(12);\n\n      let velocity = 0;\n      if (recentHistory.length >= 2) {\n        const scores = recentHistory.map((h) => parseFloat(h.score as any));\n        velocity = (scores[0] - scores[scores.length - 1]) / scores.length;\n      }\n\n      // Determine trend strength\n      const trendPercentage = parseFloat(sentiment.trendPercentage as any) || 0;\n      const trendStrength = Math.min(1, Math.abs(trendPercentage) / 50); // Normalize to 0-1\n\n      return {\n        symbol: symbolUpper,\n        score: parseFloat(sentiment.overallScore as any),\n        magnitude: parseFloat(sentiment.overallMagnitude as any),\n        label: sentiment.overallLabel as any,\n        confidence: parseFloat(sentiment.confidence as any) || 0.5,\n        trend: {\n          direction: sentiment.trend as any,\n          strength: parseFloat(trendStrength.toFixed(2)),\n          velocity: parseFloat(velocity.toFixed(2)),\n        },\n        volume: sentiment.totalMentions || 0,\n        change: trendPercentage,\n        sourceBreakdown: {\n          news: {\n            score: parseFloat(sentiment.newsScore as any) || 0,\n            count: sentiment.newsMentions || 0,\n          },\n          social: {\n            score: parseFloat(sentiment.socialScore as any) || 0,\n            count: sentiment.socialMentions || 0,\n          },\n        },\n        fearGreed: {\n          index: parseFloat(sentiment.fearGreedIndex as any) || 50,\n          label: sentiment.fearGreedLabel,\n        },\n        timeWindow: parseTimeframe(timeframe),\n        dataPoints: sentiment.totalMentions || 0,\n        lastUpdated: sentiment.updatedAt,\n      };\n    } catch (error) {\n      console.error('Error fetching sentiment:', error);\n      // Return default on error\n      return {\n        symbol: symbol.toUpperCase(),\n        score: 0,\n        magnitude: 0,\n        label: 'neutral' as const,\n        confidence: 0.5,\n        trend: {\n          direction: 'stable' as const,\n          strength: 0,\n          velocity: 0,\n        },\n        volume: 0,\n        change: 0,\n        sourceBreakdown: {},\n        timeWindow: parseTimeframe(timeWindow || '24h'),\n        dataPoints: 0,\n        lastUpdated: new Date(),\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }, {\n    params: t.Object({\n      symbol: t.String(),\n    }),\n    query: t.Object({\n      timeWindow: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * WebSocket /sentiment/stream\n   * Real-time sentiment updates\n   */\n  .ws('/stream', {\n    open(ws) {\n      const clientId = crypto.randomUUID();\n      const metadata = {\n        ip: ws.data?.headers?.['x-forwarded-for'] || 'unknown',\n        userAgent: ws.data?.headers?.['user-agent'] || 'unknown',\n      };\n\n      // Store client ID in ws context\n      (ws as any).clientId = clientId;\n\n      websocketStreamingService.onConnect(ws, clientId, metadata);\n    },\n\n    message(ws, message) {\n      const clientId = (ws as any).clientId;\n\n      if (!clientId) {\n        console.error('[WebSocket] Client ID not found');\n        return;\n      }\n\n      try {\n        const parsedMessage = typeof message === 'string' ? JSON.parse(message) : message;\n        websocketStreamingService.onMessage(clientId, parsedMessage);\n      } catch (error) {\n        console.error('[WebSocket] Error parsing message:', error);\n        ws.send(JSON.stringify({\n          type: 'error',\n          data: { message: 'Invalid message format' },\n          timestamp: Date.now(),\n        }));\n      }\n    },\n\n    close(ws) {\n      const clientId = (ws as any).clientId;\n\n      if (clientId) {\n        websocketStreamingService.onDisconnect(clientId);\n      }\n    },\n\n    error(ws: any) {\n      console.error('[WebSocket] Connection error');\n      const clientId = (ws as any).clientId;\n\n      if (clientId) {\n        websocketStreamingService.onDisconnect(clientId);\n      }\n    },\n  })\n\n  /**\n   * GET /sentiment/aggregate\n   * Aggregate sentiment across multiple symbols\n   */\n  .get('/aggregate', async ({ query }) => {\n    const symbols = query.symbols?.split(',') || [];\n    const timeframe = query.timeframe || '24h';\n\n    if (symbols.length === 0) {\n      return {\n        success: false,\n        error: 'At least one symbol required',\n      };\n    }\n\n    const results = await Promise.all(\n      symbols.map(async (symbol) => {\n        const sentiment = await sentimentAggregator.getAggregatedSentiment(\n          symbol.trim(),\n          timeframe\n        );\n        return { symbol: symbol.trim(), ...sentiment };\n      })\n    );\n\n    return {\n      success: true,\n      data: results,\n      timeframe,\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    query: t.Object({\n      symbols: t.String(),\n      timeframe: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * GET /sentiment/sources\n   * List available sentiment sources\n   */\n  .get('/sources', async () => {\n    const sources = [\n      {\n        id: 'local',\n        name: 'Local VADER Analysis',\n        type: 'analysis',\n        enabled: true,\n        cost: 'free',\n        speed: 'fast',\n        accuracy: 'good',\n      },\n      {\n        id: 'ai',\n        name: 'AI-Powered Analysis',\n        type: 'analysis',\n        enabled: Boolean(process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY),\n        cost: 'paid',\n        speed: 'medium',\n        accuracy: 'excellent',\n      },\n      {\n        id: 'rss',\n        name: 'RSS News Feeds',\n        type: 'source',\n        enabled: true,\n        cost: 'free',\n        speed: 'fast',\n        accuracy: 'good',\n      },\n      {\n        id: 'cryptopanic',\n        name: 'CryptoPanic',\n        type: 'source',\n        enabled: Boolean(process.env.CRYPTOPANIC_API_KEY),\n        cost: 'free/paid',\n        speed: 'fast',\n        accuracy: 'good',\n      },\n      {\n        id: 'twitter',\n        name: 'Twitter/X',\n        type: 'source',\n        enabled: Boolean(process.env.TWITTER_API_KEY),\n        cost: 'paid',\n        speed: 'fast',\n        accuracy: 'excellent',\n      },\n      {\n        id: 'reddit',\n        name: 'Reddit',\n        type: 'source',\n        enabled: Boolean(process.env.REDDIT_CLIENT_ID),\n        cost: 'free',\n        speed: 'medium',\n        accuracy: 'good',\n      },\n    ];\n\n    return {\n      success: true,\n      data: sources,\n      timestamp: new Date().toISOString(),\n    };\n  })\n\n  /**\n   * POST /sentiment/multi-source\n   * Analyze sentiment from multiple sources\n   */\n  .post('/multi-source', async ({ body }) => {\n    const { symbol, sources, timeframe } = body;\n\n    const results = await sentimentAggregator.analyzeMultiSource(\n      symbol,\n      sources || ['local', 'rss'],\n      timeframe || '24h'\n    );\n\n    return {\n      success: true,\n      data: results,\n      symbol,\n      sources: sources || ['local', 'rss'],\n      timeframe: timeframe || '24h',\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    body: t.Object({\n      symbol: t.String(),\n      sources: t.Optional(t.Array(t.String())),\n      timeframe: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * POST /sentiment/correlation\n   * Calculate sentiment-price correlation\n   */\n  .post('/correlation', async ({ body }) => {\n    const { symbol, timeframe } = body;\n\n    try {\n      const symbolUpper = symbol.toUpperCase();\n      const timeMs = parseTimeframe(timeframe || '7d');\n      const cutoffDate = new Date(Date.now() - timeMs);\n\n      // Fetch sentiment history from database\n      const history = await db\n        .select()\n        .from(sentimentHistory)\n        .where(\n          and(\n            eq(sentimentHistory.symbol, symbolUpper),\n            gte(sentimentHistory.timestamp, cutoffDate)\n          )\n        )\n        .orderBy(sentimentHistory.timestamp);\n\n      if (history.length < 2) {\n        return {\n          success: false,\n          message: 'Insufficient data for correlation analysis',\n          symbol: symbolUpper,\n          timeframe: timeframe || '7d',\n          timestamp: new Date().toISOString(),\n        };\n      }\n\n      // Extract sentiment scores and prices (if available)\n      const sentimentScores = history\n        .filter((h) => h.score !== null)\n        .map((h) => parseFloat(h.score as any));\n\n      const prices = history\n        .filter((h) => h.price !== null)\n        .map((h) => parseFloat(h.price as any));\n\n      if (prices.length !== sentimentScores.length || prices.length < 2) {\n        return {\n          success: false,\n          message: 'Insufficient price data for correlation analysis',\n          symbol: symbolUpper,\n          timeframe: timeframe || '7d',\n          timestamp: new Date().toISOString(),\n        };\n      }\n\n      // Calculate Pearson correlation\n      const coefficient = calculatePearsonCorrelation(sentimentScores, prices);\n\n      // Calculate significance (t-test approximation)\n      const n = sentimentScores.length;\n      const tStat = coefficient * Math.sqrt((n - 2) / (1 - coefficient * coefficient));\n      const pValue = 2 * (1 - 0.5 * (1 + Math.sign(tStat) * Math.sqrt(1 - Math.exp(-2.77 * tStat * tStat / n))));\n\n      // Determine correlation strength and direction\n      const isSignificant = pValue < 0.05;\n      const strength: 'weak' | 'moderate' | 'strong' =\n        Math.abs(coefficient) > 0.7 ? 'strong' :\n        Math.abs(coefficient) > 0.4 ? 'moderate' : 'weak';\n      const direction: 'positive' | 'negative' | 'none' =\n        coefficient > 0.1 ? 'positive' :\n        coefficient < -0.1 ? 'negative' : 'none';\n\n      // Calculate lag (simple: check if sentiment leads or lags price)\n      let lag = 0;\n      if (sentimentScores.length >= 3) {\n        // Check correlation at different lags\n        const lagScores = sentimentScores.slice(0, -1);\n        const lagPrices = prices.slice(1);\n        const lagCoeff = calculatePearsonCorrelation(lagScores, lagPrices);\n\n        if (Math.abs(lagCoeff) > Math.abs(coefficient)) {\n          lag = 1; // Sentiment leads price\n        }\n      }\n\n      const correlationData = {\n        symbol: symbolUpper,\n        coefficient: parseFloat(coefficient.toFixed(4)),\n        pValue: parseFloat(pValue.toFixed(4)),\n        isSignificant,\n        strength,\n        direction,\n        lag,\n        dataPoints: n,\n        timeframe: timeframe || '7d',\n        calculatedAt: new Date(),\n      };\n\n      return {\n        success: true,\n        data: correlationData,\n        symbol: symbolUpper,\n        timeframe: timeframe || '7d',\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error calculating correlation:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        symbol: symbol.toUpperCase(),\n        timeframe: timeframe || '7d',\n        timestamp: new Date().toISOString(),\n      };\n    }\n  }, {\n    body: t.Object({\n      symbol: t.String(),\n      timeframe: t.Optional(t.String()),\n    }),\n  })\n\n  /**\n   * POST /sentiment/batch\n   * Batch analyze multiple texts\n   */\n  .post('/batch', async ({ body }) => {\n    const { texts } = body;\n\n    if (!Array.isArray(texts) || texts.length === 0) {\n      return {\n        success: false,\n        error: 'texts array required',\n      };\n    }\n\n    const results = await Promise.all(\n      texts.map(async (text) => {\n        const sentiment = await hybridSentimentService.analyzeSentiment(text, 'en');\n        return {\n          text,\n          ...sentiment,\n        };\n      })\n    );\n\n    return {\n      success: true,\n      data: results,\n      count: results.length,\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    body: t.Object({\n      texts: t.Array(t.String()),\n    }),\n  })\n\n  /**\n   * GET /sentiment/:symbol\n   * Get aggregated sentiment for a symbol\n   * IMPORTANT: Must be LAST to avoid conflicts with specific routes\n   */\n  .get('/:symbol', async ({ params, query }) => {\n    const { symbol } = params;\n    const { timeWindow } = query as { timeWindow?: string };\n\n    // Get aggregated sentiment from all sources\n    const sentiment = await sentimentAggregator.getAggregatedSentiment(\n      symbol.toUpperCase(),\n      timeWindow || '24h'\n    );\n\n    return {\n      success: true,\n      data: sentiment,\n      symbol: symbol.toUpperCase(),\n      timeWindow: timeWindow || '24h',\n      timestamp: new Date().toISOString(),\n    };\n  }, {\n    params: t.Object({\n      symbol: t.String(),\n    }),\n    query: t.Object({\n      timeWindow: t.Optional(t.String()),\n    }),\n  });\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/schema/sentiment.schema.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'bigint' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentiment Analysis Schema\n * TimescaleDB hypertables for news, social media, and sentiment data\n *\n * @module sentiment/schema\n */\n\nimport {\n  pgTable,\n  uuid,\n  varchar,\n  text,\n  timestamp,\n  numeric,\n  integer,\n  bigint,\n  jsonb,\n  boolean,\n  index,\n  primaryKey,\n  unique,\n} from 'drizzle-orm/pg-core';\n\n// ============================================================================\n// NEWS ARTICLES (Hypertable)\n// ============================================================================\n\n/**\n * News Articles\n * Stores articles from various sources (CryptoPanic, RSS, etc.)\n */\nexport const newsArticles = pgTable(\n  'news_articles',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    source: varchar('source', { length: 50 }).notNull(), // cryptopanic, rss_coindesk, etc.\n    sourceUrl: varchar('source_url', { length: 500 }).notNull(),\n    platformId: varchar('platform_id', { length: 200 }), // External ID from source\n\n    // Content\n    title: varchar('title', { length: 500 }).notNull(),\n    content: text('content'),\n    summary: text('summary'),\n    author: varchar('author', { length: 200 }),\n    url: varchar('url', { length: 1000 }).notNull(),\n    imageUrl: varchar('image_url', { length: 1000 }),\n    category: varchar('category', { length: 50 }),\n    language: varchar('language', { length: 10 }),\n\n    // Timestamps\n    publishedAt: timestamp('published_at', { withTimezone: true }).notNull(),\n    fetchedAt: timestamp('fetched_at', { withTimezone: true }).notNull(),\n\n    // Symbols/coins mentioned\n    symbols: jsonb('symbols').$type<string[]>().notNull(), // ['BTC', 'ETH', ...]\n\n    // Sentiment analysis results\n    sentimentScore: numeric('sentiment_score', { precision: 5, scale: 2 }), // -100 to 100\n    sentimentMagnitude: numeric('sentiment_magnitude', { precision: 3, scale: 2 }), // 0 to 1\n    sentimentLabel: varchar('sentiment_label', { length: 20 }), // very_negative, negative, neutral, positive, very_positive\n    sentimentProvider: varchar('sentiment_provider', { length: 20 }), // ai, local, hybrid\n    sentimentConfidence: numeric('sentiment_confidence', { precision: 3, scale: 2 }), // 0 to 1\n\n    // Metrics\n    votes: integer('votes').default(0),\n    views: integer('views').default(0),\n\n    // Flags\n    isAnalyzed: boolean('is_analyzed').notNull().default(false),\n    isImportant: boolean('is_important').default(false),\n    isTrending: boolean('is_trending').default(false),\n\n    // Metadata\n    metadata: jsonb('metadata'), // Additional source-specific data\n\n    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),\n    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    publishedAtIdx: index('news_published_at_idx').on(table.publishedAt),\n    sourceIdx: index('news_source_idx').on(table.source),\n    symbolsIdx: index('news_symbols_idx').using('gin', table.symbols),\n    categoryIdx: index('news_category_idx').on(table.category),\n    sentimentIdx: index('news_sentiment_idx').on(table.sentimentScore),\n    importantIdx: index('news_important_idx').on(table.isImportant),\n    trendingIdx: index('news_trending_idx').on(table.isTrending),\n    analyzedIdx: index('news_analyzed_idx').on(table.isAnalyzed),\n    urlUnique: unique('news_url_unique').on(table.url),\n  })\n);\n\n// ============================================================================\n// SOCIAL MENTIONS (Hypertable)\n// ============================================================================\n\n/**\n * Social Media Mentions\n * Stores mentions from Twitter, Reddit, etc.\n */\nexport const socialMentions = pgTable(\n  'social_mentions',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    platform: varchar('platform', { length: 20 }).notNull(), // twitter, reddit, telegram, discord\n    platformId: varchar('platform_id', { length: 200 }).notNull(), // Tweet ID, Reddit post ID, etc.\n\n    // Author\n    author: varchar('author', { length: 200 }).notNull(),\n    authorId: varchar('author_id', { length: 200 }).notNull(),\n    authorFollowers: integer('author_followers'),\n    authorVerified: boolean('author_verified').default(false),\n\n    // Content\n    text: text('text').notNull(),\n    url: varchar('url', { length: 1000 }).notNull(),\n    language: varchar('language', { length: 10 }),\n\n    // Engagement metrics\n    likes: integer('likes').default(0),\n    retweets: integer('retweets').default(0), // Twitter\n    replies: integer('replies').default(0),\n    views: integer('views').default(0),\n    upvotes: integer('upvotes').default(0), // Reddit\n    downvotes: integer('downvotes').default(0), // Reddit\n    score: integer('score').default(0), // Reddit score\n\n    // Timestamps\n    createdAt: timestamp('created_at', { withTimezone: true }).notNull(), // Original post time\n    fetchedAt: timestamp('fetched_at', { withTimezone: true }).notNull(),\n\n    // Symbols/hashtags mentioned\n    symbols: jsonb('symbols').$type<string[]>().notNull(), // ['BTC', 'ETH', ...]\n    hashtags: jsonb('hashtags').$type<string[]>(), // ['#bitcoin', '#crypto', ...]\n    mentions: jsonb('mentions').$type<string[]>(), // ['@elonmusk', ...]\n\n    // Sentiment analysis\n    sentimentScore: numeric('sentiment_score', { precision: 5, scale: 2 }), // -100 to 100\n    sentimentLabel: varchar('sentiment_label', { length: 20 }),\n    sentimentProvider: varchar('sentiment_provider', { length: 20 }),\n\n    // Flags\n    isAnalyzed: boolean('is_analyzed').notNull().default(false),\n    isInfluencer: boolean('is_influencer').default(false), // >10k followers\n    isRetweet: boolean('is_retweet').default(false),\n    isReply: boolean('is_reply').default(false),\n\n    // Metadata (platform-specific)\n    metadata: jsonb('metadata'),\n\n    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    createdAtIdx: index('social_created_at_idx').on(table.createdAt),\n    platformIdx: index('social_platform_idx').on(table.platform),\n    authorIdx: index('social_author_idx').on(table.author),\n    symbolsIdx: index('social_symbols_idx').using('gin', table.symbols),\n    hashtagsIdx: index('social_hashtags_idx').using('gin', table.hashtags),\n    sentimentIdx: index('social_sentiment_idx').on(table.sentimentScore),\n    influencerIdx: index('social_influencer_idx').on(table.isInfluencer),\n    platformIdUnique: unique('social_platform_id_unique').on(table.platform, table.platformId),\n  })\n);\n\n// ============================================================================\n// SENTIMENT SCORES (Regular Table - Frequently Updated)\n// ============================================================================\n\n/**\n * Aggregated Sentiment Scores\n * Current sentiment score for each symbol\n */\nexport const sentimentScores = pgTable(\n  'sentiment_scores',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    symbol: varchar('symbol', { length: 20 }).notNull(),\n    timeframe: varchar('timeframe', { length: 10 }).notNull(), // 5m, 15m, 1h, 4h, 24h, 7d, 30d\n\n    // Overall sentiment\n    overallScore: numeric('overall_score', { precision: 5, scale: 2 }).notNull(), // -100 to 100\n    overallMagnitude: numeric('overall_magnitude', { precision: 3, scale: 2 }).notNull(), // 0 to 1\n    overallLabel: varchar('overall_label', { length: 20 }).notNull(),\n\n    // Source breakdown\n    newsScore: numeric('news_score', { precision: 5, scale: 2 }),\n    socialScore: numeric('social_score', { precision: 5, scale: 2 }),\n\n    // Volume metrics\n    totalMentions: integer('total_mentions').notNull().default(0),\n    newsMentions: integer('news_mentions').notNull().default(0),\n    socialMentions: integer('social_mentions').notNull().default(0),\n\n    // Trend\n    trend: varchar('trend', { length: 20 }).notNull(), // improving, stable, deteriorating\n    trendPercentage: numeric('trend_percentage', { precision: 6, scale: 2 }), // % change\n\n    // Fear & Greed Index\n    fearGreedIndex: numeric('fear_greed_index', { precision: 5, scale: 2 }), // 0 to 100\n    fearGreedLabel: varchar('fear_greed_label', { length: 20 }), // extreme_fear, fear, neutral, greed, extreme_greed\n\n    // Confidence\n    confidence: numeric('confidence', { precision: 3, scale: 2 }), // 0 to 1\n\n    // Timestamps\n    calculatedAt: timestamp('calculated_at', { withTimezone: true }).notNull(),\n    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    symbolTimeframeUnique: unique('sentiment_symbol_timeframe_unique').on(table.symbol, table.timeframe),\n    symbolIdx: index('sentiment_symbol_idx').on(table.symbol),\n    timeframeIdx: index('sentiment_timeframe_idx').on(table.timeframe),\n    scoreIdx: index('sentiment_score_idx').on(table.overallScore),\n    calculatedAtIdx: index('sentiment_calculated_at_idx').on(table.calculatedAt),\n  })\n);\n\n// ============================================================================\n// SENTIMENT HISTORY (Hypertable)\n// ============================================================================\n\n/**\n * Sentiment History\n * Time-series history of sentiment scores\n */\nexport const sentimentHistory = pgTable(\n  'sentiment_history',\n  {\n    id: uuid('id').defaultRandom().notNull(),\n    symbol: varchar('symbol', { length: 20 }).notNull(),\n    timestamp: timestamp('timestamp', { withTimezone: true }).notNull(),\n    timeframe: varchar('timeframe', { length: 10 }).notNull(), // 5m, 15m, 1h, 4h, 24h\n\n    // Sentiment metrics\n    score: numeric('score', { precision: 5, scale: 2 }).notNull(),\n    magnitude: numeric('magnitude', { precision: 3, scale: 2 }).notNull(),\n    label: varchar('label', { length: 20 }).notNull(),\n\n    // Volume\n    mentions: integer('mentions').notNull().default(0),\n    newsCount: integer('news_count').notNull().default(0),\n    socialCount: integer('social_count').notNull().default(0),\n\n    // Fear & Greed\n    fearGreedIndex: numeric('fear_greed_index', { precision: 5, scale: 2 }),\n\n    // Price correlation (optional)\n    price: numeric('price', { precision: 20, scale: 8 }),\n    priceChange24h: numeric('price_change_24h', { precision: 6, scale: 2 }),\n\n    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    pk: primaryKey({ columns: [table.timestamp, table.symbol, table.timeframe] }),\n    timestampIdx: index('sentiment_history_timestamp_idx').on(table.timestamp),\n    symbolIdx: index('sentiment_history_symbol_idx').on(table.symbol),\n    timeframeIdx: index('sentiment_history_timeframe_idx').on(table.timeframe),\n    scoreIdx: index('sentiment_history_score_idx').on(table.score),\n  })\n);\n\n// ============================================================================\n// TRENDING TOPICS\n// ============================================================================\n\n/**\n * Trending Topics\n * Hashtags, keywords, and topics currently trending\n */\nexport const trendingTopics = pgTable(\n  'trending_topics',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    keyword: varchar('keyword', { length: 200 }).notNull(),\n    type: varchar('type', { length: 20 }).notNull(), // hashtag, cashtag, keyword\n    symbol: varchar('symbol', { length: 20 }),\n\n    // Volume metrics\n    mentionCount: integer('mention_count').notNull().default(0),\n    mentionGrowth: numeric('mention_growth', { precision: 6, scale: 2 }), // % growth\n\n    // Sentiment\n    averageSentiment: numeric('average_sentiment', { precision: 5, scale: 2 }),\n    sentimentTrend: varchar('sentiment_trend', { length: 20 }), // improving, stable, deteriorating\n\n    // Platform breakdown\n    platforms: jsonb('platforms').$type<Array<{ platform: string; count: number }>>(),\n\n    // Timeframe\n    period: varchar('period', { length: 10 }).notNull(), // 1h, 4h, 24h\n    timestamp: timestamp('timestamp', { withTimezone: true }).notNull(),\n\n    // Top posts (IDs)\n    topPosts: jsonb('top_posts').$type<string[]>(),\n\n    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),\n    updatedAt: timestamp('updated_at', { withTimezone: true}).defaultNow().notNull(),\n  },\n  (table) => ({\n    keywordPeriodUnique: unique('trending_keyword_period_unique').on(table.keyword, table.period, table.timestamp),\n    keywordIdx: index('trending_keyword_idx').on(table.keyword),\n    symbolIdx: index('trending_symbol_idx').on(table.symbol),\n    periodIdx: index('trending_period_idx').on(table.period),\n    timestampIdx: index('trending_timestamp_idx').on(table.timestamp),\n    mentionCountIdx: index('trending_mention_count_idx').on(table.mentionCount),\n  })\n);\n\n// ============================================================================\n// SENTIMENT ALERTS\n// ============================================================================\n\n/**\n * Sentiment Alerts\n * User-configured alerts for sentiment changes\n */\nexport const sentimentAlerts = pgTable(\n  'sentiment_alerts',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    userId: uuid('user_id').notNull(),\n    tenantId: uuid('tenant_id').notNull(),\n    symbol: varchar('symbol', { length: 20 }).notNull(),\n    name: varchar('name', { length: 200 }).notNull(),\n    enabled: boolean('enabled').notNull().default(true),\n\n    // Trigger conditions\n    conditionType: varchar('condition_type', { length: 50 }).notNull(), // score_above, score_below, rapid_change, volume_spike\n    conditionThreshold: numeric('condition_threshold', { precision: 10, scale: 2 }).notNull(),\n    conditionTimeframe: varchar('condition_timeframe', { length: 10 }).notNull(), // 5m, 15m, 1h, 4h\n\n    // Notification settings\n    webhookUrl: varchar('webhook_url', { length: 500 }),\n    email: varchar('email', { length: 200 }),\n    telegram: varchar('telegram', { length: 200 }),\n\n    // Cooldown to avoid spam\n    cooldownMinutes: integer('cooldown_minutes').notNull().default(60),\n    lastTriggered: timestamp('last_triggered', { withTimezone: true }),\n\n    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),\n    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    userIdx: index('alerts_user_idx').on(table.userId),\n    tenantIdx: index('alerts_tenant_idx').on(table.tenantId),\n    symbolIdx: index('alerts_symbol_idx').on(table.symbol),\n    enabledIdx: index('alerts_enabled_idx').on(table.enabled),\n  })\n);\n\n// ============================================================================\n// INFLUENCERS\n// ============================================================================\n\n/**\n * Crypto Influencers\n * Track influential accounts across platforms\n */\nexport const influencers = pgTable(\n  'influencers',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    platform: varchar('platform', { length: 20 }).notNull(), // twitter, reddit, telegram\n    username: varchar('username', { length: 200 }).notNull(),\n    userId: varchar('user_id', { length: 200 }).notNull(),\n    displayName: varchar('display_name', { length: 200 }),\n    bio: text('bio'),\n    profileImage: varchar('profile_image', { length: 500 }),\n\n    // Stats\n    followers: integer('followers').notNull(),\n    following: integer('following'),\n    totalPosts: integer('total_posts'),\n\n    // Verification\n    isVerified: boolean('is_verified').default(false),\n    verifiedAt: timestamp('verified_at', { withTimezone: true }),\n\n    // Crypto relevance\n    cryptoRelevance: numeric('crypto_relevance', { precision: 3, scale: 2 }), // 0 to 1\n    primaryTopics: jsonb('primary_topics').$type<string[]>(),\n\n    // Tracking\n    isTracked: boolean('is_tracked').notNull().default(true),\n    lastPostAt: timestamp('last_post_at', { withTimezone: true }),\n\n    // Metadata\n    metadata: jsonb('metadata'),\n\n    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),\n    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    platformUserUnique: unique('influencers_platform_user_unique').on(table.platform, table.userId),\n    platformIdx: index('influencers_platform_idx').on(table.platform),\n    followersIdx: index('influencers_followers_idx').on(table.followers),\n    verifiedIdx: index('influencers_verified_idx').on(table.isVerified),\n    trackedIdx: index('influencers_tracked_idx').on(table.isTracked),\n  })\n);\n\n// ============================================================================\n// RSS FEED CONFIGURATIONS\n// ============================================================================\n\n/**\n * RSS Feed Configurations\n * Configure RSS feeds for news aggregation\n */\nexport const rssFeedConfigs = pgTable(\n  'rss_feed_configs',\n  {\n    id: uuid('id').defaultRandom().primaryKey(),\n    name: varchar('name', { length: 200 }).notNull(),\n    url: varchar('url', { length: 1000 }).notNull(),\n    source: varchar('source', { length: 50 }).notNull(), // rss_coindesk, rss_cointelegraph, etc.\n    category: varchar('category', { length: 50 }),\n    enabled: boolean('enabled').notNull().default(true),\n    pollInterval: integer('poll_interval').notNull().default(300000), // ms (5 min default)\n    lastFetch: timestamp('last_fetch', { withTimezone: true }),\n    lastError: text('last_error'),\n\n    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),\n    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),\n  },\n  (table) => ({\n    urlUnique: unique('rss_url_unique').on(table.url),\n    sourceIdx: index('rss_source_idx').on(table.source),\n    enabledIdx: index('rss_enabled_idx').on(table.enabled),\n  })\n);\n\n/**\n * TimescaleDB SQL Migration\n *\n * Run these commands after creating the tables:\n *\n * -- Convert to hypertables\n * SELECT create_hypertable('news_articles', 'published_at', if_not_exists => TRUE);\n * SELECT create_hypertable('social_mentions', 'created_at', if_not_exists => TRUE);\n * SELECT create_hypertable('sentiment_history', 'timestamp', if_not_exists => TRUE);\n *\n * -- Create retention policies (keep data for 90 days)\n * SELECT add_retention_policy('news_articles', INTERVAL '90 days');\n * SELECT add_retention_policy('social_mentions', INTERVAL '90 days');\n * SELECT add_retention_policy('sentiment_history', INTERVAL '365 days');\n *\n * -- Create continuous aggregate for hourly sentiment\n * CREATE MATERIALIZED VIEW sentiment_history_1h\n * WITH (timescaledb.continuous) AS\n * SELECT\n *   time_bucket('1 hour', timestamp) AS bucket,\n *   symbol,\n *   timeframe,\n *   AVG(score) AS avg_score,\n *   AVG(magnitude) AS avg_magnitude,\n *   SUM(mentions) AS total_mentions,\n *   AVG(fear_greed_index) AS avg_fear_greed\n * FROM sentiment_history\n * WHERE timeframe = '5m'\n * GROUP BY bucket, symbol, timeframe;\n *\n * -- Add refresh policy\n * SELECT add_continuous_aggregate_policy('sentiment_history_1h',\n *   start_offset => INTERVAL '2 hours',\n *   end_offset => INTERVAL '5 minutes',\n *   schedule_interval => INTERVAL '5 minutes');\n */\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/aggregator/sentiment-aggregator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'desc' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inArray' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sentimentHistory' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SentimentAnalysisResult' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceBreakdown' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":331,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":331,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'volume' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":334,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":334,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentiment Aggregator Service\n * Combines sentiment from multiple sources into unified scores\n *\n * Features:\n * - Multi-source aggregation (news, Twitter, Reddit)\n * - Weighted averaging based on source, recency, engagement\n * - Fear & Greed Index calculation\n * - Trend detection\n * - Historical tracking\n *\n * @module sentiment/services/aggregator/sentiment-aggregator\n */\n\nimport { db } from '@/db';\nimport { eq, and, gte, lte, desc, sql, inArray } from 'drizzle-orm';\nimport {\n  newsArticles,\n  socialMentions,\n  sentimentScores,\n  sentimentHistory,\n} from '../../schema/sentiment.schema';\nimport type {\n  SentimentAnalysisResult,\n  AggregatedSentiment,\n  SentimentTrend,\n  FearGreedIndex,\n} from '../../types/sentiment.types';\nimport type { NewsArticle } from '../../types/news.types';\nimport type { SocialMention } from '../../types/social.types';\n\n/**\n * Helper: Parse timeframe string to milliseconds\n */\nfunction parseTimeframe(timeframe: string): number {\n  const match = timeframe.match(/^(\\d+)([mhd])$/);\n  if (!match) return 86400000; // Default 24h\n\n  const value = parseInt(match[1], 10);\n  const unit = match[2];\n\n  switch (unit) {\n    case 'm': return value * 60 * 1000; // minutes\n    case 'h': return value * 60 * 60 * 1000; // hours\n    case 'd': return value * 24 * 60 * 60 * 1000; // days\n    default: return 86400000;\n  }\n}\n\n/**\n * Source weights for aggregation\n */\nconst SOURCE_WEIGHTS = {\n  // News sources (most reliable)\n  cryptopanic: 1.0,\n  coindesk: 0.95,\n  cointelegraph: 0.9,\n  theblock: 0.95,\n  decrypt: 0.85,\n  bitcoinmagazine: 0.85,\n  cryptoslate: 0.8,\n  newsbtc: 0.75,\n  coingape: 0.7,\n  utoday: 0.7,\n  bitcoincom: 0.75,\n  rss: 0.7,\n\n  // Social sources (less reliable, but valuable for sentiment)\n  twitter: 0.6,\n  reddit: 0.5,\n  telegram: 0.55,\n  discord: 0.45,\n};\n\n/**\n * Aggregation Configuration\n */\nexport interface AggregatorConfig {\n  /**\n   * Time window for aggregation (milliseconds)\n   * Default: 24 hours\n   */\n  timeWindow: number;\n\n  /**\n   * Minimum data points required for aggregation\n   * Default: 5\n   */\n  minDataPoints: number;\n\n  /**\n   * Recency decay factor (exponential)\n   * Higher = more weight on recent data\n   * Default: 0.5 (moderate decay)\n   */\n  recencyDecay: number;\n\n  /**\n   * Engagement weight multiplier\n   * Default: 0.3 (30% influence)\n   */\n  engagementWeight: number;\n\n  /**\n   * Influencer boost multiplier\n   * Default: 1.5 (50% boost for influencer posts)\n   */\n  influencerBoost: number;\n\n  /**\n   * Fear & Greed calculation weights\n   */\n  fearGreedWeights: {\n    sentiment: number; // Sentiment score influence\n    volume: number; // Social volume influence\n    volatility: number; // Price volatility influence\n    momentum: number; // Trend momentum influence\n  };\n}\n\n/**\n * Sentiment Data Point\n */\ninterface SentimentDataPoint {\n  source: string;\n  score: number; // -100 to 100\n  magnitude: number; // 0 to 1\n  confidence: number; // 0 to 1\n  timestamp: Date;\n  weight: number; // Calculated weight\n  engagement?: number;\n  isInfluencer?: boolean;\n  symbols: string[];\n}\n\n/**\n * Sentiment Aggregator Service\n */\nexport class SentimentAggregatorService {\n  private config: AggregatorConfig;\n\n  constructor(config?: Partial<AggregatorConfig>) {\n    this.config = {\n      timeWindow: config?.timeWindow || 86400000, // 24 hours\n      minDataPoints: config?.minDataPoints || 5,\n      recencyDecay: config?.recencyDecay || 0.5,\n      engagementWeight: config?.engagementWeight || 0.3,\n      influencerBoost: config?.influencerBoost || 1.5,\n      fearGreedWeights: config?.fearGreedWeights || {\n        sentiment: 0.4,\n        volume: 0.25,\n        volatility: 0.2,\n        momentum: 0.15,\n      },\n    };\n  }\n\n  /**\n   * Aggregate sentiment from news articles\n   */\n  async aggregateFromNews(\n    articles: NewsArticle[],\n    symbol?: string\n  ): Promise<AggregatedSentiment | null> {\n    // Filter by symbol if provided\n    const filtered = symbol\n      ? articles.filter((a) => a.symbols.includes(symbol))\n      : articles;\n\n    // Filter by time window\n    const cutoff = new Date(Date.now() - this.config.timeWindow);\n    const recent = filtered.filter((a) => a.publishedAt >= cutoff);\n\n    if (recent.length < this.config.minDataPoints) {\n      return null; // Not enough data\n    }\n\n    // Convert to data points\n    const dataPoints: SentimentDataPoint[] = recent\n      .filter((a) => a.sentimentScore !== undefined)\n      .map((article) => ({\n        source: article.source,\n        score: article.sentimentScore!,\n        magnitude: article.sentimentMagnitude || 0.5,\n        confidence: 0.8, // News articles have high confidence\n        timestamp: article.publishedAt,\n        weight: this.calculateNewsWeight(article),\n        engagement: article.votes,\n        symbols: article.symbols,\n      }));\n\n    return this.aggregateDataPoints(dataPoints, symbol);\n  }\n\n  /**\n   * Aggregate sentiment from social mentions\n   */\n  async aggregateFromSocial(\n    mentions: SocialMention[],\n    symbol?: string\n  ): Promise<AggregatedSentiment | null> {\n    // Filter by symbol if provided\n    const filtered = symbol\n      ? mentions.filter((m) => m.symbols.includes(symbol))\n      : mentions;\n\n    // Filter by time window\n    const cutoff = new Date(Date.now() - this.config.timeWindow);\n    const recent = filtered.filter((m) => m.createdAt >= cutoff);\n\n    if (recent.length < this.config.minDataPoints) {\n      return null;\n    }\n\n    // Convert to data points (requires sentiment analysis)\n    // Note: This assumes mentions have been analyzed\n    const dataPoints: SentimentDataPoint[] = recent\n      .filter((m) => m.sentimentScore !== undefined)\n      .map((mention) => ({\n        source: mention.platform,\n        score: mention.sentimentScore!,\n        magnitude: mention.sentimentMagnitude || 0.5,\n        confidence: mention.sentimentConfidence || 0.5,\n        timestamp: mention.createdAt,\n        weight: this.calculateSocialWeight(mention),\n        engagement: this.calculateEngagement(mention),\n        isInfluencer: mention.isInfluencer,\n        symbols: mention.symbols,\n      }));\n\n    return this.aggregateDataPoints(dataPoints, symbol);\n  }\n\n  /**\n   * Aggregate sentiment from mixed sources\n   */\n  async aggregateFromAll(\n    news: NewsArticle[],\n    social: SocialMention[],\n    symbol?: string\n  ): Promise<AggregatedSentiment | null> {\n    // Combine data points from both sources\n    const newsPoints: SentimentDataPoint[] = news\n      .filter((a) => a.sentimentScore !== undefined)\n      .filter((a) => !symbol || a.symbols.includes(symbol))\n      .filter((a) => a.publishedAt >= new Date(Date.now() - this.config.timeWindow))\n      .map((article) => ({\n        source: article.source,\n        score: article.sentimentScore!,\n        magnitude: article.sentimentMagnitude || 0.5,\n        confidence: 0.8,\n        timestamp: article.publishedAt,\n        weight: this.calculateNewsWeight(article),\n        engagement: article.votes,\n        symbols: article.symbols,\n      }));\n\n    const socialPoints: SentimentDataPoint[] = social\n      .filter((m) => m.sentimentScore !== undefined)\n      .filter((m) => !symbol || m.symbols.includes(symbol))\n      .filter((m) => m.createdAt >= new Date(Date.now() - this.config.timeWindow))\n      .map((mention) => ({\n        source: mention.platform,\n        score: mention.sentimentScore!,\n        magnitude: mention.sentimentMagnitude || 0.5,\n        confidence: mention.sentimentConfidence || 0.5,\n        timestamp: mention.createdAt,\n        weight: this.calculateSocialWeight(mention),\n        engagement: this.calculateEngagement(mention),\n        isInfluencer: mention.isInfluencer,\n        symbols: mention.symbols,\n      }));\n\n    const allPoints = [...newsPoints, ...socialPoints];\n\n    if (allPoints.length < this.config.minDataPoints) {\n      return null;\n    }\n\n    return this.aggregateDataPoints(allPoints, symbol);\n  }\n\n  /**\n   * Aggregate data points into unified sentiment\n   */\n  private aggregateDataPoints(\n    dataPoints: SentimentDataPoint[],\n    symbol?: string\n  ): AggregatedSentiment {\n    // Calculate weighted average score\n    let totalWeightedScore = 0;\n    let totalWeight = 0;\n    let totalMagnitude = 0;\n    let totalConfidence = 0;\n\n    const now = Date.now();\n\n    dataPoints.forEach((point) => {\n      // Apply recency decay\n      const ageHours = (now - point.timestamp.getTime()) / 3600000;\n      const recencyMultiplier = Math.exp(-this.config.recencyDecay * ageHours);\n\n      // Apply engagement boost\n      const engagementBoost = point.engagement\n        ? 1 + (this.config.engagementWeight * Math.log(1 + point.engagement)) / 10\n        : 1;\n\n      // Apply influencer boost\n      const influencerMultiplier = point.isInfluencer ? this.config.influencerBoost : 1;\n\n      // Final weight\n      const finalWeight = point.weight * recencyMultiplier * engagementBoost * influencerMultiplier;\n\n      totalWeightedScore += point.score * finalWeight;\n      totalWeight += finalWeight;\n      totalMagnitude += point.magnitude;\n      totalConfidence += point.confidence;\n    });\n\n    const avgScore = totalWeight > 0 ? totalWeightedScore / totalWeight : 0;\n    const avgMagnitude = dataPoints.length > 0 ? totalMagnitude / dataPoints.length : 0;\n    const avgConfidence = dataPoints.length > 0 ? totalConfidence / dataPoints.length : 0;\n\n    // Determine label\n    const label = this.scoreToLabel(avgScore);\n\n    // Calculate trend\n    const trendData = this.calculateTrend(dataPoints);\n\n    // Calculate source breakdown\n    const sourceBreakdown = this.calculateSourceBreakdown(dataPoints);\n\n    // Calculate volume\n    const volume = dataPoints.length;\n\n    // Calculate change (compared to older half of data)\n    const change = this.calculateChange(dataPoints);\n\n    // Calculate scores by source type\n    const newsPoints = dataPoints.filter((p) =>\n      ['cryptopanic', 'coindesk', 'cointelegraph', 'theblock', 'decrypt',\n       'bitcoinmagazine', 'cryptoslate', 'newsbtc', 'coingape', 'utoday',\n       'bitcoincom', 'rss'].includes(p.source)\n    );\n\n    const socialPoints = dataPoints.filter((p) =>\n      ['twitter', 'reddit', 'telegram', 'discord'].includes(p.source)\n    );\n\n    const newsScore = newsPoints.length > 0\n      ? newsPoints.reduce((sum, p) => sum + p.score, 0) / newsPoints.length\n      : 0;\n\n    const socialScore = socialPoints.length > 0\n      ? socialPoints.reduce((sum, p) => sum + p.score, 0) / socialPoints.length\n      : 0;\n\n    const newsMentions = newsPoints.length;\n    const socialMentions = socialPoints.length;\n\n    // Calculate Fear & Greed Index\n    // Based on sentiment score (40%), volume (25%), volatility (20%), momentum (15%)\n    const sentimentComponent = ((avgScore + 100) / 200) * 100; // Normalize -100..100 to 0..100\n    const volumeComponent = Math.min(100, (dataPoints.length / 10) * 100); // Assume 1000 is max\n    const volatilityComponent = 50; // Default (would need price data for actual calculation)\n    const momentumComponent = ((change + 100) / 200) * 100; // Normalize trend change\n\n    const fearGreedIndex = (\n      sentimentComponent * 0.4 +\n      volumeComponent * 0.25 +\n      volatilityComponent * 0.2 +\n      momentumComponent * 0.15\n    );\n\n    let fearGreedLabel: 'extreme_fear' | 'fear' | 'neutral' | 'greed' | 'extreme_greed';\n    if (fearGreedIndex >= 75) fearGreedLabel = 'extreme_greed';\n    else if (fearGreedIndex >= 55) fearGreedLabel = 'greed';\n    else if (fearGreedIndex >= 45) fearGreedLabel = 'neutral';\n    else if (fearGreedIndex >= 25) fearGreedLabel = 'fear';\n    else fearGreedLabel = 'extreme_fear';\n\n    const aggregated: AggregatedSentiment = {\n      symbol: symbol || 'OVERALL',\n      timeframe: '24h',\n      timestamp: new Date(),\n      score: parseFloat(avgScore.toFixed(2)),\n      overallScore: parseFloat(avgScore.toFixed(2)),\n      overallMagnitude: parseFloat(avgMagnitude.toFixed(2)),\n      overallLabel: label,\n      label: label,\n      newsScore: parseFloat(newsScore.toFixed(2)),\n      socialScore: parseFloat(socialScore.toFixed(2)),\n      totalMentions: dataPoints.length,\n      newsMentions,\n      socialMentions,\n      trend: trendData.direction,\n      trendPercentage: change,\n      fearGreedIndex: parseFloat(fearGreedIndex.toFixed(2)),\n      fearGreedLabel,\n      confidence: parseFloat(avgConfidence.toFixed(2)),\n      updatedAt: new Date(),\n    };\n\n    return aggregated;\n  }\n\n  /**\n   * Calculate Fear & Greed Index\n   */\n  async calculateFearGreedIndex(\n    aggregatedSentiment: AggregatedSentiment,\n    socialVolume: number,\n    priceVolatility: number,\n    priceMomentum: number\n  ): Promise<FearGreedIndex> {\n    const weights = this.config.fearGreedWeights;\n\n    // Normalize inputs to 0-100 scale\n    const sentimentNorm = ((aggregatedSentiment.score + 100) / 200) * 100; // -100..100 → 0..100\n    const volumeNorm = Math.min(100, (socialVolume / 1000) * 100); // Assume 1000 is max\n    const volatilityNorm = 100 - Math.min(100, priceVolatility * 100); // High volatility = fear\n    const momentumNorm = ((priceMomentum + 100) / 200) * 100; // -100..100 → 0..100\n\n    // Calculate weighted index\n    const index =\n      sentimentNorm * weights.sentiment +\n      volumeNorm * weights.volume +\n      volatilityNorm * weights.volatility +\n      momentumNorm * weights.momentum;\n\n    // Determine label\n    let indexLabel: FearGreedIndex['label'];\n    if (index >= 75) indexLabel = 'extreme_greed';\n    else if (index >= 55) indexLabel = 'greed';\n    else if (index >= 45) indexLabel = 'neutral';\n    else if (index >= 25) indexLabel = 'fear';\n    else indexLabel = 'extreme_fear';\n\n    return {\n      value: parseFloat(index.toFixed(2)),\n      label: indexLabel,\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Calculate news article weight\n   */\n  private calculateNewsWeight(article: NewsArticle): number {\n    let weight = SOURCE_WEIGHTS[article.source as keyof typeof SOURCE_WEIGHTS] || 0.5;\n\n    // Boost for important news\n    if (article.isImportant) {\n      weight *= 1.3;\n    }\n\n    // Boost for trending news\n    if (article.isTrending) {\n      weight *= 1.2;\n    }\n\n    return weight;\n  }\n\n  /**\n   * Calculate social mention weight\n   */\n  private calculateSocialWeight(mention: SocialMention): number {\n    let weight = SOURCE_WEIGHTS[mention.platform] || 0.5;\n\n    // Boost for verified users\n    if ('isVerified' in mention && mention.isVerified) {\n      weight *= 1.3;\n    }\n\n    // Boost for influencers\n    if (mention.isInfluencer) {\n      weight *= 1.4;\n    }\n\n    return weight;\n  }\n\n  /**\n   * Calculate engagement score\n   */\n  private calculateEngagement(mention: SocialMention): number {\n    let engagement = 0;\n\n    engagement += mention.likes || 0;\n    engagement += (mention.replies || 0) * 2; // Replies worth more\n    engagement += (mention.views || 0) / 10; // Views worth less\n\n    if ('retweets' in mention) {\n      engagement += (mention.retweets || 0) * 3; // Retweets worth most\n    }\n\n    if ('upvotes' in mention) {\n      engagement += mention.upvotes || 0;\n    }\n\n    return engagement;\n  }\n\n  /**\n   * Calculate trend from data points\n   */\n  private calculateTrend(dataPoints: SentimentDataPoint[]): {\n    direction: SentimentTrend;\n    strength: number;\n    velocity: number;\n  } {\n    if (dataPoints.length < 2) {\n      return {\n        direction: 'stable',\n        strength: 0,\n        velocity: 0,\n      };\n    }\n\n    // Sort by timestamp\n    const sorted = [...dataPoints].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    // Split into two halves\n    const mid = Math.floor(sorted.length / 2);\n    const firstHalf = sorted.slice(0, mid);\n    const secondHalf = sorted.slice(mid);\n\n    // Calculate average scores\n    const firstAvg = firstHalf.reduce((sum, p) => sum + p.score, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, p) => sum + p.score, 0) / secondHalf.length;\n\n    const change = secondAvg - firstAvg;\n    const strength = Math.abs(change) / 100; // Normalize to 0-1\n\n    // Determine direction\n    let direction: SentimentTrend;\n    if (Math.abs(change) < 5) direction = 'stable';\n    else if (change > 0) direction = 'improving';\n    else direction = 'deteriorating';\n\n    // Calculate velocity (change per hour)\n    const timespan = (sorted[sorted.length - 1].timestamp.getTime() - sorted[0].timestamp.getTime()) / 3600000;\n    const velocity = timespan > 0 ? change / timespan : 0;\n\n    return {\n      direction,\n      strength: parseFloat(strength.toFixed(2)),\n      velocity: parseFloat(velocity.toFixed(2)),\n    };\n  }\n\n  /**\n   * Calculate change compared to older data\n   */\n  private calculateChange(dataPoints: SentimentDataPoint[]): number {\n    if (dataPoints.length < 2) return 0;\n\n    const sorted = [...dataPoints].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n    const mid = Math.floor(sorted.length / 2);\n\n    const firstHalf = sorted.slice(0, mid);\n    const secondHalf = sorted.slice(mid);\n\n    const firstAvg = firstHalf.reduce((sum, p) => sum + p.score, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, p) => sum + p.score, 0) / secondHalf.length;\n\n    return parseFloat((secondAvg - firstAvg).toFixed(2));\n  }\n\n  /**\n   * Calculate source breakdown\n   */\n  private calculateSourceBreakdown(\n    dataPoints: SentimentDataPoint[]\n  ): Record<string, { count: number; avgScore: number; weight: number }> {\n    const breakdown: Record<string, { count: number; totalScore: number; totalWeight: number }> = {};\n\n    dataPoints.forEach((point) => {\n      if (!breakdown[point.source]) {\n        breakdown[point.source] = {\n          count: 0,\n          totalScore: 0,\n          totalWeight: 0,\n        };\n      }\n\n      breakdown[point.source].count++;\n      breakdown[point.source].totalScore += point.score;\n      breakdown[point.source].totalWeight += point.weight;\n    });\n\n    // Calculate averages\n    const result: Record<string, { count: number; avgScore: number; weight: number }> = {};\n    Object.entries(breakdown).forEach(([source, data]) => {\n      result[source] = {\n        count: data.count,\n        avgScore: parseFloat((data.totalScore / data.count).toFixed(2)),\n        weight: parseFloat((data.totalWeight / data.count).toFixed(2)),\n      };\n    });\n\n    return result;\n  }\n\n  /**\n   * Convert score to label\n   */\n  private scoreToLabel(score: number): AggregatedSentiment['label'] {\n    if (score >= 60) return 'very_positive';\n    if (score >= 20) return 'positive';\n    if (score >= -20) return 'neutral';\n    if (score >= -60) return 'negative';\n    return 'very_negative';\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<AggregatorConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): AggregatorConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get Aggregated Sentiment for a symbol\n   * Fetches from database and calculates if needed\n   */\n  async getAggregatedSentiment(symbol: string, timeframe: string = '24h'): Promise<any> {\n    try {\n      const symbolUpper = symbol.toUpperCase();\n\n      // Try to fetch existing aggregated sentiment from database\n      const existingSentiment = await db\n        .select()\n        .from(sentimentScores)\n        .where(\n          and(\n            eq(sentimentScores.symbol, symbolUpper),\n            eq(sentimentScores.timeframe, timeframe)\n          )\n        )\n        .limit(1);\n\n      if (existingSentiment.length > 0) {\n        const sentiment = existingSentiment[0];\n        return {\n          symbol: symbolUpper,\n          score: parseFloat(sentiment.overallScore as any),\n          magnitude: parseFloat(sentiment.overallMagnitude as any),\n          label: sentiment.overallLabel,\n          confidence: parseFloat(sentiment.confidence as any) || 0.7,\n          trend: {\n            direction: sentiment.trend,\n            strength: Math.abs(parseFloat(sentiment.trendPercentage as any) || 0) / 50,\n          },\n          newsScore: parseFloat(sentiment.newsScore as any) || 0,\n          socialScore: parseFloat(sentiment.socialScore as any) || 0,\n          totalMentions: sentiment.totalMentions || 0,\n          newsMentions: sentiment.newsMentions || 0,\n          socialMentions: sentiment.socialMentions || 0,\n          fearGreedIndex: parseFloat(sentiment.fearGreedIndex as any) || 50,\n          fearGreedLabel: sentiment.fearGreedLabel,\n          sources: ['database'],\n          timeframe,\n          timestamp: sentiment.updatedAt.toISOString(),\n        };\n      }\n\n      // If no cached data, calculate from raw data\n      const timeMs = parseTimeframe(timeframe);\n      const cutoffDate = new Date(Date.now() - timeMs);\n\n      // Fetch recent news articles\n      const news = await db\n        .select()\n        .from(newsArticles)\n        .where(\n          and(\n            sql`${newsArticles.symbols} @> ${JSON.stringify([symbolUpper])}`,\n            gte(newsArticles.publishedAt, cutoffDate),\n            eq(newsArticles.isAnalyzed, true)\n          )\n        )\n        .limit(1000);\n\n      // Fetch recent social mentions\n      const social = await db\n        .select()\n        .from(socialMentions)\n        .where(\n          and(\n            sql`${socialMentions.symbols} @> ${JSON.stringify([symbolUpper])}`,\n            gte(socialMentions.createdAt, cutoffDate),\n            eq(socialMentions.isAnalyzed, true)\n          )\n        )\n        .limit(1000);\n\n      // If we have data, aggregate it\n      if (news.length > 0 || social.length > 0) {\n        const aggregated = await this.aggregateFromAll(news as any[], social as any[], symbolUpper);\n\n        if (aggregated) {\n          return {\n            symbol: symbolUpper,\n            score: aggregated.score,\n            magnitude: aggregated.overallMagnitude,\n            label: aggregated.label,\n            confidence: aggregated.confidence,\n            trend: {\n              direction: aggregated.trend,\n              strength: Math.abs(aggregated.trendPercentage) / 50,\n            },\n            newsScore: aggregated.newsScore,\n            socialScore: aggregated.socialScore,\n            totalMentions: aggregated.totalMentions,\n            newsMentions: aggregated.newsMentions,\n            socialMentions: aggregated.socialMentions,\n            fearGreedIndex: aggregated.fearGreedIndex,\n            fearGreedLabel: aggregated.fearGreedLabel,\n            sources: ['news', 'social'],\n            timeframe,\n            timestamp: new Date().toISOString(),\n          };\n        }\n      }\n\n      // Return neutral default if no data\n      return {\n        symbol: symbolUpper,\n        score: 0,\n        magnitude: 0.5,\n        label: 'neutral',\n        confidence: 0.5,\n        trend: {\n          direction: 'stable',\n          strength: 0,\n        },\n        newsScore: 0,\n        socialScore: 0,\n        totalMentions: 0,\n        newsMentions: 0,\n        socialMentions: 0,\n        fearGreedIndex: 50,\n        fearGreedLabel: 'neutral',\n        sources: [],\n        timeframe,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error getting aggregated sentiment:', error);\n      // Return neutral on error\n      return {\n        symbol: symbol.toUpperCase(),\n        score: 0,\n        magnitude: 0.5,\n        label: 'neutral',\n        confidence: 0.5,\n        trend: {\n          direction: 'stable',\n          strength: 0,\n        },\n        sources: [],\n        timeframe,\n        timestamp: new Date().toISOString(),\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Analyze Multi-Source Sentiment\n   * Mock implementation - analyzes from multiple sources\n   */\n  async analyzeMultiSource(symbol: string, sources: string[] = ['local'], timeframe: string = '24h'): Promise<any> {\n    // Mock implementation\n    const results = sources.map(source => ({\n      source,\n      score: Math.random() * 2 - 1, // -1 to 1\n      label: 'neutral',\n      confidence: 0.7,\n    }));\n\n    const avgScore = results.reduce((sum, r) => sum + r.score, 0) / results.length;\n\n    return {\n      symbol: symbol.toUpperCase(),\n      aggregated: {\n        score: avgScore,\n        label: avgScore > 0.2 ? 'positive' : avgScore < -0.2 ? 'negative' : 'neutral',\n        confidence: 0.7,\n      },\n      sources: results,\n      timeframe,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Create Sentiment Aggregator instance\n */\nexport function createSentimentAggregator(config?: Partial<AggregatorConfig>): SentimentAggregatorService {\n  return new SentimentAggregatorService(config);\n}\n\n/**\n * Singleton instance\n */\nexport const sentimentAggregator = new SentimentAggregatorService({\n  timeWindow: parseInt(process.env.SENTIMENT_TIME_WINDOW || '86400000', 10),\n  minDataPoints: parseInt(process.env.SENTIMENT_MIN_DATA_POINTS || '5', 10),\n  recencyDecay: parseFloat(process.env.SENTIMENT_RECENCY_DECAY || '0.5'),\n  engagementWeight: parseFloat(process.env.SENTIMENT_ENGAGEMENT_WEIGHT || '0.3'),\n  influencerBoost: parseFloat(process.env.SENTIMENT_INFLUENCER_BOOST || '1.5'),\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/analysis/sentiment-ai.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/analysis/sentiment-hybrid.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/analysis/sentiment-local.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":121,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":121,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":299,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":299,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Local Sentiment Analysis Service\n * Fast, offline sentiment analysis using sentiment.js and compromise\n *\n * @module sentiment/services/analysis/sentiment-local\n */\n\nimport Sentiment from 'sentiment';\nimport nlp from 'compromise';\nimport type { SentimentAnalysisResult, TextAnalysisOptions } from '../../types/sentiment.types';\n\n/**\n * Custom crypto-specific lexicon for sentiment analysis\n */\nconst CRYPTO_LEXICON: Record<string, number> = {\n  // Very positive (5)\n  'moon': 5,\n  'mooning': 5,\n  'bullish': 5,\n  'lambo': 5,\n  'rocket': 5,\n  'hodl': 4,\n  'buy': 4,\n  'pump': 4,\n  'rally': 4,\n  'surge': 4,\n  'breakout': 4,\n  'adoption': 4,\n  'mainstream': 3,\n  'accumulate': 3,\n  'undervalued': 3,\n  'gem': 4,\n  'golden': 4,\n  'profits': 3,\n  'gains': 3,\n  'winning': 3,\n  'success': 3,\n\n  // Positive (2-3)\n  'green': 2,\n  'up': 2,\n  'rise': 2,\n  'increase': 2,\n  'growth': 3,\n  'upgrade': 3,\n  'partnership': 3,\n  'innovative': 3,\n  'promising': 3,\n\n  // Very negative (-5)\n  'crash': -5,\n  'scam': -5,\n  'rug': -5,\n  'rugpull': -5,\n  'dump': -5,\n  'dumping': -4,\n  'ponzi': -5,\n  'fraud': -5,\n  'hack': -5,\n  'exploit': -5,\n  'bearish': -5,\n  'rekt': -5,\n\n  // Negative (-2 to -4)\n  'sell': -4,\n  'selling': -4,\n  'fall': -3,\n  'drop': -3,\n  'decline': -3,\n  'plunge': -4,\n  'tank': -4,\n  'red': -2,\n  'down': -2,\n  'loss': -3,\n  'losses': -3,\n  'concern': -2,\n  'worried': -3,\n  'fear': -3,\n  'panic': -4,\n  'bubble': -3,\n  'overvalued': -3,\n\n  // Uncertainty (-1)\n  'uncertain': -1,\n  'volatile': -1,\n  'risky': -2,\n  'speculation': -1,\n  'maybe': -1,\n  'might': -1,\n  'could': -1,\n\n  // Crypto slang\n  'fomo': 2, // Fear of missing out\n  'fud': -4, // Fear, uncertainty, doubt\n  'rip': -4,\n  'bag': -2, // Bagholder\n  'bagholder': -3,\n  'whale': 1,\n  'dip': -1,\n  'btfd': 3, // Buy the f*ing dip\n  'wagmi': 4, // We're all gonna make it\n  'ngmi': -4, // Not gonna make it\n  'ath': 4, // All time high\n  'atl': -3, // All time low\n};\n\n/**\n * Local Sentiment Analysis Service\n */\nexport class SentimentLocalService {\n  private analyzer: Sentiment;\n\n  constructor() {\n    // Initialize sentiment analyzer\n    this.analyzer = new Sentiment();\n  }\n\n  /**\n   * Analyze text sentiment\n   */\n  async analyze(text: string, options?: TextAnalysisOptions): Promise<SentimentAnalysisResult> {\n    const startTime = Date.now();\n\n    // Preprocess text\n    const processedText = this.preprocessText(text);\n\n    // Run sentiment analysis with crypto-specific lexicon\n    const result = this.analyzer.analyze(processedText, {\n      extras: CRYPTO_LEXICON,\n    });\n\n    // Calculate normalized score (-100 to 100)\n    const normalizedScore = this.normalizeScore(result.score, processedText.split(' ').length);\n\n    // Calculate magnitude (0 to 1) based on word count and score\n    const magnitude = this.calculateMagnitude(result);\n\n    // Determine label\n    const label = this.determineLabel(normalizedScore);\n\n    // Calculate confidence (higher for extreme scores, lower for neutral)\n    const confidence = this.calculateConfidence(normalizedScore, magnitude);\n\n    // Extract keywords\n    const keywords = this.extractKeywords(text, result);\n\n    // Calculate aspects (fear, greed, uncertainty, hype)\n    const aspects = this.calculateAspects(text, result);\n\n    const analysisResult: SentimentAnalysisResult = {\n      score: parseFloat(normalizedScore.toFixed(2)),\n      magnitude: parseFloat(magnitude.toFixed(2)),\n      label,\n      confidence: parseFloat(confidence.toFixed(2)),\n      provider: 'local',\n      processedAt: new Date(),\n      processingTime: Date.now() - startTime,\n      aspects,\n      keywords,\n    };\n\n    return analysisResult;\n  }\n\n  /**\n   * Batch analyze multiple texts\n   */\n  async analyzeBatch(texts: string[], options?: TextAnalysisOptions): Promise<SentimentAnalysisResult[]> {\n    const results: SentimentAnalysisResult[] = [];\n\n    for (const text of texts) {\n      try {\n        const result = await this.analyze(text, options);\n        results.push(result);\n      } catch (error) {\n        console.error('Error analyzing text:', error);\n        // Return neutral result on error\n        results.push(this.createNeutralResult());\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Preprocess text for analysis\n   */\n  private preprocessText(text: string): string {\n    // Convert to lowercase\n    let processed = text.toLowerCase();\n\n    // Remove URLs\n    processed = processed.replace(/https?:\\/\\/[^\\s]+/g, '');\n\n    // Remove mentions (@username)\n    processed = processed.replace(/@[\\w]+/g, '');\n\n    // Remove excessive punctuation\n    processed = processed.replace(/[!?]{2,}/g, '!');\n\n    // Remove extra whitespace\n    processed = processed.replace(/\\s+/g, ' ').trim();\n\n    return processed;\n  }\n\n  /**\n   * Normalize sentiment score to -100 to 100 scale\n   */\n  private normalizeScore(rawScore: number, wordCount: number): number {\n    if (wordCount === 0) return 0;\n\n    // Normalize based on word count (avoid extreme scores for short texts)\n    const normalizedScore = (rawScore / Math.sqrt(wordCount)) * 10;\n\n    // Clamp to -100 to 100\n    return Math.max(-100, Math.min(100, normalizedScore));\n  }\n\n  /**\n   * Calculate magnitude (strength of emotion)\n   */\n  private calculateMagnitude(result: any): number {\n    const totalTokens = result.tokens.length;\n    if (totalTokens === 0) return 0;\n\n    // Count how many words have sentiment\n    const sentimentWords = result.positive.length + result.negative.length;\n\n    // Magnitude is the ratio of sentiment words to total words\n    const magnitude = sentimentWords / totalTokens;\n\n    return Math.min(1, magnitude * 2); // Scale up a bit\n  }\n\n  /**\n   * Determine sentiment label\n   */\n  private determineLabel(score: number): SentimentAnalysisResult['label'] {\n    if (score >= 60) return 'very_positive';\n    if (score >= 20) return 'positive';\n    if (score >= -20) return 'neutral';\n    if (score >= -60) return 'negative';\n    return 'very_negative';\n  }\n\n  /**\n   * Calculate confidence level\n   */\n  private calculateConfidence(score: number, magnitude: number): number {\n    // Higher confidence for extreme scores\n    const scoreConfidence = Math.abs(score) / 100;\n\n    // Higher confidence when magnitude is high\n    const magnitudeConfidence = magnitude;\n\n    // Combined confidence\n    const confidence = (scoreConfidence * 0.7) + (magnitudeConfidence * 0.3);\n\n    return Math.min(1, Math.max(0.1, confidence));\n  }\n\n  /**\n   * Extract keywords that influenced sentiment\n   */\n  private extractKeywords(text: string, result: any): Array<{ word: string; score: number; weight: number }> {\n    const keywords: Array<{ word: string; score: number; weight: number }> = [];\n\n    // Add positive words\n    result.positive.forEach((word: string) => {\n      const score = CRYPTO_LEXICON[word] || 1;\n      keywords.push({\n        word,\n        score,\n        weight: score / 5, // Normalize to 0-1\n      });\n    });\n\n    // Add negative words\n    result.negative.forEach((word: string) => {\n      const score = CRYPTO_LEXICON[word] || -1;\n      keywords.push({\n        word,\n        score,\n        weight: Math.abs(score) / 5, // Normalize to 0-1\n      });\n    });\n\n    // Sort by absolute score\n    keywords.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));\n\n    // Return top 10\n    return keywords.slice(0, 10);\n  }\n\n  /**\n   * Calculate emotional aspects (fear, greed, uncertainty, hype)\n   */\n  private calculateAspects(text: string, result: any): {\n    fear?: number;\n    greed?: number;\n    uncertainty?: number;\n    hype?: number;\n  } {\n    const lowerText = text.toLowerCase();\n\n    // Fear indicators\n    const fearWords = ['crash', 'scam', 'hack', 'panic', 'fear', 'fud', 'rekt', 'loss', 'dump'];\n    const fearScore = fearWords.reduce((sum, word) => {\n      return sum + (lowerText.includes(word) ? 1 : 0);\n    }, 0);\n\n    // Greed indicators\n    const greedWords = ['moon', 'lambo', 'pump', 'gains', 'profits', 'buy', 'hodl', 'rocket'];\n    const greedScore = greedWords.reduce((sum, word) => {\n      return sum + (lowerText.includes(word) ? 1 : 0);\n    }, 0);\n\n    // Uncertainty indicators\n    const uncertaintyWords = ['maybe', 'might', 'could', 'uncertain', 'volatile', 'speculation'];\n    const uncertaintyScore = uncertaintyWords.reduce((sum, word) => {\n      return sum + (lowerText.includes(word) ? 1 : 0);\n    }, 0);\n\n    // Hype indicators\n    const hypeWords = ['breakthrough', 'revolutionary', 'game-changer', 'mainstream', 'adoption', 'gem'];\n    const hypeScore = hypeWords.reduce((sum, word) => {\n      return sum + (lowerText.includes(word) ? 1 : 0);\n    }, 0);\n\n    return {\n      fear: Math.min(1, fearScore / 3),\n      greed: Math.min(1, greedScore / 3),\n      uncertainty: Math.min(1, uncertaintyScore / 3),\n      hype: Math.min(1, hypeScore / 3),\n    };\n  }\n\n  /**\n   * Create neutral result (for errors)\n   */\n  private createNeutralResult(): SentimentAnalysisResult {\n    return {\n      score: 0,\n      magnitude: 0,\n      label: 'neutral',\n      confidence: 0.1,\n      provider: 'local',\n      processedAt: new Date(),\n      processingTime: 0,\n    };\n  }\n\n  /**\n   * Extract entities (coins, people, exchanges)\n   */\n  extractEntities(text: string): {\n    coins: string[];\n    people: string[];\n    exchanges: string[];\n    technologies: string[];\n  } {\n    const doc = nlp(text);\n\n    // Extract proper nouns\n    const properNouns = doc.match('#ProperNoun').out('array');\n\n    // Known exchanges\n    const knownExchanges = ['binance', 'coinbase', 'kraken', 'ftx', 'okx', 'bybit', 'kucoin', 'huobi'];\n\n    // Known technologies\n    const knownTech = ['blockchain', 'defi', 'nft', 'web3', 'metaverse', 'dao', 'ethereum', 'bitcoin'];\n\n    const entities = {\n      coins: [] as string[],\n      people: properNouns.filter((noun: string) => {\n        const lower = noun.toLowerCase();\n        return !knownExchanges.includes(lower) && !knownTech.includes(lower);\n      }),\n      exchanges: properNouns.filter((noun: string) => knownExchanges.includes(noun.toLowerCase())),\n      technologies: properNouns.filter((noun: string) => knownTech.includes(noun.toLowerCase())),\n    };\n\n    // Extract coin symbols ($BTC, $ETH)\n    const coinPattern = /\\$([A-Z]{2,10})/g;\n    const matches = text.matchAll(coinPattern);\n    for (const match of matches) {\n      entities.coins.push(match[1]);\n    }\n\n    return entities;\n  }\n\n  /**\n   * Detect language\n   */\n  detectLanguage(text: string): string {\n    // Simple heuristic - check for common English words\n    const englishWords = ['the', 'is', 'are', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'];\n    const lowerText = text.toLowerCase();\n    const englishWordCount = englishWords.reduce((count, word) => {\n      return count + (lowerText.includes(` ${word} `) ? 1 : 0);\n    }, 0);\n\n    return englishWordCount >= 2 ? 'en' : 'unknown';\n  }\n}\n\n// Export singleton instance\nexport const sentimentLocalService = new SentimentLocalService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/analyzer/price-correlation.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'df' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":437,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":437,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Price Correlation Service\n * Analyzes correlation between sentiment and price movements\n *\n * Features:\n * - Pearson correlation calculation\n * - Leading/lagging relationship detection\n * - Sentiment-driven price signal generation\n * - Multi-timeframe analysis\n * - Divergence detection\n *\n * @module sentiment/services/analyzer/price-correlation\n */\n\nimport type { AggregatedSentiment } from '../../types/sentiment.types';\n\n/**\n * Price Data Point\n */\nexport interface PriceDataPoint {\n  timestamp: Date;\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  volume: number;\n}\n\n/**\n * Correlation Result\n */\nexport interface CorrelationResult {\n  symbol: string;\n  coefficient: number; // -1 to 1 (Pearson correlation)\n  pValue: number; // Statistical significance (0 to 1)\n  isSignificant: boolean; // p-value < 0.05\n  strength: 'very_weak' | 'weak' | 'moderate' | 'strong' | 'very_strong';\n  direction: 'positive' | 'negative' | 'none';\n  lag: number; // Time lag in hours (sentiment leads if positive, lags if negative)\n  dataPoints: number;\n  timeframe: string;\n  calculatedAt: Date;\n}\n\n/**\n * Divergence Detection Result\n */\nexport interface DivergenceResult {\n  symbol: string;\n  type: 'bullish' | 'bearish';\n  severity: 'weak' | 'moderate' | 'strong';\n  sentimentTrend: 'up' | 'down';\n  priceTrend: 'up' | 'down';\n  startTime: Date;\n  endTime: Date;\n  description: string;\n}\n\n/**\n * Sentiment-Price Signal\n */\nexport interface SentimentPriceSignal {\n  symbol: string;\n  signal: 'strong_buy' | 'buy' | 'neutral' | 'sell' | 'strong_sell';\n  confidence: number; // 0 to 1\n  reasoning: string[];\n  sentimentScore: number;\n  priceChange: number;\n  correlation: number;\n  generatedAt: Date;\n}\n\n/**\n * Correlation Configuration\n */\nexport interface CorrelationConfig {\n  /**\n   * Minimum data points for correlation\n   * Default: 20\n   */\n  minDataPoints: number;\n\n  /**\n   * Time windows to analyze (hours)\n   * Default: [1, 4, 24, 168] (1h, 4h, 24h, 1w)\n   */\n  timeframes: number[];\n\n  /**\n   * Max lag to test (hours)\n   * Default: 24 (test up to 24h lag)\n   */\n  maxLag: number;\n\n  /**\n   * P-value threshold for significance\n   * Default: 0.05 (95% confidence)\n   */\n  significanceThreshold: number;\n\n  /**\n   * Divergence detection threshold\n   * Default: 0.3 (30% difference in normalized trends)\n   */\n  divergenceThreshold: number;\n}\n\n/**\n * Price Correlation Service\n */\nexport class PriceCorrelationService {\n  private config: CorrelationConfig;\n\n  constructor(config?: Partial<CorrelationConfig>) {\n    this.config = {\n      minDataPoints: config?.minDataPoints || 20,\n      timeframes: config?.timeframes || [1, 4, 24, 168], // 1h, 4h, 24h, 1w\n      maxLag: config?.maxLag || 24,\n      significanceThreshold: config?.significanceThreshold || 0.05,\n      divergenceThreshold: config?.divergenceThreshold || 0.3,\n    };\n  }\n\n  /**\n   * Calculate correlation between sentiment and price\n   */\n  async calculateCorrelation(\n    sentimentData: Array<{ timestamp: Date; score: number }>,\n    priceData: PriceDataPoint[],\n    symbol: string,\n    timeframeHours?: number\n  ): Promise<CorrelationResult> {\n    // Align data points by timestamp\n    const aligned = this.alignDataPoints(sentimentData, priceData);\n\n    if (aligned.length < this.config.minDataPoints) {\n      throw new Error(`Insufficient data points. Need at least ${this.config.minDataPoints}, got ${aligned.length}`);\n    }\n\n    // Calculate price returns (percentage change)\n    const priceReturns = aligned.map((point, i) => {\n      if (i === 0) return 0;\n      return ((point.price - aligned[i - 1].price) / aligned[i - 1].price) * 100;\n    });\n\n    // Extract sentiment scores\n    const sentimentScores = aligned.map((point) => point.sentiment);\n\n    // Calculate Pearson correlation\n    const coefficient = this.pearsonCorrelation(sentimentScores, priceReturns);\n\n    // Calculate p-value (approximate)\n    const pValue = this.calculatePValue(coefficient, aligned.length);\n\n    // Determine statistical significance\n    const isSignificant = pValue < this.config.significanceThreshold;\n\n    // Determine correlation strength\n    const strength = this.determineStrength(Math.abs(coefficient));\n\n    // Determine direction\n    let direction: CorrelationResult['direction'];\n    if (Math.abs(coefficient) < 0.1) {\n      direction = 'none';\n    } else if (coefficient > 0) {\n      direction = 'positive';\n    } else {\n      direction = 'negative';\n    }\n\n    // Find optimal lag (sentiment leading or lagging price)\n    const lag = await this.findOptimalLag(sentimentScores, priceReturns);\n\n    return {\n      symbol,\n      coefficient: parseFloat(coefficient.toFixed(4)),\n      pValue: parseFloat(pValue.toFixed(4)),\n      isSignificant,\n      strength,\n      direction,\n      lag,\n      dataPoints: aligned.length,\n      timeframe: timeframeHours ? `${timeframeHours}h` : 'custom',\n      calculatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Calculate correlation for multiple timeframes\n   */\n  async calculateMultiTimeframeCorrelation(\n    sentimentData: Array<{ timestamp: Date; score: number }>,\n    priceData: PriceDataPoint[],\n    symbol: string\n  ): Promise<CorrelationResult[]> {\n    const results: CorrelationResult[] = [];\n\n    for (const timeframeHours of this.config.timeframes) {\n      try {\n        // Filter data for this timeframe\n        const cutoff = new Date(Date.now() - timeframeHours * 3600000);\n\n        const filteredSentiment = sentimentData.filter((d) => d.timestamp >= cutoff);\n        const filteredPrice = priceData.filter((d) => d.timestamp >= cutoff);\n\n        if (filteredSentiment.length >= this.config.minDataPoints &&\n            filteredPrice.length >= this.config.minDataPoints) {\n          const result = await this.calculateCorrelation(\n            filteredSentiment,\n            filteredPrice,\n            symbol,\n            timeframeHours\n          );\n          results.push(result);\n        }\n      } catch (error) {\n        console.error(`Error calculating correlation for ${timeframeHours}h:`, error);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Detect divergences between sentiment and price\n   */\n  async detectDivergences(\n    sentimentData: Array<{ timestamp: Date; score: number }>,\n    priceData: PriceDataPoint[]\n  ): Promise<DivergenceResult[]> {\n    const divergences: DivergenceResult[] = [];\n\n    // Need at least 10 points to detect divergence\n    if (sentimentData.length < 10 || priceData.length < 10) {\n      return divergences;\n    }\n\n    // Align data\n    const aligned = this.alignDataPoints(sentimentData, priceData);\n\n    // Calculate trends (using linear regression)\n    const sentimentTrend = this.calculateTrend(aligned.map((p) => p.sentiment));\n    const priceTrend = this.calculateTrend(aligned.map((p) => p.price));\n\n    // Normalize trends to -1 to 1 scale\n    const sentimentSlope = sentimentTrend / 100; // Sentiment is -100 to 100\n    const priceSlope = priceTrend / aligned[0].price; // Normalize by initial price\n\n    // Check for divergence\n    const difference = Math.abs(sentimentSlope - priceSlope);\n\n    if (difference > this.config.divergenceThreshold) {\n      // Bullish divergence: price down, sentiment up\n      if (priceSlope < 0 && sentimentSlope > 0) {\n        divergences.push({\n          symbol: priceData[0] ? 'UNKNOWN' : 'UNKNOWN', // Would need symbol passed in\n          type: 'bullish',\n          severity: this.determineDivergenceSeverity(difference),\n          sentimentTrend: 'up',\n          priceTrend: 'down',\n          startTime: aligned[0].timestamp,\n          endTime: aligned[aligned.length - 1].timestamp,\n          description: 'Price declining while sentiment improving - potential reversal signal',\n        });\n      }\n      // Bearish divergence: price up, sentiment down\n      else if (priceSlope > 0 && sentimentSlope < 0) {\n        divergences.push({\n          symbol: priceData[0] ? 'UNKNOWN' : 'UNKNOWN',\n          type: 'bearish',\n          severity: this.determineDivergenceSeverity(difference),\n          sentimentTrend: 'down',\n          priceTrend: 'up',\n          startTime: aligned[0].timestamp,\n          endTime: aligned[aligned.length - 1].timestamp,\n          description: 'Price rising while sentiment deteriorating - potential correction signal',\n        });\n      }\n    }\n\n    return divergences;\n  }\n\n  /**\n   * Generate trading signals based on sentiment-price correlation\n   */\n  async generateSignals(\n    currentSentiment: AggregatedSentiment,\n    priceData: PriceDataPoint[],\n    correlation: CorrelationResult\n  ): Promise<SentimentPriceSignal> {\n    const reasoning: string[] = [];\n    let signalStrength = 0; // -2 to +2\n\n    // Factor 1: Current sentiment score\n    if (currentSentiment.score > 60) {\n      signalStrength += 1;\n      reasoning.push(`Strong positive sentiment (${currentSentiment.score})`);\n    } else if (currentSentiment.score < -60) {\n      signalStrength -= 1;\n      reasoning.push(`Strong negative sentiment (${currentSentiment.score})`);\n    }\n\n    // Factor 2: Sentiment trend\n    if (currentSentiment.trend === 'improving') {\n      signalStrength += 0.5;\n      reasoning.push('Sentiment improving');\n    } else if (currentSentiment.trend === 'deteriorating') {\n      signalStrength -= 0.5;\n      reasoning.push('Sentiment deteriorating');\n    }\n\n    // Factor 3: Correlation strength\n    if (correlation.isSignificant) {\n      if (correlation.direction === 'positive') {\n        // Strong positive correlation: sentiment predicts price\n        const correlationBoost = Math.abs(correlation.coefficient) * 0.5;\n        signalStrength += (currentSentiment.score > 0 ? correlationBoost : -correlationBoost);\n        reasoning.push(`Strong ${correlation.direction} correlation (${correlation.coefficient.toFixed(2)})`);\n      }\n    } else {\n      reasoning.push('Weak correlation - sentiment not predictive');\n    }\n\n    // Factor 4: Recent price change\n    if (priceData.length >= 2) {\n      const recentPriceChange = ((priceData[priceData.length - 1].close - priceData[0].close) / priceData[0].close) * 100;\n\n      // Divergence check: if sentiment and price diverge, it's a potential reversal\n      if (currentSentiment.score > 20 && recentPriceChange < -5) {\n        signalStrength += 1;\n        reasoning.push('Bullish divergence detected');\n      } else if (currentSentiment.score < -20 && recentPriceChange > 5) {\n        signalStrength -= 1;\n        reasoning.push('Bearish divergence detected');\n      }\n    }\n\n    // Map signal strength to signal type\n    let signal: SentimentPriceSignal['signal'];\n    let confidence: number;\n\n    if (signalStrength >= 1.5) {\n      signal = 'strong_buy';\n      confidence = Math.min(0.95, 0.6 + signalStrength * 0.15);\n    } else if (signalStrength >= 0.5) {\n      signal = 'buy';\n      confidence = 0.5 + signalStrength * 0.2;\n    } else if (signalStrength <= -1.5) {\n      signal = 'strong_sell';\n      confidence = Math.min(0.95, 0.6 + Math.abs(signalStrength) * 0.15);\n    } else if (signalStrength <= -0.5) {\n      signal = 'sell';\n      confidence = 0.5 + Math.abs(signalStrength) * 0.2;\n    } else {\n      signal = 'neutral';\n      confidence = 0.3;\n      reasoning.push('No strong signal detected');\n    }\n\n    const recentPriceChange = priceData.length >= 2\n      ? ((priceData[priceData.length - 1].close - priceData[0].close) / priceData[0].close) * 100\n      : 0;\n\n    return {\n      symbol: currentSentiment.symbol,\n      signal,\n      confidence: parseFloat(confidence.toFixed(2)),\n      reasoning,\n      sentimentScore: currentSentiment.score,\n      priceChange: parseFloat(recentPriceChange.toFixed(2)),\n      correlation: correlation.coefficient,\n      generatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Align sentiment and price data by timestamp\n   */\n  private alignDataPoints(\n    sentimentData: Array<{ timestamp: Date; score: number }>,\n    priceData: PriceDataPoint[]\n  ): Array<{ timestamp: Date; sentiment: number; price: number }> {\n    const aligned: Array<{ timestamp: Date; sentiment: number; price: number }> = [];\n\n    // For each sentiment data point, find closest price point\n    sentimentData.forEach((sentiment) => {\n      // Find nearest price point (within 30 minutes)\n      const nearest = priceData.find((price) => {\n        const diff = Math.abs(price.timestamp.getTime() - sentiment.timestamp.getTime());\n        return diff < 1800000; // 30 minutes\n      });\n\n      if (nearest) {\n        aligned.push({\n          timestamp: sentiment.timestamp,\n          sentiment: sentiment.score,\n          price: nearest.close,\n        });\n      }\n    });\n\n    return aligned;\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient\n   */\n  private pearsonCorrelation(x: number[], y: number[]): number {\n    if (x.length !== y.length || x.length === 0) return 0;\n\n    const n = x.length;\n    const sumX = x.reduce((a, b) => a + b, 0);\n    const sumY = y.reduce((a, b) => a + b, 0);\n    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n    const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);\n\n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n\n    if (denominator === 0) return 0;\n\n    return numerator / denominator;\n  }\n\n  /**\n   * Calculate p-value (approximate using t-distribution)\n   */\n  private calculatePValue(r: number, n: number): number {\n    if (n < 3) return 1;\n\n    // t-statistic\n    const t = (r * Math.sqrt(n - 2)) / Math.sqrt(1 - r * r);\n\n    // Degrees of freedom\n    const df = n - 2;\n\n    // Approximate p-value using normal approximation\n    // (For more accuracy, use a proper t-distribution library)\n    const p = 2 * (1 - this.normalCDF(Math.abs(t)));\n\n    return Math.max(0, Math.min(1, p));\n  }\n\n  /**\n   * Normal cumulative distribution function (approximation)\n   */\n  private normalCDF(z: number): number {\n    const t = 1 / (1 + 0.2316419 * Math.abs(z));\n    const d = 0.3989423 * Math.exp((-z * z) / 2);\n    const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));\n\n    return z > 0 ? 1 - p : p;\n  }\n\n  /**\n   * Find optimal lag between sentiment and price\n   */\n  private async findOptimalLag(sentiment: number[], price: number[]): Promise<number> {\n    let bestLag = 0;\n    let bestCorrelation = 0;\n\n    // Test different lags\n    for (let lag = -this.config.maxLag; lag <= this.config.maxLag; lag++) {\n      const correlation = this.calculateLaggedCorrelation(sentiment, price, lag);\n\n      if (Math.abs(correlation) > Math.abs(bestCorrelation)) {\n        bestCorrelation = correlation;\n        bestLag = lag;\n      }\n    }\n\n    return bestLag;\n  }\n\n  /**\n   * Calculate correlation with lag\n   */\n  private calculateLaggedCorrelation(x: number[], y: number[], lag: number): number {\n    if (lag === 0) {\n      return this.pearsonCorrelation(x, y);\n    }\n\n    if (lag > 0) {\n      // Sentiment leads price\n      const xLagged = x.slice(0, -lag);\n      const yLagged = y.slice(lag);\n      return this.pearsonCorrelation(xLagged, yLagged);\n    } else {\n      // Price leads sentiment\n      const xLagged = x.slice(-lag);\n      const yLagged = y.slice(0, lag);\n      return this.pearsonCorrelation(xLagged, yLagged);\n    }\n  }\n\n  /**\n   * Calculate trend (linear regression slope)\n   */\n  private calculateTrend(values: number[]): number {\n    const n = values.length;\n    if (n < 2) return 0;\n\n    const x = Array.from({ length: n }, (_, i) => i);\n    const sumX = x.reduce((a, b) => a + b, 0);\n    const sumY = values.reduce((a, b) => a + b, 0);\n    const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);\n    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n\n    return slope;\n  }\n\n  /**\n   * Determine correlation strength\n   */\n  private determineStrength(absCorr: number): CorrelationResult['strength'] {\n    if (absCorr >= 0.7) return 'very_strong';\n    if (absCorr >= 0.5) return 'strong';\n    if (absCorr >= 0.3) return 'moderate';\n    if (absCorr >= 0.1) return 'weak';\n    return 'very_weak';\n  }\n\n  /**\n   * Determine divergence severity\n   */\n  private determineDivergenceSeverity(difference: number): DivergenceResult['severity'] {\n    if (difference >= 0.6) return 'strong';\n    if (difference >= 0.4) return 'moderate';\n    return 'weak';\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<CorrelationConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): CorrelationConfig {\n    return { ...this.config };\n  }\n}\n\n/**\n * Create Price Correlation Service\n */\nexport function createPriceCorrelationService(config?: Partial<CorrelationConfig>): PriceCorrelationService {\n  return new PriceCorrelationService(config);\n}\n\n/**\n * Singleton instance\n */\nexport const priceCorrelationService = new PriceCorrelationService({\n  minDataPoints: parseInt(process.env.CORRELATION_MIN_DATA_POINTS || '20', 10),\n  timeframes: process.env.CORRELATION_TIMEFRAMES\n    ? JSON.parse(process.env.CORRELATION_TIMEFRAMES)\n    : [1, 4, 24, 168],\n  maxLag: parseInt(process.env.CORRELATION_MAX_LAG || '24', 10),\n  significanceThreshold: parseFloat(process.env.CORRELATION_SIGNIFICANCE || '0.05'),\n  divergenceThreshold: parseFloat(process.env.CORRELATION_DIVERGENCE_THRESHOLD || '0.3'),\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/analyzer/trending-topics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'peakTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":169,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Trending Topics Analyzer\n * Detects trending hashtags, keywords, and topics from social media\n *\n * Features:\n * - Real-time trend detection\n * - Velocity-based ranking (growth rate)\n * - Engagement-weighted scoring\n * - Symbol association\n * - Emerging vs declining trend classification\n *\n * @module sentiment/services/analyzer/trending-topics\n */\n\nimport type { TrendingTopic } from '../../types/social.types';\nimport type { SocialMention } from '../../types/social.types';\n\n/**\n * Trending Configuration\n */\nexport interface TrendingConfig {\n  /**\n   * Time window for trend analysis (milliseconds)\n   * Default: 1 hour\n   */\n  timeWindow: number;\n\n  /**\n   * Minimum mentions required to be considered trending\n   * Default: 10\n   */\n  minMentions: number;\n\n  /**\n   * Velocity threshold (mentions per hour)\n   * Topics must grow faster than this to be \"emerging\"\n   * Default: 5\n   */\n  velocityThreshold: number;\n\n  /**\n   * Engagement weight multiplier\n   * Default: 0.4 (40% influence)\n   */\n  engagementWeight: number;\n\n  /**\n   * Recency decay factor\n   * Default: 0.7\n   */\n  recencyDecay: number;\n\n  /**\n   * Max trending topics to return\n   * Default: 50\n   */\n  maxTopics: number;\n}\n\n/**\n * Topic Data Point\n */\ninterface TopicDataPoint {\n  topic: string; // Hashtag or keyword\n  timestamp: Date;\n  engagement: number;\n  symbols: string[];\n  source: string;\n}\n\n/**\n * Topic Statistics\n */\ninterface TopicStats {\n  topic: string;\n  mentions: number;\n  firstSeen: Date;\n  lastSeen: Date;\n  totalEngagement: number;\n  avgEngagement: number;\n  velocity: number; // Mentions per hour\n  symbols: Set<string>;\n  sources: Set<string>;\n  dataPoints: TopicDataPoint[];\n}\n\n/**\n * Trending Topics Service\n */\nexport class TrendingTopicsService {\n  private config: TrendingConfig;\n  private topicHistory: Map<string, TopicStats> = new Map();\n  private lastCleanup: Date = new Date();\n\n  constructor(config?: Partial<TrendingConfig>) {\n    this.config = {\n      timeWindow: config?.timeWindow || 3600000, // 1 hour\n      minMentions: config?.minMentions || 10,\n      velocityThreshold: config?.velocityThreshold || 5,\n      engagementWeight: config?.engagementWeight || 0.4,\n      recencyDecay: config?.recencyDecay || 0.7,\n      maxTopics: config?.maxTopics || 50,\n    };\n\n    // Clean up old data every 10 minutes\n    setInterval(() => this.cleanupOldData(), 600000);\n  }\n\n  /**\n   * Process social mentions to extract trending topics\n   */\n  async processMentions(mentions: SocialMention[]): Promise<TrendingTopic[]> {\n    // Extract topics from mentions\n    mentions.forEach((mention) => {\n      // Process hashtags\n      if (mention.hashtags && mention.hashtags.length > 0) {\n        mention.hashtags.forEach((hashtag) => {\n          this.addDataPoint({\n            topic: hashtag.toLowerCase(),\n            timestamp: mention.createdAt,\n            engagement: this.calculateMentionEngagement(mention),\n            symbols: mention.symbols,\n            source: mention.platform,\n          });\n        });\n      }\n\n      // Extract keywords from text (top N-grams)\n      const keywords = this.extractKeywords(mention.text);\n      keywords.forEach((keyword) => {\n        this.addDataPoint({\n          topic: keyword.toLowerCase(),\n          timestamp: mention.createdAt,\n          engagement: this.calculateMentionEngagement(mention),\n          symbols: mention.symbols,\n          source: mention.platform,\n        });\n      });\n    });\n\n    // Calculate trending scores and return top topics\n    return this.getTrendingTopics();\n  }\n\n  /**\n   * Get current trending topics\n   */\n  getTrendingTopics(): TrendingTopic[] {\n    const now = new Date();\n    const cutoff = new Date(now.getTime() - this.config.timeWindow);\n\n    const trendingList: TrendingTopic[] = [];\n\n    this.topicHistory.forEach((stats, topic) => {\n      // Filter data points within time window\n      const recentPoints = stats.dataPoints.filter((p) => p.timestamp >= cutoff);\n\n      if (recentPoints.length < this.config.minMentions) {\n        return; // Skip topics with insufficient mentions\n      }\n\n      // Calculate trending score\n      const score = this.calculateTrendingScore(stats, recentPoints, now);\n\n      // Determine trend type\n      const trendType = this.determineTrendType(stats, recentPoints);\n\n      // Calculate peak time\n      const peakTime = this.calculatePeakTime(recentPoints);\n\n      // Find related symbols\n      const relatedSymbols = Array.from(stats.symbols);\n\n      const trending: TrendingTopic = {\n        id: crypto.randomUUID(),\n        keyword: stats.topic,\n        type: topic.startsWith('#') ? 'hashtag' : 'keyword',\n        symbols: relatedSymbols,\n        mentionCount: recentPoints.length,\n        mentionGrowth: stats.velocity * 100,\n        score,\n        averageSentiment: 0, // Will be calculated separately\n        sentimentTrend: 'stable',\n        trendType,\n        platforms: Array.from(stats.sources).map(source => ({\n          platform: source as any,\n          count: recentPoints.filter(p => p.source === source).length,\n        })),\n        period: '1h',\n        timestamp: now,\n        topPosts: [],\n      };\n\n      trendingList.push(trending);\n    });\n\n    // Sort by score descending\n    trendingList.sort((a, b) => (b.score || 0) - (a.score || 0));\n\n    // Return top N\n    return trendingList.slice(0, this.config.maxTopics);\n  }\n\n  /**\n   * Get trending topics for specific symbol\n   */\n  getTrendingForSymbol(symbol: string): TrendingTopic[] {\n    const all = this.getTrendingTopics();\n    return all.filter((t) => t.symbols && t.symbols.includes(symbol));\n  }\n\n  /**\n   * Add data point for topic\n   */\n  private addDataPoint(dataPoint: TopicDataPoint): void {\n    const { topic } = dataPoint;\n\n    if (!this.topicHistory.has(topic)) {\n      this.topicHistory.set(topic, {\n        topic,\n        mentions: 0,\n        firstSeen: dataPoint.timestamp,\n        lastSeen: dataPoint.timestamp,\n        totalEngagement: 0,\n        avgEngagement: 0,\n        velocity: 0,\n        symbols: new Set(),\n        sources: new Set(),\n        dataPoints: [],\n      });\n    }\n\n    const stats = this.topicHistory.get(topic)!;\n    stats.dataPoints.push(dataPoint);\n    stats.mentions++;\n    stats.lastSeen = dataPoint.timestamp;\n    stats.totalEngagement += dataPoint.engagement;\n    stats.avgEngagement = stats.totalEngagement / stats.mentions;\n\n    // Add symbols and sources\n    dataPoint.symbols.forEach((s) => stats.symbols.add(s));\n    stats.sources.add(dataPoint.source);\n\n    // Recalculate velocity\n    const timespanHours =\n      (stats.lastSeen.getTime() - stats.firstSeen.getTime()) / 3600000;\n    stats.velocity = timespanHours > 0 ? stats.mentions / timespanHours : stats.mentions;\n  }\n\n  /**\n   * Calculate trending score\n   */\n  private calculateTrendingScore(\n    stats: TopicStats,\n    recentPoints: TopicDataPoint[],\n    now: Date\n  ): number {\n    if (recentPoints.length === 0) return 0;\n\n    // Components of trending score:\n    // 1. Volume (number of mentions)\n    // 2. Velocity (growth rate)\n    // 3. Engagement (likes, retweets, etc.)\n    // 4. Recency (more recent = higher score)\n\n    // Normalize volume (log scale)\n    const volumeScore = Math.log10(recentPoints.length + 1) * 20;\n\n    // Velocity score (mentions per hour)\n    const velocityScore = Math.min(100, stats.velocity * 2);\n\n    // Engagement score\n    const avgEngagement = recentPoints.reduce((sum, p) => sum + p.engagement, 0) / recentPoints.length;\n    const engagementScore = Math.log10(avgEngagement + 1) * 15;\n\n    // Recency score (exponential decay)\n    let recencyScore = 0;\n    recentPoints.forEach((point) => {\n      const ageHours = (now.getTime() - point.timestamp.getTime()) / 3600000;\n      const decay = Math.exp(-this.config.recencyDecay * ageHours);\n      recencyScore += decay;\n    });\n    recencyScore = (recencyScore / recentPoints.length) * 30;\n\n    // Combine scores\n    const totalScore =\n      volumeScore * 0.3 +\n      velocityScore * 0.35 +\n      engagementScore * this.config.engagementWeight +\n      recencyScore * (1 - this.config.engagementWeight - 0.3);\n\n    return parseFloat(totalScore.toFixed(2));\n  }\n\n  /**\n   * Determine trend type\n   */\n  private determineTrendType(\n    stats: TopicStats,\n    recentPoints: TopicDataPoint[]\n  ): TrendingTopic['trendType'] {\n    if (recentPoints.length < 4) return 'emerging';\n\n    // Split into two halves to detect growth/decline\n    const mid = Math.floor(recentPoints.length / 2);\n    const firstHalf = recentPoints.slice(0, mid);\n    const secondHalf = recentPoints.slice(mid);\n\n    const firstHalfRate = firstHalf.length / mid;\n    const secondHalfRate = secondHalf.length / (recentPoints.length - mid);\n\n    const growthRate = (secondHalfRate - firstHalfRate) / firstHalfRate;\n\n    // Check if emerging (new topic with high velocity)\n    const ageHours = (stats.lastSeen.getTime() - stats.firstSeen.getTime()) / 3600000;\n    if (ageHours < 2 && stats.velocity > this.config.velocityThreshold) {\n      return 'emerging';\n    }\n\n    // Check if peak (high velocity but slowing down)\n    if (stats.velocity > this.config.velocityThreshold && growthRate < 0) {\n      return 'peak';\n    }\n\n    // Check if declining\n    if (growthRate < -0.3) {\n      return 'declining';\n    }\n\n    // Sustained trend\n    return 'sustained';\n  }\n\n  /**\n   * Calculate peak time (time of highest activity)\n   */\n  private calculatePeakTime(dataPoints: TopicDataPoint[]): Date {\n    if (dataPoints.length === 0) return new Date();\n\n    // Group by hour buckets\n    const buckets: Map<number, { count: number; engagement: number }> = new Map();\n\n    dataPoints.forEach((point) => {\n      const hourBucket = Math.floor(point.timestamp.getTime() / 3600000) * 3600000;\n\n      if (!buckets.has(hourBucket)) {\n        buckets.set(hourBucket, { count: 0, engagement: 0 });\n      }\n\n      const bucket = buckets.get(hourBucket)!;\n      bucket.count++;\n      bucket.engagement += point.engagement;\n    });\n\n    // Find bucket with highest activity\n    let maxActivity = 0;\n    let peakBucket = 0;\n\n    buckets.forEach((bucket, time) => {\n      const activity = bucket.count + bucket.engagement / 10;\n      if (activity > maxActivity) {\n        maxActivity = activity;\n        peakBucket = time;\n      }\n    });\n\n    return new Date(peakBucket);\n  }\n\n  /**\n   * Extract keywords from text (simple N-gram extraction)\n   */\n  private extractKeywords(text: string): string[] {\n    // Remove URLs, mentions, hashtags\n    const cleaned = text\n      .replace(/https?:\\/\\/[^\\s]+/g, '')\n      .replace(/@[\\w]+/g, '')\n      .replace(/#[\\w]+/g, '')\n      .toLowerCase();\n\n    // Split into words\n    const words = cleaned.match(/\\b[a-z]{3,}\\b/g) || [];\n\n    // Filter stop words and crypto-specific terms\n    const stopWords = new Set(['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'has', 'had', 'was', 'been', 'have', 'this', 'that', 'with', 'from', 'will', 'what', 'when', 'where']);\n\n    const cryptoTerms = new Set(['bitcoin', 'ethereum', 'crypto', 'blockchain', 'btc', 'eth', 'altcoin', 'defi', 'nft', 'trading', 'market', 'price']);\n\n    const keywords: string[] = [];\n\n    // Unigrams (single words)\n    words.forEach((word) => {\n      if (cryptoTerms.has(word) && !stopWords.has(word)) {\n        keywords.push(word);\n      }\n    });\n\n    // Bigrams (two-word phrases)\n    for (let i = 0; i < words.length - 1; i++) {\n      if (!stopWords.has(words[i]) && !stopWords.has(words[i + 1])) {\n        const bigram = `${words[i]} ${words[i + 1]}`;\n        if (this.isCryptoRelated(bigram)) {\n          keywords.push(bigram);\n        }\n      }\n    }\n\n    // Return unique keywords (max 5 per mention)\n    return Array.from(new Set(keywords)).slice(0, 5);\n  }\n\n  /**\n   * Check if phrase is crypto-related\n   */\n  private isCryptoRelated(phrase: string): boolean {\n    const cryptoKeywords = [\n      'bull', 'bear', 'pump', 'dump', 'moon', 'lambo', 'hodl',\n      'whale', 'market', 'price', 'rally', 'crash', 'surge',\n      'breakout', 'support', 'resistance', 'pattern', 'chart'\n    ];\n\n    return cryptoKeywords.some((kw) => phrase.includes(kw));\n  }\n\n  /**\n   * Calculate engagement for mention\n   */\n  private calculateMentionEngagement(mention: SocialMention): number {\n    let engagement = 0;\n\n    engagement += mention.likes || 0;\n    engagement += (mention.replies || 0) * 2;\n    engagement += (mention.views || 0) / 100;\n\n    if ('retweets' in mention) {\n      engagement += (mention.retweets || 0) * 3;\n    }\n\n    if ('upvotes' in mention) {\n      engagement += mention.upvotes || 0;\n    }\n\n    return engagement;\n  }\n\n  /**\n   * Clean up old data outside time window\n   */\n  private cleanupOldData(): void {\n    const now = new Date();\n    const cutoff = new Date(now.getTime() - this.config.timeWindow * 2); // Keep 2x time window\n\n    this.topicHistory.forEach((stats, topic) => {\n      // Remove old data points\n      stats.dataPoints = stats.dataPoints.filter((p) => p.timestamp >= cutoff);\n\n      // Remove topic if no recent data\n      if (stats.dataPoints.length === 0) {\n        this.topicHistory.delete(topic);\n      } else {\n        // Recalculate stats\n        stats.mentions = stats.dataPoints.length;\n        stats.firstSeen = stats.dataPoints[0].timestamp;\n        stats.lastSeen = stats.dataPoints[stats.dataPoints.length - 1].timestamp;\n        stats.totalEngagement = stats.dataPoints.reduce((sum, p) => sum + p.engagement, 0);\n        stats.avgEngagement = stats.totalEngagement / stats.mentions;\n\n        const timespanHours =\n          (stats.lastSeen.getTime() - stats.firstSeen.getTime()) / 3600000;\n        stats.velocity = timespanHours > 0 ? stats.mentions / timespanHours : stats.mentions;\n      }\n    });\n\n    this.lastCleanup = now;\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats(): {\n    totalTopics: number;\n    trendingTopics: number;\n    lastCleanup: Date;\n  } {\n    return {\n      totalTopics: this.topicHistory.size,\n      trendingTopics: this.getTrendingTopics().length,\n      lastCleanup: this.lastCleanup,\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<TrendingConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): TrendingConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Reset all data\n   */\n  reset(): void {\n    this.topicHistory.clear();\n    this.lastCleanup = new Date();\n  }\n}\n\n/**\n * Create Trending Topics Service\n */\nexport function createTrendingTopicsService(config?: Partial<TrendingConfig>): TrendingTopicsService {\n  return new TrendingTopicsService(config);\n}\n\n/**\n * Singleton instance\n */\nexport const trendingTopicsService = new TrendingTopicsService({\n  timeWindow: parseInt(process.env.TRENDING_TIME_WINDOW || '3600000', 10),\n  minMentions: parseInt(process.env.TRENDING_MIN_MENTIONS || '10', 10),\n  velocityThreshold: parseFloat(process.env.TRENDING_VELOCITY_THRESHOLD || '5'),\n  engagementWeight: parseFloat(process.env.TRENDING_ENGAGEMENT_WEIGHT || '0.4'),\n  recencyDecay: parseFloat(process.env.TRENDING_RECENCY_DECAY || '0.7'),\n  maxTopics: parseInt(process.env.TRENDING_MAX_TOPICS || '50', 10),\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/integration/sentiment-agent.integration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lte' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sentimentAggregator' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'priceCorrelationService' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sentiment Agent Integration\n * Integrates sentiment analysis with the Marketing Agent (CMO)\n *\n * @module sentiment/services/integration/sentiment-agent\n */\n\nimport logger from '@/utils/logger';\nimport { db } from '@/db';\nimport { eq, and, gte, lte, desc, sql } from 'drizzle-orm';\nimport {\n  sentimentScores,\n  sentimentHistory,\n  sentimentAlerts,\n} from '../../schema/sentiment.schema';\nimport { AgentService } from '@/modules/agents/services/agent.service';\nimport { hybridSentimentService } from '../analysis/sentiment-hybrid.service';\nimport { sentimentAggregator } from '../aggregator/sentiment-aggregator.service';\nimport { trendingTopicsService } from '../analyzer/trending-topics.service';\nimport { priceCorrelationService } from '../analyzer/price-correlation.service';\nimport { cryptoPanicService } from '../sources/cryptopanic.service';\nimport { rssFeedsService } from '../sources/rss-feeds.service';\nimport { twitterService } from '../sources/twitter.service';\nimport { redditService } from '../sources/reddit.service';\nimport type { AgentActionRequest } from '@/modules/agents/types/agents.types';\n\n/**\n * Sentiment Agent Actions\n * Actions that the Marketing Agent can execute\n */\nexport const SentimentAgentActions = {\n  /**\n   * Analyze text sentiment\n   */\n  'sentiment:analyze_text': {\n    description: 'Analyze sentiment of a text using hybrid AI+Local NLP',\n    async handler(input: { text: string; context?: any }) {\n      if (!input.text) {\n        throw new Error('Text is required');\n      }\n\n      return await hybridSentimentService.analyze(input.text, input.context);\n    },\n  },\n\n  /**\n   * Analyze batch of texts\n   */\n  'sentiment:analyze_batch': {\n    description: 'Batch analyze multiple texts',\n    async handler(input: { texts: Array<{ id: string; text: string }>; options?: any }) {\n      if (!input.texts || input.texts.length === 0) {\n        throw new Error('Texts array is required');\n      }\n\n      return await hybridSentimentService.analyzeBatch({\n        texts: input.texts,\n        options: input.options,\n      });\n    },\n  },\n\n  /**\n   * Get aggregated sentiment for symbol\n   */\n  'sentiment:get_aggregated': {\n    description: 'Get aggregated sentiment from multiple sources',\n    async handler(input: { symbol?: string; timeWindow?: number }) {\n      try {\n        if (!input.symbol) {\n          throw new Error('Symbol is required');\n        }\n\n        const symbolUpper = input.symbol.toUpperCase();\n        const timeframe = input.timeWindow ? `${Math.floor(input.timeWindow / 3600000)}h` : '24h';\n\n        // Fetch sentiment from database\n        const sentiment = await db\n          .select()\n          .from(sentimentScores)\n          .where(\n            and(\n              eq(sentimentScores.symbol, symbolUpper),\n              eq(sentimentScores.timeframe, timeframe)\n            )\n          )\n          .limit(1);\n\n        if (sentiment.length === 0) {\n          // Return neutral default\n          return {\n            symbol: symbolUpper,\n            score: 0,\n            magnitude: 0,\n            label: 'neutral' as const,\n            confidence: 0.5,\n            trend: {\n              direction: 'stable' as const,\n              strength: 0,\n              velocity: 0,\n            },\n            volume: 0,\n            change: 0,\n            sourceBreakdown: {\n              news: { score: 0, count: 0 },\n              social: { score: 0, count: 0 },\n            },\n            timeWindow: input.timeWindow || 86400000,\n            dataPoints: 0,\n            lastUpdated: new Date(),\n          };\n        }\n\n        const s = sentiment[0];\n\n        return {\n          symbol: symbolUpper,\n          score: parseFloat(s.overallScore as any),\n          magnitude: parseFloat(s.overallMagnitude as any),\n          label: s.overallLabel as any,\n          confidence: parseFloat(s.confidence as any) || 0.5,\n          trend: {\n            direction: s.trend as any,\n            strength: Math.abs(parseFloat(s.trendPercentage as any) || 0) / 50,\n            velocity: 0, // Would need to calculate from history\n          },\n          volume: s.totalMentions || 0,\n          change: parseFloat(s.trendPercentage as any) || 0,\n          sourceBreakdown: {\n            news: {\n              score: parseFloat(s.newsScore as any) || 0,\n              count: s.newsMentions || 0,\n            },\n            social: {\n              score: parseFloat(s.socialScore as any) || 0,\n              count: s.socialMentions || 0,\n            },\n          },\n          fearGreed: {\n            index: parseFloat(s.fearGreedIndex as any) || 50,\n            label: s.fearGreedLabel,\n          },\n          timeWindow: input.timeWindow || 86400000,\n          dataPoints: s.totalMentions || 0,\n          lastUpdated: s.updatedAt,\n        };\n      } catch (error) {\n        logger.error('Error fetching aggregated sentiment', { error });\n        // Return neutral on error\n        return {\n          symbol: input.symbol || 'OVERALL',\n          score: 0,\n          magnitude: 0,\n          label: 'neutral' as const,\n          confidence: 0.5,\n          trend: {\n            direction: 'stable' as const,\n            strength: 0,\n            velocity: 0,\n          },\n          volume: 0,\n          change: 0,\n          sourceBreakdown: {},\n          timeWindow: input.timeWindow || 86400000,\n          dataPoints: 0,\n          lastUpdated: new Date(),\n          error: error instanceof Error ? error.message : 'Unknown error',\n        };\n      }\n    },\n  },\n\n  /**\n   * Get trending topics\n   */\n  'sentiment:get_trending': {\n    description: 'Get current trending topics',\n    async handler(input: { symbol?: string; limit?: number }) {\n      const trending = input.symbol\n        ? trendingTopicsService.getTrendingForSymbol(input.symbol.toUpperCase())\n        : trendingTopicsService.getTrendingTopics();\n\n      const limit = input.limit || 50;\n      return trending.slice(0, limit);\n    },\n  },\n\n  /**\n   * Fetch news articles\n   */\n  'sentiment:fetch_news': {\n    description: 'Fetch recent news articles',\n    async handler(input: { symbol?: string; source?: 'cryptopanic' | 'rss'; limit?: number }) {\n      let articles: any[] = [];\n\n      if (input.source === 'cryptopanic' && cryptoPanicService) {\n        articles = input.symbol\n          ? await cryptoPanicService.fetchForCurrency(input.symbol.toUpperCase())\n          : await cryptoPanicService.fetchRecent();\n      } else if (rssFeedsService) {\n        articles = await rssFeedsService.fetchAllFeeds();\n        if (input.symbol) {\n          articles = articles.filter((a) => a.symbols.includes(input.symbol!.toUpperCase()));\n        }\n      }\n\n      const limit = input.limit || 50;\n      return articles.slice(0, limit);\n    },\n  },\n\n  /**\n   * Monitor social media\n   */\n  'sentiment:monitor_social': {\n    description: 'Monitor social media mentions',\n    async handler(input: { symbol: string; platform: 'twitter' | 'reddit'; limit?: number }) {\n      let mentions: any[] = [];\n\n      if (input.platform === 'twitter' && twitterService) {\n        mentions = await twitterService.searchCryptoTweets(input.symbol.toUpperCase(), {\n          maxResults: input.limit || 100,\n        });\n      } else if (input.platform === 'reddit' && redditService) {\n        mentions = await redditService.searchCrypto(input.symbol.toUpperCase(), {\n          limit: input.limit || 100,\n        });\n      }\n\n      return mentions;\n    },\n  },\n\n  /**\n   * Generate trading signals\n   */\n  'sentiment:generate_signals': {\n    description: 'Generate trading signals based on sentiment',\n    async handler(input: { symbol: string }) {\n      try {\n        const symbolUpper = input.symbol.toUpperCase();\n\n        // Fetch current sentiment\n        const currentSentiment = await db\n          .select()\n          .from(sentimentScores)\n          .where(\n            and(\n              eq(sentimentScores.symbol, symbolUpper),\n              eq(sentimentScores.timeframe, '24h')\n            )\n          )\n          .limit(1);\n\n        if (currentSentiment.length === 0) {\n          return {\n            symbol: symbolUpper,\n            signal: 'HOLD' as const,\n            confidence: 0,\n            reasoning: ['No sentiment data available'],\n            sentimentScore: 0,\n            priceChange: 0,\n            correlation: 0,\n            generatedAt: new Date(),\n          };\n        }\n\n        // Fetch recent history for trend analysis\n        const history = await db\n          .select()\n          .from(sentimentHistory)\n          .where(\n            and(\n              eq(sentimentHistory.symbol, symbolUpper),\n              gte(sentimentHistory.timestamp, new Date(Date.now() - 3600000)) // Last hour\n            )\n          )\n          .orderBy(desc(sentimentHistory.timestamp))\n          .limit(12);\n\n        const s = currentSentiment[0];\n        const score = parseFloat(s.overallScore as any);\n        const trendPct = parseFloat(s.trendPercentage as any) || 0;\n        const volume = s.totalMentions || 0;\n\n        // Calculate velocity\n        let velocity = 0;\n        if (history.length >= 2) {\n          const scores = history.map((h) => parseFloat(h.score as any));\n          velocity = (scores[0] - scores[scores.length - 1]) / scores.length;\n        }\n\n        // Determine signal\n        let signal: 'STRONG_BUY' | 'BUY' | 'HOLD' | 'SELL' | 'STRONG_SELL' = 'HOLD';\n        let confidence = 50;\n        const reasoning: string[] = [];\n\n        if (score > 70 && trendPct > 0) {\n          signal = 'STRONG_BUY';\n          confidence = 85;\n          reasoning.push(`Very positive sentiment (${score.toFixed(1)})`);\n          reasoning.push(`Improving trend (+${trendPct.toFixed(1)}%)`);\n        } else if (score > 50 && trendPct > 0) {\n          signal = 'BUY';\n          confidence = 70;\n          reasoning.push(`Positive sentiment (${score.toFixed(1)})`);\n          reasoning.push(`Improving trend (+${trendPct.toFixed(1)}%)`);\n        } else if (score < -70 && trendPct < 0) {\n          signal = 'STRONG_SELL';\n          confidence = 85;\n          reasoning.push(`Very negative sentiment (${score.toFixed(1)})`);\n          reasoning.push(`Deteriorating trend (${trendPct.toFixed(1)}%)`);\n        } else if (score < -50 && trendPct < 0) {\n          signal = 'SELL';\n          confidence = 70;\n          reasoning.push(`Negative sentiment (${score.toFixed(1)})`);\n          reasoning.push(`Deteriorating trend (${trendPct.toFixed(1)}%)`);\n        } else {\n          reasoning.push(`Neutral sentiment (${score.toFixed(1)})`);\n        }\n\n        // Adjust confidence based on volume\n        if (volume > 1000) {\n          confidence = Math.min(95, confidence + 10);\n          reasoning.push(`High volume (${volume} mentions)`);\n        } else if (volume < 50) {\n          confidence = Math.max(30, confidence - 15);\n          reasoning.push(`Low volume (${volume} mentions)`);\n        }\n\n        // Get price change if available\n        let priceChange = 0;\n        if (history.length > 0 && history[0].priceChange24h) {\n          priceChange = parseFloat(history[0].priceChange24h as any);\n        }\n\n        return {\n          symbol: symbolUpper,\n          signal,\n          confidence,\n          reasoning,\n          sentimentScore: score,\n          priceChange,\n          correlation: 0, // Would need to calculate\n          velocity: parseFloat(velocity.toFixed(2)),\n          volume,\n          generatedAt: new Date(),\n        };\n      } catch (error) {\n        logger.error('Error generating trading signals', { error });\n        return {\n          symbol: input.symbol.toUpperCase(),\n          signal: 'HOLD' as const,\n          confidence: 0,\n          reasoning: ['Error generating signal'],\n          sentimentScore: 0,\n          priceChange: 0,\n          correlation: 0,\n          error: error instanceof Error ? error.message : 'Unknown error',\n          generatedAt: new Date(),\n        };\n      }\n    },\n  },\n\n  /**\n   * Check sentiment alerts\n   */\n  'sentiment:check_alerts': {\n    description: 'Check for sentiment-based alerts',\n    async handler(input: { symbol: string; userId?: string; tenantId?: string }) {\n      try {\n        const symbolUpper = input.symbol.toUpperCase();\n\n        // Fetch current sentiment\n        const currentSentiment = await db\n          .select()\n          .from(sentimentScores)\n          .where(\n            and(\n              eq(sentimentScores.symbol, symbolUpper),\n              eq(sentimentScores.timeframe, '24h')\n            )\n          )\n          .limit(1);\n\n        if (currentSentiment.length === 0) {\n          return [];\n        }\n\n        const sentiment = currentSentiment[0];\n        const score = parseFloat(sentiment.overallScore as any);\n        const volume = sentiment.totalMentions || 0;\n        const trendPct = parseFloat(sentiment.trendPercentage as any) || 0;\n\n        // Build filter conditions\n        const conditions: any[] = [\n          eq(sentimentAlerts.symbol, symbolUpper),\n          eq(sentimentAlerts.enabled, true),\n        ];\n\n        if (input.userId) {\n          conditions.push(eq(sentimentAlerts.userId, input.userId));\n        }\n        if (input.tenantId) {\n          conditions.push(eq(sentimentAlerts.tenantId, input.tenantId));\n        }\n\n        // Fetch active alerts for this symbol\n        const alerts = await db\n          .select()\n          .from(sentimentAlerts)\n          .where(and(...conditions))\n          .limit(100);\n\n        const triggeredAlerts: Array<{\n          id: string;\n          type: string;\n          severity: 'low' | 'medium' | 'high';\n          message: string;\n          threshold: number;\n          currentValue: number;\n        }> = [];\n\n        const now = new Date();\n\n        for (const alert of alerts) {\n          // Check cooldown\n          if (alert.lastTriggered) {\n            const cooldownMs = alert.cooldownMinutes * 60 * 1000;\n            const timeSinceLastTrigger = now.getTime() - alert.lastTriggered.getTime();\n            if (timeSinceLastTrigger < cooldownMs) {\n              continue; // Still in cooldown\n            }\n          }\n\n          const threshold = parseFloat(alert.conditionThreshold as any);\n          let shouldTrigger = false;\n          let currentValue = 0;\n          let severity: 'low' | 'medium' | 'high' = 'medium';\n\n          switch (alert.conditionType) {\n            case 'score_above':\n              currentValue = score;\n              shouldTrigger = score > threshold;\n              severity = score > threshold + 20 ? 'high' : score > threshold + 10 ? 'medium' : 'low';\n              break;\n\n            case 'score_below':\n              currentValue = score;\n              shouldTrigger = score < threshold;\n              severity = score < threshold - 20 ? 'high' : score < threshold - 10 ? 'medium' : 'low';\n              break;\n\n            case 'rapid_change':\n              currentValue = Math.abs(trendPct);\n              shouldTrigger = Math.abs(trendPct) > threshold;\n              severity = Math.abs(trendPct) > threshold * 2 ? 'high' : 'medium';\n              break;\n\n            case 'volume_spike':\n              currentValue = volume;\n              shouldTrigger = volume > threshold;\n              severity = volume > threshold * 2 ? 'high' : 'medium';\n              break;\n          }\n\n          if (shouldTrigger) {\n            triggeredAlerts.push({\n              id: alert.id,\n              type: alert.conditionType,\n              severity,\n              message: `Alert \"${alert.name}\" triggered for ${symbolUpper}`,\n              threshold,\n              currentValue: parseFloat(currentValue.toFixed(2)),\n            });\n\n            // Update lastTriggered timestamp (in a real implementation)\n            // await db.update(sentimentAlerts)\n            //   .set({ lastTriggered: now })\n            //   .where(eq(sentimentAlerts.id, alert.id));\n          }\n        }\n\n        return triggeredAlerts;\n      } catch (error) {\n        logger.error('Error checking alerts', { error });\n        return [];\n      }\n    },\n  },\n\n  /**\n   * Generate sentiment report\n   */\n  'sentiment:generate_report': {\n    description: 'Generate comprehensive sentiment report',\n    async handler(input: { symbol?: string; period: 'daily' | 'weekly' | 'monthly' }) {\n      const symbols = input.symbol ? [input.symbol.toUpperCase()] : ['BTC', 'ETH', 'BNB'];\n\n      const reports = symbols.map((symbol) => ({\n        symbol,\n        sentiment: {\n          score: 0,\n          label: 'neutral' as const,\n          trend: 'stable' as const,\n        },\n        trending: [],\n        signals: { signal: 'neutral' as const, confidence: 0.5 },\n        generatedAt: new Date(),\n      }));\n\n      return {\n        period: input.period,\n        reports,\n        summary: `Generated ${reports.length} sentiment reports for ${input.period} period`,\n      };\n    },\n  },\n\n  /**\n   * Get service statistics\n   */\n  'sentiment:get_stats': {\n    description: 'Get sentiment service statistics',\n    async handler(_input: Record<string, never>) {\n      return {\n        sentiment: hybridSentimentService?.getUsageStats(),\n        trending: trendingTopicsService.getStats(),\n        timestamp: new Date().toISOString(),\n      };\n    },\n  },\n};\n\n/**\n * Sentiment Agent Integration Service\n */\nexport class SentimentAgentIntegrationService {\n  /**\n   * Register sentiment actions with Marketing Agent\n   */\n  static async registerActions(agentId: string, tenantId: string): Promise<void> {\n    try {\n      logger.info('Registering sentiment actions with Marketing Agent', {\n        agentId,\n        tenantId,\n      });\n\n      for (const [actionName, action] of Object.entries(SentimentAgentActions)) {\n        logger.debug('Registering action', {\n          actionName,\n          description: action.description,\n        });\n\n        // Note: Actual registration would happen via AgentService\n        // For now, just log the registration\n      }\n\n      logger.info('Sentiment actions registered successfully', {\n        agentId,\n        actionCount: Object.keys(SentimentAgentActions).length,\n      });\n    } catch (error) {\n      logger.error('Failed to register sentiment actions', {\n        agentId,\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute sentiment action\n   */\n  static async executeAction(\n    agentId: string,\n    tenantId: string,\n    actionRequest: AgentActionRequest\n  ): Promise<any> {\n    const startTime = Date.now();\n\n    try {\n      logger.info('Executing sentiment action', {\n        agentId,\n        actionName: actionRequest.actionName,\n      });\n\n      // Get action handler\n      const action = SentimentAgentActions[actionRequest.actionName as keyof typeof SentimentAgentActions];\n\n      if (!action) {\n        throw new Error(`Unknown action: ${actionRequest.actionName}`);\n      }\n\n      // Execute action\n      const result = await action.handler((actionRequest.input || {}) as any);\n\n      const executionTime = Date.now() - startTime;\n\n      logger.info('Sentiment action executed successfully', {\n        agentId,\n        actionName: actionRequest.actionName,\n        executionTime,\n      });\n\n      return {\n        success: true,\n        result,\n        executionTime,\n        timestamp: new Date(),\n      };\n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n\n      logger.error('Sentiment action execution failed', {\n        agentId,\n        actionName: actionRequest.actionName,\n        executionTime,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        executionTime,\n        timestamp: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Handle sentiment event and notify agent\n   */\n  static async handleSentimentEvent(\n    agentId: string,\n    tenantId: string,\n    event: {\n      type: 'sentiment_update' | 'trending_update' | 'news_update' | 'signal_update';\n      data: any;\n    }\n  ): Promise<any> {\n    try {\n      logger.info('Handling sentiment event for agent', {\n        agentId,\n        eventType: event.type,\n      });\n\n      // Build prompt for AI analysis\n      const prompt = this.buildEventPrompt(event);\n\n      // Query agent with event data\n      const analysis = await AgentService.query(agentId, tenantId, {\n        prompt,\n        includeHistory: true,\n        maxHistoryMessages: 5,\n      });\n\n      logger.info('Sentiment event analyzed by agent', {\n        agentId,\n        eventType: event.type,\n        responseLength: analysis.response.length,\n      });\n\n      // Check if action is recommended\n      if (this.shouldTakeAction(analysis.response)) {\n        logger.info('Action recommended by agent', { agentId });\n\n        // Execute recommended action\n        await this.executeRecommendedAction(agentId, tenantId, event, analysis.response);\n      }\n\n      return analysis;\n    } catch (error) {\n      logger.error('Failed to handle sentiment event', {\n        agentId,\n        eventType: event.type,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Build prompt for event analysis\n   */\n  private static buildEventPrompt(event: {\n    type: string;\n    data: any;\n  }): string {\n    return `New ${event.type} received:\n\n${JSON.stringify(event.data, null, 2)}\n\nAnalyze this event and determine:\n1. Is this significant enough to alert CEO or Trading Ops Agent?\n2. Does this represent a trading opportunity?\n3. Should I adjust marketing strategy?\n4. Any risks or red flags?\n5. What action should I take, if any?\n\nProvide a concise analysis with clear recommendations.`;\n  }\n\n  /**\n   * Check if agent recommends taking action\n   */\n  private static shouldTakeAction(response: string): boolean {\n    const actionKeywords = [\n      'should alert',\n      'recommend',\n      'take action',\n      'notify',\n      'urgent',\n      'opportunity',\n      'risk',\n    ];\n\n    const lowerResponse = response.toLowerCase();\n    return actionKeywords.some((keyword) => lowerResponse.includes(keyword));\n  }\n\n  /**\n   * Execute action recommended by agent\n   */\n  private static async executeRecommendedAction(\n    agentId: string,\n    tenantId: string,\n    event: { type: string; data: any },\n    recommendation: string\n  ): Promise<void> {\n    try {\n      logger.info('Executing recommended action', {\n        agentId,\n        eventType: event.type,\n      });\n\n      const lowerRec = recommendation.toLowerCase();\n\n      // Check if should alert CEO or Trading Agent\n      if (lowerRec.includes('alert ceo') || lowerRec.includes('notify ceo')) {\n        logger.info('Creating alert for CEO', {\n          agentId,\n          eventType: event.type,\n          data: event.data,\n        });\n        // In production: Send notification to CEO agent\n        // await AgentService.notify('ceo-agent-id', tenantId, {\n        //   type: 'sentiment_alert',\n        //   priority: 'high',\n        //   data: event.data,\n        //   recommendation,\n        // });\n      }\n\n      // Check if should alert Trading Ops\n      if (lowerRec.includes('trading') || lowerRec.includes('opportunity')) {\n        logger.info('Creating alert for Trading Operations', {\n          agentId,\n          eventType: event.type,\n          data: event.data,\n        });\n        // In production: Send to trading agent\n        // await AgentService.notify('trading-agent-id', tenantId, {\n        //   type: 'trading_signal',\n        //   data: event.data,\n        //   recommendation,\n        // });\n      }\n\n      // Check if should create system alert\n      if (lowerRec.includes('urgent') || lowerRec.includes('risk')) {\n        logger.warn('URGENT: Creating system alert', {\n          agentId,\n          eventType: event.type,\n          recommendation: recommendation.substring(0, 200),\n        });\n        // In production: Create system-wide alert\n        // await NotificationService.createSystemAlert({\n        //   severity: 'high',\n        //   title: `Sentiment Alert: ${event.type}`,\n        //   message: recommendation,\n        //   data: event.data,\n        // });\n      }\n\n      // Check if should adjust marketing strategy\n      if (lowerRec.includes('marketing') || lowerRec.includes('campaign')) {\n        logger.info('Adjusting marketing strategy based on sentiment', {\n          agentId,\n          eventType: event.type,\n        });\n        // In production: Trigger marketing adjustments\n        // await MarketingService.adjustStrategy({\n        //   sentimentData: event.data,\n        //   recommendation,\n        // });\n      }\n\n      // Check if should generate report\n      if (lowerRec.includes('report') || lowerRec.includes('analysis')) {\n        logger.info('Generating sentiment analysis report', {\n          agentId,\n          eventType: event.type,\n        });\n        // In production: Generate and store report\n        // await ReportService.generateSentimentReport({\n        //   eventType: event.type,\n        //   data: event.data,\n        //   analysis: recommendation,\n        //   generatedBy: agentId,\n        // });\n      }\n\n      // Log the action for audit trail\n      logger.info('Action execution completed', {\n        agentId,\n        eventType: event.type,\n        actionsTaken: {\n          ceoAlert: lowerRec.includes('alert ceo'),\n          tradingAlert: lowerRec.includes('trading'),\n          systemAlert: lowerRec.includes('urgent'),\n          marketingAdjustment: lowerRec.includes('marketing'),\n          reportGeneration: lowerRec.includes('report'),\n        },\n      });\n    } catch (error) {\n      logger.error('Failed to execute recommended action', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  /**\n   * Get Marketing Agent for tenant\n   */\n  static async getMarketingAgent(tenantId: string): Promise<any> {\n    try {\n      const agents = await AgentService.listAgents(tenantId, {\n        agentType: 'marketing',\n      });\n\n      if (agents.length === 0) {\n        logger.warn('No Marketing Agent found for tenant', { tenantId });\n        return null;\n      }\n\n      return agents[0];\n    } catch (error) {\n      logger.error('Failed to get Marketing Agent', {\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Initialize integration for tenant\n   */\n  static async initialize(tenantId: string): Promise<void> {\n    try {\n      logger.info('Initializing Sentiment-Agent integration', { tenantId });\n\n      // Get Marketing Agent\n      const marketingAgent = await this.getMarketingAgent(tenantId);\n\n      if (!marketingAgent) {\n        logger.warn('Cannot initialize integration: Marketing Agent not found', {\n          tenantId,\n        });\n        return;\n      }\n\n      // Register actions\n      await this.registerActions(marketingAgent.id, tenantId);\n\n      logger.info('Sentiment-Agent integration initialized', {\n        tenantId,\n        agentId: marketingAgent.id,\n      });\n    } catch (error) {\n      logger.error('Failed to initialize Sentiment-Agent integration', {\n        tenantId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n}\n\n// Export singleton for convenience\nexport const sentimentAgentIntegration = {\n  registerActions: SentimentAgentIntegrationService.registerActions,\n  executeAction: SentimentAgentIntegrationService.executeAction,\n  handleEvent: SentimentAgentIntegrationService.handleSentimentEvent,\n  initialize: SentimentAgentIntegrationService.initialize,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/sources/cryptopanic.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/sources/reddit.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Comment' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RedditStreamConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reddit Service\n * Monitor Reddit posts and comments from crypto subreddits\n *\n * @module sentiment/services/sources/reddit\n */\n\nimport Snoowrap from 'snoowrap';\n\n// Types from snoowrap\ntype Submission = any;\ntype Comment = any;\nimport type { RedditMention, RedditStreamConfig } from '../../types/social.types';\n\n/**\n * Default crypto subreddits to monitor\n */\nconst DEFAULT_SUBREDDITS = [\n  'cryptocurrency',\n  'bitcoin',\n  'ethereum',\n  'cryptomarkets',\n  'cryptomoonshots',\n  'satoshistreetbets',\n  'ethtrader',\n  'bitcoinmarkets',\n  'defi',\n  'nft',\n];\n\n/**\n * Reddit Service Class\n */\nexport class RedditService {\n  private client: Snoowrap;\n  private pollingIntervals: Map<string, NodeJS.Timeout> = new Map();\n  private lastPostIds: Map<string, Set<string>> = new Map();\n\n  constructor(config: {\n    clientId: string;\n    clientSecret: string;\n    username: string;\n    password: string;\n    userAgent: string;\n  }) {\n    this.client = new Snoowrap({\n      userAgent: config.userAgent || 'BotCriptoFy/1.0',\n      clientId: config.clientId,\n      clientSecret: config.clientSecret,\n      username: config.username,\n      password: config.password,\n    });\n\n    // Configure request delay to respect rate limits\n    this.client.config({ requestDelay: 1000, warnings: false });\n  }\n\n  /**\n   * Get recent posts from subreddit\n   */\n  async getRecentPosts(subreddit: string, options?: {\n    limit?: number;\n    sort?: 'hot' | 'new' | 'rising' | 'top';\n    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';\n  }): Promise<RedditMention[]> {\n    try {\n      const sort = options?.sort || 'new';\n      const limit = options?.limit || 100;\n\n      let submissions: Submission[];\n\n      switch (sort) {\n        case 'hot':\n          submissions = await this.client.getSubreddit(subreddit).getHot({ limit });\n          break;\n        case 'new':\n          submissions = await this.client.getSubreddit(subreddit).getNew({ limit });\n          break;\n        case 'rising':\n          submissions = await this.client.getSubreddit(subreddit).getRising({ limit });\n          break;\n        case 'top':\n          submissions = await this.client.getSubreddit(subreddit).getTop({\n            limit,\n            time: options?.timeframe || 'day',\n          });\n          break;\n        default:\n          submissions = await this.client.getSubreddit(subreddit).getNew({ limit });\n      }\n\n      return submissions.map((post) => this.transformToRedditMention(post, subreddit));\n    } catch (error) {\n      console.error(`Error fetching posts from r/${subreddit}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search posts across all subreddits\n   */\n  async searchPosts(query: string, options?: {\n    subreddit?: string;\n    limit?: number;\n    sort?: 'relevance' | 'hot' | 'top' | 'new' | 'comments';\n    timeframe?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';\n  }): Promise<RedditMention[]> {\n    try {\n      const searchOptions = {\n        query,\n        subreddit: options?.subreddit,\n        limit: options?.limit || 100,\n        sort: options?.sort || 'new',\n        time: options?.timeframe || 'day',\n      };\n\n      const results = await this.client.search(searchOptions);\n\n      return results.map((post) => {\n        const subreddit = post.subreddit?.display_name || 'unknown';\n        return this.transformToRedditMention(post, subreddit);\n      });\n    } catch (error) {\n      console.error('Error searching Reddit:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search for crypto mentions\n   */\n  async searchCrypto(symbol: string, options?: {\n    subreddit?: string;\n    limit?: number;\n  }): Promise<RedditMention[]> {\n    const queries = [\n      symbol,\n      `$${symbol}`,\n      symbol === 'BTC' ? 'bitcoin' : '',\n      symbol === 'ETH' ? 'ethereum' : '',\n    ].filter(Boolean);\n\n    const query = queries.join(' OR ');\n\n    return this.searchPosts(query, {\n      subreddit: options?.subreddit || DEFAULT_SUBREDDITS.join('+'),\n      limit: options?.limit || 100,\n    });\n  }\n\n  /**\n   * Get post comments\n   */\n  getPostComments(postId: string, limit: number = 100): Promise<RedditMention[]> {\n    return Promise.resolve().then(async () => {\n      try {\n        const submission: any = await (this.client.getSubmission(postId) as Promise<any>);\n        await submission.expandReplies({ limit, depth: 1 });\n\n        const comments: RedditMention[] = [];\n\n        const processComment = (comment: any): void => {\n          if (comment && typeof comment === 'object') {\n            const mention = this.transformCommentToMention(comment);\n            if (mention) {\n              comments.push(mention);\n            }\n\n            // Process replies\n            if (comment.replies && Array.isArray(comment.replies)) {\n              comment.replies.forEach(processComment);\n            }\n          }\n        };\n\n        submission.comments.forEach(processComment);\n\n        return comments;\n      } catch (error) {\n        console.error(`Error fetching comments for post ${postId}:`, error);\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Start monitoring subreddits\n   */\n  startMonitoring(\n    subreddits: string[] = DEFAULT_SUBREDDITS,\n    onNewPost: (mention: RedditMention) => void,\n    pollInterval: number = 60000 // 1 minute\n  ): void {\n    subreddits.forEach((subreddit) => {\n      // Initialize last post IDs set\n      this.lastPostIds.set(subreddit, new Set());\n\n      // Clear existing interval\n      const existingInterval = this.pollingIntervals.get(subreddit);\n      if (existingInterval) {\n        clearInterval(existingInterval);\n      }\n\n      // Set up polling\n      const interval = setInterval(async () => {\n        try {\n          const posts = await this.getRecentPosts(subreddit, { limit: 25, sort: 'new' });\n          const lastIds = this.lastPostIds.get(subreddit)!;\n\n          // Filter new posts\n          const newPosts = posts.filter((post) => !lastIds.has(post.platformId));\n\n          // Update last IDs\n          posts.forEach((post) => lastIds.add(post.platformId));\n\n          // Keep only last 100 IDs\n          if (lastIds.size > 100) {\n            const idsArray = Array.from(lastIds);\n            this.lastPostIds.set(subreddit, new Set(idsArray.slice(-100)));\n          }\n\n          // Emit new posts\n          newPosts.forEach((post) => onNewPost(post));\n        } catch (error) {\n          console.error(`Error monitoring r/${subreddit}:`, error);\n        }\n      }, pollInterval);\n\n      this.pollingIntervals.set(subreddit, interval);\n\n      // Also fetch immediately\n      this.getRecentPosts(subreddit, { limit: 25, sort: 'new' })\n        .then((posts) => {\n          const lastIds = this.lastPostIds.get(subreddit)!;\n          posts.forEach((post) => {\n            lastIds.add(post.platformId);\n            onNewPost(post);\n          });\n        })\n        .catch((error) => {\n          console.error(`Error fetching initial posts from r/${subreddit}:`, error);\n        });\n    });\n  }\n\n  /**\n   * Stop monitoring all subreddits\n   */\n  stopMonitoring(): void {\n    this.pollingIntervals.forEach((interval) => clearInterval(interval));\n    this.pollingIntervals.clear();\n    this.lastPostIds.clear();\n  }\n\n  /**\n   * Stop monitoring specific subreddit\n   */\n  stopMonitoringSubreddit(subreddit: string): void {\n    const interval = this.pollingIntervals.get(subreddit);\n    if (interval) {\n      clearInterval(interval);\n      this.pollingIntervals.delete(subreddit);\n    }\n    this.lastPostIds.delete(subreddit);\n  }\n\n  /**\n   * Transform Reddit submission to RedditMention\n   */\n  private transformToRedditMention(post: Submission, subreddit: string): RedditMention {\n    // Extract symbols from title and text\n    const text = `${post.title} ${post.selftext || ''}`;\n    const symbols = this.extractSymbols(text);\n\n    // Determine post type\n    let postType: 'text' | 'link' | 'image' | 'video' = 'text';\n    if (post.is_video) {\n      postType = 'video';\n    } else if (post.post_hint === 'image' || post.url?.match(/\\.(jpg|jpeg|png|gif)$/i)) {\n      postType = 'image';\n    } else if (post.is_self) {\n      postType = 'text';\n    } else {\n      postType = 'link';\n    }\n\n    const redditMention: RedditMention = {\n      id: crypto.randomUUID(),\n      platform: 'reddit',\n      platformId: post.id,\n      postId: post.id,\n      subreddit,\n      author: post.author?.name || '[deleted]',\n      authorId: post.author?.id || 'deleted',\n      authorFollowers: undefined,\n      authorVerified: false,\n\n      // Content\n      text: text.substring(0, 2000), // Limit text length\n      url: `https://www.reddit.com${post.permalink}`,\n      language: 'en', // Reddit doesn't provide language detection\n\n      // Engagement\n      likes: post.ups || 0,\n      replies: post.num_comments || 0,\n      views: 0,\n      upvotes: post.ups || 0,\n      downvotes: post.downs || 0,\n      score: post.score || 0,\n\n      // Timestamps\n      createdAt: new Date((post.created_utc || 0) * 1000),\n      fetchedAt: new Date(),\n\n      // Extracted data\n      symbols,\n      hashtags: [],\n      mentions: [],\n\n      // Flags\n      isAnalyzed: false,\n      isInfluencer: false, // Reddit doesn't have follower counts on posts\n      isRetweet: false,\n      isReply: false,\n\n      // Reddit-specific\n      postType,\n      upvoteRatio: post.upvote_ratio || 0,\n      numComments: post.num_comments || 0,\n      distinguished: post.distinguished as any,\n      stickied: post.stickied || false,\n      over18: post.over_18 || false,\n      spoiler: post.spoiler || false,\n    };\n\n    return redditMention;\n  }\n\n  /**\n   * Transform Reddit comment to RedditMention\n   */\n  private transformCommentToMention(comment: any): RedditMention | null {\n    try {\n      const symbols = this.extractSymbols(comment.body || '');\n\n      const mention: RedditMention = {\n        id: crypto.randomUUID(),\n        platform: 'reddit',\n        platformId: comment.id,\n        postId: comment.link_id?.replace('t3_', '') || comment.id,\n        subreddit: comment.subreddit?.display_name || 'unknown',\n        author: comment.author?.name || '[deleted]',\n        authorId: comment.author?.id || 'deleted',\n        authorFollowers: undefined,\n        authorVerified: false,\n\n        // Content\n        text: comment.body || '',\n        url: `https://www.reddit.com${comment.permalink}`,\n        language: 'en',\n\n        // Engagement\n        likes: comment.ups || 0,\n        replies: 0, // Comments don't have reply count in API\n        views: 0,\n        upvotes: comment.ups || 0,\n        downvotes: comment.downs || 0,\n        score: comment.score || 0,\n\n        // Timestamps\n        createdAt: new Date((comment.created_utc || 0) * 1000),\n        fetchedAt: new Date(),\n\n        // Extracted data\n        symbols,\n        hashtags: [],\n        mentions: [],\n\n        // Flags\n        isAnalyzed: false,\n        isInfluencer: false,\n        isRetweet: false,\n        isReply: true, // Comments are always replies\n\n        // Reddit-specific\n        postType: 'text',\n        upvoteRatio: 0,\n        numComments: 0,\n        distinguished: comment.distinguished as any,\n        stickied: comment.stickied || false,\n        over18: false,\n        spoiler: false,\n      };\n\n      return mention;\n    } catch (error) {\n      console.error('Error transforming comment:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Extract crypto symbols from text\n   */\n  private extractSymbols(text: string): string[] {\n    const symbols = new Set<string>();\n\n    // Common crypto keywords\n    const cryptoMap: Record<string, string> = {\n      'bitcoin': 'BTC',\n      'btc': 'BTC',\n      'ethereum': 'ETH',\n      'eth': 'ETH',\n      'ether': 'ETH',\n      'binance': 'BNB',\n      'bnb': 'BNB',\n      'cardano': 'ADA',\n      'ada': 'ADA',\n      'solana': 'SOL',\n      'sol': 'SOL',\n      'ripple': 'XRP',\n      'xrp': 'XRP',\n      'dogecoin': 'DOGE',\n      'doge': 'DOGE',\n      'polkadot': 'DOT',\n      'dot': 'DOT',\n    };\n\n    // Check for keywords\n    const lowerText = text.toLowerCase();\n    Object.entries(cryptoMap).forEach(([keyword, symbol]) => {\n      if (lowerText.includes(keyword)) {\n        symbols.add(symbol);\n      }\n    });\n\n    // Check for $SYMBOL mentions\n    const cashtags = text.match(/\\$[A-Z]{2,10}/g);\n    if (cashtags) {\n      cashtags.forEach((tag) => {\n        symbols.add(tag.substring(1));\n      });\n    }\n\n    return Array.from(symbols);\n  }\n\n  /**\n   * Get monitoring status\n   */\n  getMonitoringStatus(): Array<{\n    subreddit: string;\n    isMonitoring: boolean;\n    lastPostCount: number;\n  }> {\n    const status: Array<{ subreddit: string; isMonitoring: boolean; lastPostCount: number }> = [];\n\n    this.pollingIntervals.forEach((_, subreddit) => {\n      status.push({\n        subreddit,\n        isMonitoring: true,\n        lastPostCount: this.lastPostIds.get(subreddit)?.size || 0,\n      });\n    });\n\n    return status;\n  }\n\n  /**\n   * Health check\n   */\n  healthCheck(): Promise<boolean> {\n    const checkHealthAsync = async (): Promise<boolean> => {\n      try {\n        const subreddit: any = this.client.getSubreddit('cryptocurrency');\n        await subreddit.fetch();\n        return true;\n      } catch {\n        return false;\n      }\n    };\n\n    return checkHealthAsync();\n  }\n}\n\n/**\n * Create Reddit service instance\n */\nexport function createRedditService(config: {\n  clientId: string;\n  clientSecret: string;\n  username: string;\n  password: string;\n  userAgent: string;\n}): RedditService {\n  return new RedditService(config);\n}\n\n/**\n * Singleton instance (requires credentials from env)\n */\nexport const redditService =\n  process.env.REDDIT_CLIENT_ID && process.env.REDDIT_CLIENT_SECRET\n    ? new RedditService({\n        clientId: process.env.REDDIT_CLIENT_ID,\n        clientSecret: process.env.REDDIT_CLIENT_SECRET,\n        username: process.env.REDDIT_USERNAME || '',\n        password: process.env.REDDIT_PASSWORD || '',\n        userAgent: 'BotCriptoFy/1.0 (Crypto Sentiment Analysis)',\n      })\n    : undefined;\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/sources/rss-feeds.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/sources/twitter.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TweetSearchRecentV2Paginator' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TwitterStreamConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Twitter/X Service\n * Real-time Twitter/X streaming and search\n *\n * @module sentiment/services/sources/twitter\n */\n\nimport { TwitterApi, ETwitterStreamEvent, TweetV2, TweetSearchRecentV2Paginator } from 'twitter-api-v2';\nimport type { TwitterMention, TwitterStreamConfig } from '../../types/social.types';\n\n/**\n * Twitter Service Class\n */\nexport class TwitterService {\n  private client: TwitterApi;\n  private stream?: AsyncGenerator<any>;\n  private isStreaming: boolean = false;\n  private reconnectAttempts: number = 0;\n  private readonly maxReconnectAttempts: number = 5;\n\n  constructor(bearerToken: string) {\n    this.client = new TwitterApi(bearerToken);\n  }\n\n  /**\n   * Search recent tweets\n   */\n  async searchTweets(query: string, options?: {\n    maxResults?: number;\n    startTime?: Date;\n    endTime?: Date;\n  }): Promise<TwitterMention[]> {\n    try {\n      const tweets = await this.client.v2.search(query, {\n        max_results: options?.maxResults || 100,\n        start_time: options?.startTime?.toISOString(),\n        end_time: options?.endTime?.toISOString(),\n        'tweet.fields': [\n          'created_at',\n          'public_metrics',\n          'author_id',\n          'conversation_id',\n          'lang',\n          'referenced_tweets',\n          'entities',\n        ],\n        'user.fields': ['username', 'name', 'verified', 'public_metrics'],\n        expansions: ['author_id', 'referenced_tweets.id'],\n      });\n\n      const mentions: TwitterMention[] = [];\n\n      for await (const tweet of tweets) {\n        const mention = this.transformToTwitterMention(tweet);\n        if (mention) {\n          mentions.push(mention);\n        }\n      }\n\n      return mentions;\n    } catch (error) {\n      console.error('Error searching tweets:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search tweets for specific crypto symbol\n   */\n  async searchCryptoTweets(symbol: string, options?: {\n    maxResults?: number;\n    includeRetweets?: boolean;\n  }): Promise<TwitterMention[]> {\n    // Build query for crypto mentions\n    const queries = [\n      `$${symbol}`,  // Cashtag\n      `#${symbol}`,  // Hashtag\n      symbol === 'BTC' ? 'bitcoin' : '',\n      symbol === 'ETH' ? 'ethereum' : '',\n    ].filter(Boolean);\n\n    const query = `(${queries.join(' OR ')}) lang:en ${!options?.includeRetweets ? '-is:retweet' : ''}`;\n\n    return this.searchTweets(query, {\n      maxResults: options?.maxResults || 100,\n    });\n  }\n\n  /**\n   * Get tweets from specific user\n   */\n  async getUserTweets(username: string, maxResults: number = 100): Promise<TwitterMention[]> {\n    try {\n      const user = await this.client.v2.userByUsername(username, {\n        'user.fields': ['public_metrics', 'verified'],\n      });\n\n      if (!user.data) {\n        throw new Error(`User not found: ${username}`);\n      }\n\n      const tweets = await this.client.v2.userTimeline(user.data.id, {\n        max_results: maxResults,\n        'tweet.fields': ['created_at', 'public_metrics', 'lang', 'entities'],\n      });\n\n      const mentions: TwitterMention[] = [];\n\n      for await (const tweet of tweets) {\n        const mention = this.transformToTwitterMention(tweet, user.data);\n        if (mention) {\n          mentions.push(mention);\n        }\n      }\n\n      return mentions;\n    } catch (error) {\n      console.error(`Error fetching tweets for user ${username}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start filtered stream\n   */\n  async startFilteredStream(\n    rules: Array<{ value: string; tag?: string }>,\n    onTweet: (mention: TwitterMention) => void,\n    onError?: (error: Error) => void\n  ): Promise<void> {\n    try {\n      // Delete existing rules\n      const existingRules = await this.client.v2.streamRules();\n      if (existingRules.data?.length) {\n        await this.client.v2.updateStreamRules({\n          delete: { ids: existingRules.data.map((rule) => rule.id) },\n        });\n      }\n\n      // Add new rules\n      await this.client.v2.updateStreamRules({\n        add: rules,\n      });\n\n      // Start streaming\n      const stream = await this.client.v2.searchStream({\n        'tweet.fields': ['created_at', 'public_metrics', 'author_id', 'lang', 'entities', 'referenced_tweets'],\n        'user.fields': ['username', 'name', 'verified', 'public_metrics'],\n        expansions: ['author_id', 'referenced_tweets.id'],\n      });\n\n      this.isStreaming = true;\n      this.reconnectAttempts = 0;\n\n      stream.on(ETwitterStreamEvent.Data, (tweet) => {\n        try {\n          const mention = this.transformToTwitterMention(tweet.data);\n          if (mention) {\n            onTweet(mention);\n          }\n        } catch (error) {\n          console.error('Error processing tweet:', error);\n        }\n      });\n\n      stream.on(ETwitterStreamEvent.DataError, (error) => {\n        console.error('Stream data error:', error);\n        if (onError) {\n          onError(new Error('Stream data error'));\n        }\n      });\n\n      stream.on(ETwitterStreamEvent.ConnectionError, (error) => {\n        console.error('Stream connection error:', error);\n        this.handleReconnect(rules, onTweet, onError);\n      });\n\n      stream.on(ETwitterStreamEvent.Error, (error: any) => {\n        console.error('Stream error:', error);\n        if (onError) {\n          onError(error instanceof Error ? error : new Error(String(error)));\n        }\n      });\n\n      stream.on(ETwitterStreamEvent.ConnectionClosed, () => {\n        console.log('Stream connection closed');\n        this.isStreaming = false;\n      });\n\n    } catch (error) {\n      console.error('Error starting filtered stream:', error);\n      if (onError) {\n        onError(error as Error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Handle reconnection after stream failure\n   */\n  private async handleReconnect(\n    rules: Array<{ value: string; tag?: string }>,\n    onTweet: (mention: TwitterMention) => void,\n    onError?: (error: Error) => void\n  ): Promise<void> {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      if (onError) {\n        onError(new Error('Max reconnection attempts reached'));\n      }\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 60000); // Exponential backoff, max 60s\n\n    console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n\n    setTimeout(() => {\n      this.startFilteredStream(rules, onTweet, onError);\n    }, delay);\n  }\n\n  /**\n   * Stop streaming\n   */\n  stopStream(): void {\n    this.isStreaming = false;\n    // The stream will close on next iteration\n  }\n\n  /**\n   * Transform Twitter API response to TwitterMention\n   */\n  private transformToTwitterMention(tweet: TweetV2, author?: any): TwitterMention | null {\n    try {\n      // Extract symbols and hashtags\n      const symbols: string[] = [];\n      const hashtags: string[] = [];\n      const mentions: string[] = [];\n\n      if (tweet.entities) {\n        // Cashtags ($BTC, $ETH)\n        if (tweet.entities.cashtags) {\n          tweet.entities.cashtags.forEach((tag) => {\n            symbols.push(tag.tag.toUpperCase());\n          });\n        }\n\n        // Hashtags\n        if (tweet.entities.hashtags) {\n          tweet.entities.hashtags.forEach((tag) => {\n            hashtags.push(`#${tag.tag}`);\n\n            // Map common hashtags to symbols\n            const hashtagUpper = tag.tag.toUpperCase();\n            if (['BITCOIN', 'BTC'].includes(hashtagUpper)) symbols.push('BTC');\n            if (['ETHEREUM', 'ETH'].includes(hashtagUpper)) symbols.push('ETH');\n            if (['CRYPTO', 'CRYPTOCURRENCY'].includes(hashtagUpper)) {\n              // Generic crypto hashtag - don't add specific symbol\n            } else if (hashtagUpper.length >= 2 && hashtagUpper.length <= 10) {\n              // Might be a symbol\n              symbols.push(hashtagUpper);\n            }\n          });\n        }\n\n        // Mentions\n        if (tweet.entities.mentions) {\n          tweet.entities.mentions.forEach((mention) => {\n            mentions.push(`@${mention.username}`);\n          });\n        }\n      }\n\n      // Get metrics\n      const metrics = tweet.public_metrics || {\n        retweet_count: 0,\n        reply_count: 0,\n        like_count: 0,\n        quote_count: 0,\n      };\n\n      // Determine if retweet or quote\n      const isRetweet = tweet.referenced_tweets?.some((ref) => ref.type === 'retweeted') || false;\n      const isQuote = tweet.referenced_tweets?.some((ref) => ref.type === 'quoted') || false;\n\n      const twitterMention: TwitterMention = {\n        id: crypto.randomUUID(),\n        platform: 'twitter',\n        platformId: tweet.id,\n        tweetId: tweet.id,\n        author: author?.username || tweet.author_id || 'unknown',\n        authorId: tweet.author_id || 'unknown',\n        authorFollowers: author?.public_metrics?.followers_count,\n        authorVerified: author?.verified || false,\n\n        // Content\n        text: tweet.text,\n        url: `https://twitter.com/i/web/status/${tweet.id}`,\n        language: tweet.lang,\n\n        // Engagement\n        likes: metrics.like_count || 0,\n        retweets: metrics.retweet_count,\n        replies: metrics.reply_count || 0,\n        views: 0,\n\n        // Timestamps\n        createdAt: tweet.created_at ? new Date(tweet.created_at) : new Date(),\n        fetchedAt: new Date(),\n\n        // Extracted data\n        symbols: Array.from(new Set(symbols)),\n        hashtags: Array.from(new Set(hashtags)),\n        mentions: Array.from(new Set(mentions)),\n\n        // Flags\n        isAnalyzed: false,\n        isInfluencer: (author?.public_metrics?.followers_count || 0) > 10000,\n        isVerified: author?.verified || false,\n        isRetweet,\n        isReply: tweet.referenced_tweets?.some((ref) => ref.type === 'replied_to') || false,\n\n        // Twitter-specific\n        conversationId: tweet.conversation_id,\n        isQuote,\n        retweetCount: metrics.retweet_count || 0,\n        quoteCount: metrics.quote_count || 0,\n        replyCount: metrics.reply_count || 0,\n        likeCount: metrics.like_count || 0,\n        bookmarkCount: 0,\n      };\n\n      return twitterMention;\n    } catch (error) {\n      console.error('Error transforming tweet:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get stream status\n   */\n  getStreamStatus(): { isStreaming: boolean; reconnectAttempts: number } {\n    return {\n      isStreaming: this.isStreaming,\n      reconnectAttempts: this.reconnectAttempts,\n    };\n  }\n\n  /**\n   * Get current stream rules\n   */\n  async getStreamRules(): Promise<Array<{ id: string; value: string; tag?: string }>> {\n    try {\n      const rules = await this.client.v2.streamRules();\n      return rules.data || [];\n    } catch (error) {\n      console.error('Error fetching stream rules:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      await this.client.v2.me();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Create Twitter service instance\n */\nexport function createTwitterService(bearerToken: string): TwitterService {\n  return new TwitterService(bearerToken);\n}\n\n/**\n * Singleton instance (requires bearer token from env)\n */\nexport const twitterService = process.env.TWITTER_BEARER_TOKEN\n  ? new TwitterService(process.env.TWITTER_BEARER_TOKEN)\n  : undefined;\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/services/streaming/websocket-streaming.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SentimentAnalysisResult' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebSocket Streaming Service\n * Real-time sentiment updates via WebSocket\n *\n * Features:\n * - Multi-channel subscriptions (sentiment, trending, news, social, alerts)\n * - Client connection management\n * - Heartbeat/ping-pong\n * - Throttling and rate limiting\n * - Message batching for efficiency\n *\n * @module sentiment/services/streaming/websocket-streaming\n */\n\nimport type { AggregatedSentiment, SentimentAnalysisResult } from '../../types/sentiment.types';\nimport type { NewsArticle } from '../../types/news.types';\nimport type { SocialMention, TrendingTopic } from '../../types/social.types';\nimport type { SentimentPriceSignal } from '../analyzer/price-correlation.service';\n\n/**\n * WebSocket Message Types\n */\nexport type WSMessageType =\n  | 'subscribe'\n  | 'unsubscribe'\n  | 'ping'\n  | 'pong'\n  | 'sentiment_update'\n  | 'trending_update'\n  | 'news_update'\n  | 'social_update'\n  | 'signal_update'\n  | 'alert'\n  | 'error'\n  | 'success';\n\n/**\n * Channel Types\n */\nexport type ChannelType =\n  | 'sentiment' // Aggregated sentiment updates\n  | 'sentiment:symbol' // Sentiment for specific symbol (e.g., sentiment:BTC)\n  | 'trending' // Trending topics\n  | 'news' // News articles\n  | 'news:symbol' // News for specific symbol\n  | 'social' // Social mentions\n  | 'social:symbol' // Social for specific symbol\n  | 'signals' // Trading signals\n  | 'signals:symbol' // Signals for specific symbol\n  | 'alerts'; // User alerts\n\n/**\n * WebSocket Message\n */\nexport interface WSMessage {\n  type: WSMessageType;\n  channel?: string;\n  data?: any;\n  timestamp: number;\n}\n\n/**\n * Subscribe Message\n */\nexport interface SubscribeMessage extends WSMessage {\n  type: 'subscribe';\n  channel: string;\n}\n\n/**\n * Client Connection\n */\ninterface ClientConnection {\n  id: string;\n  ws: any; // WebSocket instance (Elysia WS)\n  subscriptions: Set<string>;\n  lastPing: Date;\n  lastPong: Date;\n  messageCount: number;\n  connectedAt: Date;\n  metadata?: {\n    userId?: string;\n    ip?: string;\n    userAgent?: string;\n  };\n}\n\n/**\n * Streaming Configuration\n */\nexport interface StreamingConfig {\n  /**\n   * Heartbeat interval (milliseconds)\n   * Default: 30000 (30 seconds)\n   */\n  heartbeatInterval: number;\n\n  /**\n   * Client timeout (milliseconds)\n   * Disconnect if no pong received\n   * Default: 60000 (60 seconds)\n   */\n  clientTimeout: number;\n\n  /**\n   * Max subscriptions per client\n   * Default: 50\n   */\n  maxSubscriptionsPerClient: number;\n\n  /**\n   * Message rate limit (messages per minute)\n   * Default: 100\n   */\n  messageRateLimit: number;\n\n  /**\n   * Batch updates (delay before sending)\n   * Default: 1000 (1 second)\n   */\n  batchDelay: number;\n\n  /**\n   * Max batch size\n   * Default: 10\n   */\n  maxBatchSize: number;\n}\n\n/**\n * Message Queue for batching\n */\ninterface MessageQueue {\n  channel: string;\n  messages: any[];\n  timeout?: NodeJS.Timeout;\n}\n\n/**\n * WebSocket Streaming Service\n */\nexport class WebSocketStreamingService {\n  private config: StreamingConfig;\n  private clients: Map<string, ClientConnection> = new Map();\n  private channelSubscribers: Map<string, Set<string>> = new Map(); // channel -> client IDs\n  private messageQueues: Map<string, MessageQueue> = new Map();\n  private heartbeatInterval?: NodeJS.Timeout;\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(config?: Partial<StreamingConfig>) {\n    this.config = {\n      heartbeatInterval: config?.heartbeatInterval || 30000,\n      clientTimeout: config?.clientTimeout || 60000,\n      maxSubscriptionsPerClient: config?.maxSubscriptionsPerClient || 50,\n      messageRateLimit: config?.messageRateLimit || 100,\n      batchDelay: config?.batchDelay || 1000,\n      maxBatchSize: config?.maxBatchSize || 10,\n    };\n\n    // Start heartbeat\n    this.startHeartbeat();\n\n    // Start cleanup\n    this.startCleanup();\n  }\n\n  /**\n   * Handle new client connection\n   */\n  onConnect(ws: any, clientId: string, metadata?: ClientConnection['metadata']): void {\n    const client: ClientConnection = {\n      id: clientId,\n      ws,\n      subscriptions: new Set(),\n      lastPing: new Date(),\n      lastPong: new Date(),\n      messageCount: 0,\n      connectedAt: new Date(),\n      metadata,\n    };\n\n    this.clients.set(clientId, client);\n\n    // Send welcome message\n    this.sendToClient(clientId, {\n      type: 'success',\n      data: {\n        message: 'Connected to sentiment stream',\n        clientId,\n        availableChannels: this.getAvailableChannels(),\n      },\n      timestamp: Date.now(),\n    });\n\n    console.log(`[WebSocket] Client connected: ${clientId} (Total: ${this.clients.size})`);\n  }\n\n  /**\n   * Handle client disconnection\n   */\n  onDisconnect(clientId: string): void {\n    const client = this.clients.get(clientId);\n\n    if (client) {\n      // Unsubscribe from all channels\n      client.subscriptions.forEach((channel) => {\n        this.unsubscribeFromChannel(clientId, channel);\n      });\n\n      this.clients.delete(clientId);\n      console.log(`[WebSocket] Client disconnected: ${clientId} (Total: ${this.clients.size})`);\n    }\n  }\n\n  /**\n   * Handle incoming message from client\n   */\n  onMessage(clientId: string, message: WSMessage): void {\n    const client = this.clients.get(clientId);\n\n    if (!client) {\n      console.error(`[WebSocket] Client not found: ${clientId}`);\n      return;\n    }\n\n    // Update message count (for rate limiting)\n    client.messageCount++;\n\n    // Check rate limit\n    if (!this.checkRateLimit(client)) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        data: { message: 'Rate limit exceeded' },\n        timestamp: Date.now(),\n      });\n      return;\n    }\n\n    // Handle message type\n    switch (message.type) {\n      case 'subscribe':\n        this.handleSubscribe(clientId, message as SubscribeMessage);\n        break;\n\n      case 'unsubscribe':\n        this.handleUnsubscribe(clientId, message);\n        break;\n\n      case 'ping':\n        this.handlePing(clientId);\n        break;\n\n      case 'pong':\n        this.handlePong(clientId);\n        break;\n\n      default:\n        this.sendToClient(clientId, {\n          type: 'error',\n          data: { message: `Unknown message type: ${message.type}` },\n          timestamp: Date.now(),\n        });\n    }\n  }\n\n  /**\n   * Handle subscribe request\n   */\n  private handleSubscribe(clientId: string, message: SubscribeMessage): void {\n    const client = this.clients.get(clientId);\n\n    if (!client) return;\n\n    const { channel } = message;\n\n    // Validate channel\n    if (!this.isValidChannel(channel)) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        data: { message: `Invalid channel: ${channel}` },\n        timestamp: Date.now(),\n      });\n      return;\n    }\n\n    // Check max subscriptions\n    if (client.subscriptions.size >= this.config.maxSubscriptionsPerClient) {\n      this.sendToClient(clientId, {\n        type: 'error',\n        data: { message: 'Max subscriptions reached' },\n        timestamp: Date.now(),\n      });\n      return;\n    }\n\n    // Subscribe\n    this.subscribeToChannel(clientId, channel);\n\n    this.sendToClient(clientId, {\n      type: 'success',\n      data: {\n        message: `Subscribed to ${channel}`,\n        subscriptions: Array.from(client.subscriptions),\n      },\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Handle unsubscribe request\n   */\n  private handleUnsubscribe(clientId: string, message: WSMessage): void {\n    const client = this.clients.get(clientId);\n\n    if (!client || !message.channel) return;\n\n    this.unsubscribeFromChannel(clientId, message.channel);\n\n    this.sendToClient(clientId, {\n      type: 'success',\n      data: {\n        message: `Unsubscribed from ${message.channel}`,\n        subscriptions: Array.from(client.subscriptions),\n      },\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Handle ping from client\n   */\n  private handlePing(clientId: string): void {\n    const client = this.clients.get(clientId);\n\n    if (client) {\n      client.lastPing = new Date();\n      this.sendToClient(clientId, {\n        type: 'pong',\n        timestamp: Date.now(),\n      });\n    }\n  }\n\n  /**\n   * Handle pong from client\n   */\n  private handlePong(clientId: string): void {\n    const client = this.clients.get(clientId);\n\n    if (client) {\n      client.lastPong = new Date();\n    }\n  }\n\n  /**\n   * Subscribe client to channel\n   */\n  private subscribeToChannel(clientId: string, channel: string): void {\n    const client = this.clients.get(clientId);\n\n    if (!client) return;\n\n    client.subscriptions.add(channel);\n\n    if (!this.channelSubscribers.has(channel)) {\n      this.channelSubscribers.set(channel, new Set());\n    }\n\n    this.channelSubscribers.get(channel)!.add(clientId);\n  }\n\n  /**\n   * Unsubscribe client from channel\n   */\n  private unsubscribeFromChannel(clientId: string, channel: string): void {\n    const client = this.clients.get(clientId);\n\n    if (client) {\n      client.subscriptions.delete(channel);\n    }\n\n    const subscribers = this.channelSubscribers.get(channel);\n    if (subscribers) {\n      subscribers.delete(clientId);\n\n      // Clean up empty channel\n      if (subscribers.size === 0) {\n        this.channelSubscribers.delete(channel);\n      }\n    }\n  }\n\n  /**\n   * Broadcast sentiment update\n   */\n  broadcastSentimentUpdate(sentiment: AggregatedSentiment): void {\n    const channels = ['sentiment', `sentiment:${sentiment.symbol}`];\n\n    channels.forEach((channel) => {\n      this.broadcastToChannel(channel, {\n        type: 'sentiment_update',\n        channel,\n        data: sentiment,\n        timestamp: Date.now(),\n      });\n    });\n  }\n\n  /**\n   * Broadcast trending topics update\n   */\n  broadcastTrendingUpdate(trending: TrendingTopic[]): void {\n    this.broadcastToChannel('trending', {\n      type: 'trending_update',\n      channel: 'trending',\n      data: trending,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Broadcast news article\n   */\n  broadcastNewsUpdate(article: NewsArticle): void {\n    const channels = ['news', ...article.symbols.map((s) => `news:${s}`)];\n\n    channels.forEach((channel) => {\n      this.broadcastToChannel(channel, {\n        type: 'news_update',\n        channel,\n        data: article,\n        timestamp: Date.now(),\n      });\n    });\n  }\n\n  /**\n   * Broadcast social mention\n   */\n  broadcastSocialUpdate(mention: SocialMention): void {\n    const channels = ['social', ...mention.symbols.map((s) => `social:${s}`)];\n\n    channels.forEach((channel) => {\n      this.broadcastToChannel(channel, {\n        type: 'social_update',\n        channel,\n        data: mention,\n        timestamp: Date.now(),\n      });\n    });\n  }\n\n  /**\n   * Broadcast trading signal\n   */\n  broadcastSignalUpdate(signal: SentimentPriceSignal): void {\n    const channels = ['signals', `signals:${signal.symbol}`];\n\n    channels.forEach((channel) => {\n      this.broadcastToChannel(channel, {\n        type: 'signal_update',\n        channel,\n        data: signal,\n        timestamp: Date.now(),\n      });\n    });\n  }\n\n  /**\n   * Broadcast to channel (with batching)\n   */\n  private broadcastToChannel(channel: string, message: WSMessage): void {\n    // Check if batching is enabled\n    if (this.config.batchDelay > 0) {\n      this.addToQueue(channel, message);\n    } else {\n      this.sendToChannel(channel, message);\n    }\n  }\n\n  /**\n   * Add message to batch queue\n   */\n  private addToQueue(channel: string, message: WSMessage): void {\n    if (!this.messageQueues.has(channel)) {\n      this.messageQueues.set(channel, {\n        channel,\n        messages: [],\n      });\n    }\n\n    const queue = this.messageQueues.get(channel)!;\n    queue.messages.push(message);\n\n    // Clear existing timeout\n    if (queue.timeout) {\n      clearTimeout(queue.timeout);\n    }\n\n    // Send if batch is full\n    if (queue.messages.length >= this.config.maxBatchSize) {\n      this.flushQueue(channel);\n    } else {\n      // Set timeout to flush\n      queue.timeout = setTimeout(() => {\n        this.flushQueue(channel);\n      }, this.config.batchDelay);\n    }\n  }\n\n  /**\n   * Flush message queue\n   */\n  private flushQueue(channel: string): void {\n    const queue = this.messageQueues.get(channel);\n\n    if (!queue || queue.messages.length === 0) return;\n\n    // Send batch\n    if (queue.messages.length === 1) {\n      this.sendToChannel(channel, queue.messages[0]);\n    } else {\n      // Send as batch\n      this.sendToChannel(channel, {\n        type: queue.messages[0].type,\n        channel,\n        data: queue.messages.map((m) => m.data),\n        timestamp: Date.now(),\n      });\n    }\n\n    // Clear queue\n    queue.messages = [];\n    if (queue.timeout) {\n      clearTimeout(queue.timeout);\n      queue.timeout = undefined;\n    }\n  }\n\n  /**\n   * Send message to channel subscribers\n   */\n  private sendToChannel(channel: string, message: WSMessage): void {\n    const subscribers = this.channelSubscribers.get(channel);\n\n    if (!subscribers || subscribers.size === 0) return;\n\n    subscribers.forEach((clientId) => {\n      this.sendToClient(clientId, message);\n    });\n  }\n\n  /**\n   * Send message to specific client\n   */\n  private sendToClient(clientId: string, message: WSMessage): void {\n    const client = this.clients.get(clientId);\n\n    if (!client) return;\n\n    try {\n      client.ws.send(JSON.stringify(message));\n    } catch (error) {\n      console.error(`[WebSocket] Error sending to client ${clientId}:`, error);\n      this.onDisconnect(clientId);\n    }\n  }\n\n  /**\n   * Check rate limit for client\n   */\n  private checkRateLimit(client: ClientConnection): boolean {\n    // Reset counter every minute\n    const now = Date.now();\n    const connectedTime = now - client.connectedAt.getTime();\n    const minutes = connectedTime / 60000;\n\n    if (minutes < 1) {\n      return client.messageCount <= this.config.messageRateLimit;\n    }\n\n    // Reset counter\n    client.messageCount = 0;\n    client.connectedAt = new Date();\n    return true;\n  }\n\n  /**\n   * Validate channel name\n   */\n  private isValidChannel(channel: string): boolean {\n    const validPrefixes = [\n      'sentiment',\n      'trending',\n      'news',\n      'social',\n      'signals',\n      'alerts',\n    ];\n\n    return validPrefixes.some((prefix) => channel === prefix || channel.startsWith(`${prefix}:`));\n  }\n\n  /**\n   * Get available channels\n   */\n  private getAvailableChannels(): string[] {\n    return [\n      'sentiment',\n      'sentiment:{symbol}',\n      'trending',\n      'news',\n      'news:{symbol}',\n      'social',\n      'social:{symbol}',\n      'signals',\n      'signals:{symbol}',\n      'alerts',\n    ];\n  }\n\n  /**\n   * Start heartbeat\n   */\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      this.clients.forEach((client, clientId) => {\n        // Check if client is alive\n        const timeSinceLastPong = Date.now() - client.lastPong.getTime();\n\n        if (timeSinceLastPong > this.config.clientTimeout) {\n          console.log(`[WebSocket] Client timeout: ${clientId}`);\n          this.onDisconnect(clientId);\n          return;\n        }\n\n        // Send ping\n        this.sendToClient(clientId, {\n          type: 'ping',\n          timestamp: Date.now(),\n        });\n      });\n    }, this.config.heartbeatInterval);\n  }\n\n  /**\n   * Start cleanup\n   */\n  private startCleanup(): void {\n    this.cleanupInterval = setInterval(() => {\n      // Flush all queues\n      this.messageQueues.forEach((_, channel) => {\n        this.flushQueue(channel);\n      });\n\n      // Log stats\n      console.log(`[WebSocket] Stats: ${this.clients.size} clients, ${this.channelSubscribers.size} channels`);\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats(): {\n    clients: number;\n    channels: number;\n    totalSubscriptions: number;\n    queuedMessages: number;\n  } {\n    let totalSubscriptions = 0;\n    this.clients.forEach((client) => {\n      totalSubscriptions += client.subscriptions.size;\n    });\n\n    let queuedMessages = 0;\n    this.messageQueues.forEach((queue) => {\n      queuedMessages += queue.messages.length;\n    });\n\n    return {\n      clients: this.clients.size,\n      channels: this.channelSubscribers.size,\n      totalSubscriptions,\n      queuedMessages,\n    };\n  }\n\n  /**\n   * Get client info\n   */\n  getClientInfo(clientId: string): ClientConnection | undefined {\n    return this.clients.get(clientId);\n  }\n\n  /**\n   * Get all clients\n   */\n  getClients(): ClientConnection[] {\n    return Array.from(this.clients.values());\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<StreamingConfig>): void {\n    this.config = { ...this.config, ...config };\n\n    // Restart heartbeat if interval changed\n    if (config.heartbeatInterval) {\n      if (this.heartbeatInterval) {\n        clearInterval(this.heartbeatInterval);\n      }\n      this.startHeartbeat();\n    }\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): StreamingConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Shutdown\n   */\n  shutdown(): void {\n    // Clear intervals\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    // Disconnect all clients\n    this.clients.forEach((_, clientId) => {\n      this.onDisconnect(clientId);\n    });\n\n    console.log('[WebSocket] Service shutdown complete');\n  }\n}\n\n/**\n * Create WebSocket Streaming Service\n */\nexport function createWebSocketStreamingService(config?: Partial<StreamingConfig>): WebSocketStreamingService {\n  return new WebSocketStreamingService(config);\n}\n\n/**\n * Singleton instance\n */\nexport const websocketStreamingService = new WebSocketStreamingService({\n  heartbeatInterval: parseInt(process.env.WS_HEARTBEAT_INTERVAL || '30000', 10),\n  clientTimeout: parseInt(process.env.WS_CLIENT_TIMEOUT || '60000', 10),\n  maxSubscriptionsPerClient: parseInt(process.env.WS_MAX_SUBSCRIPTIONS || '50', 10),\n  messageRateLimit: parseInt(process.env.WS_MESSAGE_RATE_LIMIT || '100', 10),\n  batchDelay: parseInt(process.env.WS_BATCH_DELAY || '1000', 10),\n  maxBatchSize: parseInt(process.env.WS_MAX_BATCH_SIZE || '10', 10),\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/types/news.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/types/sentiment.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/types/social.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/sentiment/workflows/sentiment-monitoring.workflow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/routes/analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/routes/copy.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/routes/leaderboard.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/routes/traders.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/schema/social.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/copy-trading.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/feed.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/follow.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/leaderboard.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/performance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/signal.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/services/trader.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/types/social.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/utils/copy-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/utils/leaderboard-ranker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/utils/performance-tracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/social-trading/utils/risk-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/engine/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/engine/strategy-runner.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'marketData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":195,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":195,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Strategy Runner Tests\n * Comprehensive test suite for strategy runner engine\n */\n\nimport { describe, test, expect, beforeEach } from 'bun:test';\nimport { StrategyRunner } from './strategy-runner';\nimport type { TradingStrategy } from '../types/strategies.types';\nimport type { MarketDataPoint } from './strategy-runner.types';\n\n// Test data generators\nconst generateMarketData = (count: number, startPrice = 50000): MarketDataPoint[] => {\n  const data: MarketDataPoint[] = [];\n  let price = startPrice;\n\n  for (let i = 0; i < count; i++) {\n    const change = (Math.random() - 0.5) * 1000;\n    price += change;\n\n    data.push({\n      timestamp: new Date(Date.now() - (count - i) * 3600000), // 1 hour intervals\n      open: price - Math.random() * 100,\n      high: price + Math.random() * 200,\n      low: price - Math.random() * 200,\n      close: price,\n      volume: Math.random() * 1000000,\n    });\n  }\n\n  return data;\n};\n\nconst createTestStrategy = (overrides?: Partial<TradingStrategy>): TradingStrategy => ({\n  id: 'strategy-1',\n  userId: 'user-1',\n  tenantId: 'tenant-1',\n  name: 'Test Strategy',\n  description: 'Test strategy description',\n  version: '1.0.0',\n  exchangeId: 'binance',\n  symbol: 'BTC/USDT',\n  timeframe: '1h',\n  type: 'trend_following',\n  indicators: [\n    {\n      type: 'rsi',\n      parameters: { period: 14 },\n      enabled: true,\n    },\n    {\n      type: 'sma',\n      parameters: { period: 20 },\n      enabled: true,\n    },\n  ],\n  conditions: [\n    {\n      type: 'entry',\n      logic: 'AND',\n      rules: [\n        { indicator: 'rsi', operator: '<', value: 30 },\n        { indicator: 'sma', operator: '>', value: 50000 },\n      ],\n    },\n  ],\n  status: 'active',\n  isPublic: false,\n  totalTrades: 0,\n  winningTrades: 0,\n  losingTrades: 0,\n  totalPnl: 0,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  ...overrides,\n});\n\ndescribe('StrategyRunner - Indicator Calculation', () => {\n  let runner: StrategyRunner;\n  let strategy: TradingStrategy;\n  let marketData: MarketDataPoint[];\n\n  beforeEach(() => {\n    runner = new StrategyRunner();\n    strategy = createTestStrategy();\n    marketData = generateMarketData(100);\n  });\n\n  test('should calculate RSI indicator', async () => {\n    const indicators = await runner.calculateIndicators(strategy, marketData);\n    const rsi = indicators.find((i) => i.type === 'rsi');\n\n    expect(rsi).toBeDefined();\n    expect(rsi?.value).toBeGreaterThanOrEqual(0);\n    expect(rsi?.value).toBeLessThanOrEqual(100);\n  });\n\n  test('should calculate SMA indicator', async () => {\n    const indicators = await runner.calculateIndicators(strategy, marketData);\n    const sma = indicators.find((i) => i.type === 'sma');\n\n    expect(sma).toBeDefined();\n    expect(typeof sma?.value).toBe('number');\n  });\n\n  test('should calculate EMA indicator', async () => {\n    const strategyWithEMA = createTestStrategy({\n      indicators: [{ type: 'ema', parameters: { period: 20 }, enabled: true }],\n    });\n\n    const indicators = await runner.calculateIndicators(strategyWithEMA, marketData);\n    const ema = indicators.find((i) => i.type === 'ema');\n\n    expect(ema).toBeDefined();\n    expect(typeof ema?.value).toBe('number');\n  });\n\n  test('should calculate MACD indicator', async () => {\n    const strategyWithMACD = createTestStrategy({\n      indicators: [\n        {\n          type: 'macd',\n          parameters: { fastPeriod: 12, slowPeriod: 26, signalPeriod: 9 },\n          enabled: true,\n        },\n      ],\n    });\n\n    const indicators = await runner.calculateIndicators(strategyWithMACD, marketData);\n    const macd = indicators.find((i) => i.type === 'macd');\n\n    expect(macd).toBeDefined();\n    expect(macd?.value).toHaveProperty('macd');\n    expect(macd?.value).toHaveProperty('signal');\n    expect(macd?.value).toHaveProperty('histogram');\n  });\n\n  test('should calculate Bollinger Bands', async () => {\n    const strategyWithBB = createTestStrategy({\n      indicators: [\n        {\n          type: 'bollinger_bands',\n          parameters: { period: 20, stdDevMultiplier: 2 },\n          enabled: true,\n        },\n      ],\n    });\n\n    const indicators = await runner.calculateIndicators(strategyWithBB, marketData);\n    const bb = indicators.find((i) => i.type === 'bollinger_bands');\n\n    expect(bb).toBeDefined();\n    expect(bb?.value).toHaveProperty('upper');\n    expect(bb?.value).toHaveProperty('middle');\n    expect(bb?.value).toHaveProperty('lower');\n  });\n\n  test('should skip disabled indicators', async () => {\n    const strategyWithDisabled = createTestStrategy({\n      indicators: [\n        { type: 'rsi', parameters: { period: 14 }, enabled: true },\n        { type: 'sma', parameters: { period: 20 }, enabled: false },\n      ],\n    });\n\n    const indicators = await runner.calculateIndicators(strategyWithDisabled, marketData);\n\n    expect(indicators.some((i) => i.type === 'rsi')).toBe(true);\n    expect(indicators.some((i) => i.type === 'sma')).toBe(false);\n  });\n\n  test('should skip indicators with insufficient data', async () => {\n    const shortData = generateMarketData(10); // Not enough for period 20\n\n    const indicators = await runner.calculateIndicators(strategy, shortData);\n    const sma = indicators.find((i) => i.type === 'sma');\n\n    expect(sma).toBeUndefined();\n  });\n\n  test('should validate indicator configuration', async () => {\n    const strategyWithInvalidConfig = createTestStrategy({\n      indicators: [{ type: 'rsi', parameters: { period: -1 }, enabled: true }],\n    });\n\n    const indicators = await runner.calculateIndicators(strategyWithInvalidConfig, marketData);\n    const rsi = indicators.find((i) => i.type === 'rsi');\n\n    expect(rsi).toBeUndefined();\n  });\n});\n\ndescribe('StrategyRunner - Condition Evaluation', () => {\n  let runner: StrategyRunner;\n  let strategy: TradingStrategy;\n  let marketData: MarketDataPoint[];\n\n  beforeEach(() => {\n    runner = new StrategyRunner();\n    strategy = createTestStrategy();\n    marketData = generateMarketData(100);\n  });\n\n  test('should evaluate AND logic correctly', async () => {\n    const indicators = [\n      { name: 'rsi', type: 'rsi', value: 25, timestamp: new Date() },\n      { name: 'sma', type: 'sma', value: 51000, timestamp: new Date() },\n    ];\n\n    const result = runner.evaluateConditions(strategy, indicators, 50000);\n\n    expect(result.met).toBe(true);\n    expect(result.reasons).toHaveLength(2);\n  });\n\n  test('should evaluate OR logic correctly', async () => {\n    const strategyWithOR = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'OR',\n          rules: [\n            { indicator: 'rsi', operator: '<', value: 30 },\n            { indicator: 'sma', operator: '>', value: 60000 },\n          ],\n        },\n      ],\n    });\n\n    const indicators = [\n      { name: 'rsi', type: 'rsi', value: 25, timestamp: new Date() },\n      { name: 'sma', type: 'sma', value: 50000, timestamp: new Date() },\n    ];\n\n    const result = runner.evaluateConditions(strategyWithOR, indicators, 50000);\n\n    expect(result.met).toBe(true);\n    expect(result.reasons.length).toBeGreaterThan(0);\n  });\n\n  test('should handle greater than operator', () => {\n    const indicators = [{ name: 'rsi', type: 'rsi', value: 70, timestamp: new Date() }];\n\n    const strategyWithGT = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'rsi', operator: '>', value: 60 }],\n        },\n      ],\n    });\n\n    const result = runner.evaluateConditions(strategyWithGT, indicators, 50000);\n\n    expect(result.met).toBe(true);\n  });\n\n  test('should handle less than operator', () => {\n    const indicators = [{ name: 'rsi', type: 'rsi', value: 25, timestamp: new Date() }];\n\n    const strategyWithLT = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'rsi', operator: '<', value: 30 }],\n        },\n      ],\n    });\n\n    const result = runner.evaluateConditions(strategyWithLT, indicators, 50000);\n\n    expect(result.met).toBe(true);\n  });\n\n  test('should handle equal operator', () => {\n    const indicators = [{ name: 'rsi', type: 'rsi', value: 50, timestamp: new Date() }];\n\n    const strategyWithEQ = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'rsi', operator: '==', value: 50 }],\n        },\n      ],\n    });\n\n    const result = runner.evaluateConditions(strategyWithEQ, indicators, 50000);\n\n    expect(result.met).toBe(true);\n  });\n\n  test('should handle complex indicator values', () => {\n    const indicators = [\n      {\n        name: 'macd',\n        type: 'macd',\n        value: { macd: 100, signal: 90, histogram: 10 },\n        timestamp: new Date(),\n      },\n    ];\n\n    const strategyWithMACD = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'macd', operator: '>', value: 50 }],\n        },\n      ],\n    });\n\n    const result = runner.evaluateConditions(strategyWithMACD, indicators, 50000);\n\n    expect(result.met).toBe(true);\n  });\n\n  test('should normalize score to 0-100', () => {\n    const indicators = [\n      { name: 'rsi', type: 'rsi', value: 25, timestamp: new Date() },\n      { name: 'sma', type: 'sma', value: 51000, timestamp: new Date() },\n    ];\n\n    const result = runner.evaluateConditions(strategy, indicators, 50000);\n\n    expect(result.score).toBeGreaterThanOrEqual(0);\n    expect(result.score).toBeLessThanOrEqual(100);\n  });\n});\n\ndescribe('StrategyRunner - Signal Generation', () => {\n  let runner: StrategyRunner;\n  let strategy: TradingStrategy;\n  let marketData: MarketDataPoint[];\n\n  beforeEach(() => {\n    runner = new StrategyRunner();\n    strategy = createTestStrategy();\n    marketData = generateMarketData(100);\n  });\n\n  test('should generate BUY signal for trend following strategy', async () => {\n    const trendStrategy = createTestStrategy({\n      type: 'trend_following',\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'rsi', operator: '<', value: 30 }],\n        },\n      ],\n    });\n\n    // Create oversold RSI condition\n    const oversoldData = generateMarketData(100, 50000);\n    oversoldData[oversoldData.length - 1].close = 45000; // Drop price to create oversold\n\n    const signal = await runner.evaluate(trendStrategy, oversoldData);\n\n    if (signal) {\n      expect(signal.type).toBe('BUY');\n    }\n  });\n\n  test('should generate SELL signal for mean reversion with overbought RSI', async () => {\n    const meanRevStrategy = createTestStrategy({\n      type: 'mean_reversion',\n      indicators: [{ type: 'rsi', parameters: { period: 14 }, enabled: true }],\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'rsi', operator: '>', value: 70 }],\n        },\n      ],\n    });\n\n    const overboughtData = generateMarketData(100, 50000);\n    overboughtData[overboughtData.length - 1].close = 55000; // Pump price\n\n    const signal = await runner.evaluate(meanRevStrategy, overboughtData);\n\n    if (signal) {\n      expect(['BUY', 'SELL', 'HOLD']).toContain(signal.type);\n    }\n  });\n\n  test('should return null when conditions not met', async () => {\n    const strictStrategy = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [\n            { indicator: 'rsi', operator: '<', value: 10 }, // Very strict\n            { indicator: 'sma', operator: '>', value: 100000 }, // Very strict\n          ],\n        },\n      ],\n    });\n\n    const signal = await runner.evaluate(strictStrategy, marketData);\n\n    expect(signal).toBeNull();\n  });\n\n  test('should return null when insufficient data', async () => {\n    const shortData = generateMarketData(50); // Less than minDataPoints (100)\n    const signal = await runner.evaluate(strategy, shortData);\n\n    expect(signal).toBeNull();\n  });\n\n  test('should include indicator values in signal', async () => {\n    const signal = await runner.evaluate(strategy, marketData);\n\n    if (signal) {\n      expect(signal).toHaveProperty('indicators');\n      expect(typeof signal.indicators).toBe('object');\n    }\n  });\n\n  test('should calculate confidence and strength', async () => {\n    const signal = await runner.evaluate(strategy, marketData);\n\n    if (signal) {\n      expect(signal.confidence).toBeGreaterThanOrEqual(0);\n      expect(signal.confidence).toBeLessThanOrEqual(100);\n      expect(signal.strength).toBeGreaterThanOrEqual(0);\n      expect(signal.strength).toBeLessThanOrEqual(100);\n    }\n  });\n});\n\n// NOTE: Custom indicators via registerIndicator() removed\n// StrategyRunner now uses IndicatorFactory from indicators module\n// Custom indicators should be added to the indicators module instead\ndescribe.skip('StrategyRunner - Custom Indicators', () => {\n  // This test suite is skipped as the registerIndicator API was removed\n  // in favor of using the centralized IndicatorFactory from indicators module\n});\n\ndescribe('StrategyRunner - Error Handling', () => {\n  let runner: StrategyRunner;\n  let strategy: TradingStrategy;\n  let marketData: MarketDataPoint[];\n\n  beforeEach(() => {\n    runner = new StrategyRunner();\n    strategy = createTestStrategy();\n    marketData = generateMarketData(100);\n  });\n\n  test('should handle unknown indicator type gracefully', async () => {\n    const strategyWithUnknown = createTestStrategy({\n      indicators: [{ type: 'unknown_indicator', parameters: {}, enabled: true }],\n    });\n\n    const indicators = await runner.calculateIndicators(strategyWithUnknown, marketData);\n\n    expect(indicators).toHaveLength(0);\n  });\n\n  test('should handle missing indicator values', () => {\n    const indicators = [{ name: 'rsi', type: 'rsi', value: 50, timestamp: new Date() }];\n\n    const strategyWithMissing = createTestStrategy({\n      conditions: [\n        {\n          type: 'entry',\n          logic: 'AND',\n          rules: [{ indicator: 'missing_indicator', operator: '>', value: 50 }],\n        },\n      ],\n    });\n\n    const result = runner.evaluateConditions(strategyWithMissing, indicators, 50000);\n\n    expect(result.met).toBe(false);\n  });\n\n  test('should handle evaluation errors', async () => {\n    const emptyData: MarketDataPoint[] = [];\n    const signal = await runner.evaluate(strategy, emptyData);\n\n    expect(signal).toBeNull();\n  });\n});\n\ndescribe('StrategyRunner - Cache', () => {\n  let runner: StrategyRunner;\n\n  beforeEach(() => {\n    runner = new StrategyRunner();\n  });\n\n  test('should clear cache', () => {\n    runner.clearCache();\n    // If cache clearing throws, test will fail\n    expect(true).toBe(true);\n  });\n});\n\ndescribe('StrategyRunner - Configuration', () => {\n  test('should accept custom configuration', () => {\n    const config = {\n      minDataPoints: 50,\n      maxDataPoints: 1000,\n      enableCache: false,\n      cacheExpiryMs: 30000,\n    };\n\n    const runner = new StrategyRunner(config);\n    expect(runner).toBeDefined();\n  });\n\n  test('should use default configuration when not provided', () => {\n    const runner = new StrategyRunner();\n    expect(runner).toBeDefined();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/engine/strategy-runner.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentPrice' is defined but never used. Allowed unused args must match /^_/u.","line":395,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":395,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Strategy Runner\n * Evaluates trading strategies and generates signals\n */\n\nimport logger from '@/utils/logger';\nimport { OHLCVService } from '../../market-data/services/ohlcv.service';\nimport { IndicatorFactory } from '../../indicators/services/indicator-factory.service';\nimport type { OHLCVData, BaseIndicatorConfig } from '../../indicators/types/indicators.types';\nimport type { TradingSignal } from '../../bots/engine/execution-engine.types';\nimport type { TradingStrategy, ConditionRule, StrategyCondition } from '../types/strategies.types';\nimport type {\n  IStrategyRunner,\n  StrategyRunnerConfig,\n  MarketDataPoint,\n  IndicatorResult,\n  ConditionEvaluationResult,\n} from './strategy-runner.types';\nimport { DEFAULT_STRATEGY_RUNNER_CONFIG } from './strategy-runner.types';\n\n/**\n * Strategy Runner Implementation\n */\nexport class StrategyRunner implements IStrategyRunner {\n  private config: StrategyRunnerConfig;\n  private cache: Map<string, { data: any; timestamp: number }>;\n\n  constructor(config?: Partial<StrategyRunnerConfig>) {\n    this.config = { ...DEFAULT_STRATEGY_RUNNER_CONFIG, ...config };\n    this.cache = new Map();\n  }\n\n  /**\n   * Evaluate strategy and generate trading signal\n   */\n  async evaluate(\n    strategy: TradingStrategy,\n    marketData?: MarketDataPoint[]\n  ): Promise<TradingSignal | null> {\n    try {\n      logger.debug('Evaluating strategy', { strategyId: strategy.id, strategyName: strategy.name });\n\n      // Fetch market data if not provided\n      if (!marketData || marketData.length === 0) {\n        marketData = await this.fetchMarketData(strategy);\n      }\n\n      if (marketData.length < this.config.minDataPoints) {\n        logger.warn('Insufficient market data for strategy evaluation', {\n          strategyId: strategy.id,\n          dataPoints: marketData.length,\n          required: this.config.minDataPoints,\n        });\n        return null;\n      }\n\n      // Calculate indicators\n      const indicators = await this.calculateIndicators(strategy, marketData);\n\n      if (indicators.length === 0) {\n        logger.warn('No indicators calculated', { strategyId: strategy.id });\n        return null;\n      }\n\n      // Get current price\n      const currentPrice = marketData[marketData.length - 1].close;\n\n      // Evaluate conditions\n      const evaluation = this.evaluateConditions(strategy, indicators, currentPrice);\n\n      if (!evaluation.met) {\n        logger.debug('Strategy conditions not met', {\n          strategyId: strategy.id,\n          score: evaluation.score,\n        });\n        return null;\n      }\n\n      // Generate signal\n      const signal = this.generateSignal(strategy, evaluation, currentPrice);\n\n      logger.info('Trading signal generated', {\n        strategyId: strategy.id,\n        type: signal.type,\n        strength: signal.strength,\n        confidence: signal.confidence,\n      });\n\n      return signal;\n    } catch (error) {\n      logger.error('Strategy evaluation failed', {\n        strategyId: strategy.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      // Return null instead of throwing to allow bot to continue\n      return null;\n    }\n  }\n\n  /**\n   * Convert indicator type from strategy config to IndicatorFactory format\n   * Strategy uses lowercase (rsi, sma, ema), IndicatorFactory uses PascalCase/UPPERCASE (RSI, SMA, EMA)\n   */\n  private convertIndicatorType(type: string): string {\n    const typeMap: Record<string, string> = {\n      'rsi': 'RSI',\n      'macd': 'MACD',\n      'sma': 'SMA',\n      'ema': 'EMA',\n      'atr': 'ATR',\n      'adx': 'ADX',\n      'bollinger_bands': 'BollingerBands',\n      'stochastic': 'Stochastic',\n      'vwap': 'VWAP',\n    };\n\n    return typeMap[type.toLowerCase()] || type;\n  }\n\n  /**\n   * Calculate all indicators for strategy using IndicatorFactory\n   */\n  async calculateIndicators(\n    strategy: TradingStrategy,\n    marketData: MarketDataPoint[]\n  ): Promise<IndicatorResult[]> {\n    const results: IndicatorResult[] = [];\n\n    // Convert MarketDataPoint[] to OHLCVData[]\n    const ohlcvData: OHLCVData[] = marketData.map(point => ({\n      timestamp: point.timestamp,\n      open: point.open,\n      high: point.high,\n      low: point.low,\n      close: point.close,\n      volume: point.volume,\n    }));\n\n    for (const indicatorConfig of strategy.indicators) {\n      if (!indicatorConfig.enabled) {\n        continue;\n      }\n\n      // Check if we have minimum data\n      if (ohlcvData.length < 10) {\n        logger.warn('Insufficient data for indicator', {\n          type: indicatorConfig.type,\n          dataPoints: ohlcvData.length,\n        });\n        continue;\n      }\n\n      // Calculate indicator using IndicatorFactory\n      try {\n        // Convert indicator type to IndicatorFactory format\n        const factoryType = this.convertIndicatorType(indicatorConfig.type);\n\n        const config: BaseIndicatorConfig = {\n          type: factoryType as any,\n          period: indicatorConfig.parameters?.period || 14,\n          parameters: indicatorConfig.parameters,\n        };\n\n        const factoryResult = await IndicatorFactory.calculate(ohlcvData, config);\n\n        // Extract numeric value from IndicatorFactory result\n        // IndicatorFactory returns objects like { rsi: 50 } or { sma: 45000 }\n        // We need to extract the main numeric value\n        let numericValue: number | Record<string, number> = factoryResult.value;\n\n        if (typeof factoryResult.value === 'object' && factoryResult.value !== null) {\n          // For RSI: extract 'rsi' field\n          // For MACD: keep full object { macd, signal, histogram }\n          // For SMA/EMA: extract 'sma'/'ema' field\n          // For BollingerBands: keep full object { upper, middle, lower }\n          const type = factoryType.toLowerCase();\n          if (type === 'rsi' && 'rsi' in factoryResult.value) {\n            numericValue = (factoryResult.value as any).rsi;\n          } else if ((type === 'sma' || type === 'ema') && type in factoryResult.value) {\n            numericValue = (factoryResult.value as any)[type];\n          } else {\n            // Keep full object for complex indicators (MACD, BollingerBands)\n            numericValue = factoryResult.value;\n          }\n        }\n\n        // Convert IndicatorFactory result to StrategyRunner IndicatorResult format\n        // Keep original type from strategy config\n        results.push({\n          name: indicatorConfig.type,\n          type: indicatorConfig.type,\n          value: numericValue,\n          timestamp: factoryResult.timestamp,\n        });\n\n        logger.debug('Indicator calculated via IndicatorFactory', {\n          type: indicatorConfig.type,\n          factoryType,\n          value: factoryResult.value,\n        });\n      } catch (error) {\n        logger.error('Indicator calculation failed', {\n          type: indicatorConfig.type,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        // Continue processing other indicators even if one fails\n        continue;\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate strategy conditions\n   */\n  evaluateConditions(\n    strategy: TradingStrategy,\n    indicators: IndicatorResult[],\n    currentPrice: number\n  ): ConditionEvaluationResult {\n    const result: ConditionEvaluationResult = {\n      conditionType: 'entry',\n      met: false,\n      score: 0,\n      reasons: [],\n      indicatorValues: {},\n    };\n\n    // Build indicator values map\n    const indicatorValues: Record<string, any> = {};\n    for (const indicator of indicators) {\n      indicatorValues[indicator.name] = indicator.value;\n    }\n    result.indicatorValues = indicatorValues;\n\n    // Evaluate each condition\n    for (const condition of strategy.conditions) {\n      const conditionMet = this.evaluateCondition(condition, indicatorValues, currentPrice);\n\n      if (conditionMet.met) {\n        result.met = true;\n        result.conditionType = condition.type;\n        result.score += conditionMet.score;\n        result.reasons.push(...conditionMet.reasons);\n      }\n    }\n\n    // Normalize score to 0-100\n    result.score = Math.min(result.score, 100);\n\n    return result;\n  }\n\n  /**\n   * Evaluate a single condition\n   */\n  private evaluateCondition(\n    condition: StrategyCondition,\n    indicatorValues: Record<string, any>,\n    currentPrice: number\n  ): { met: boolean; score: number; reasons: string[] } {\n    const results = {\n      met: false,\n      score: 0,\n      reasons: [] as string[],\n    };\n\n    const ruleResults: boolean[] = [];\n    let totalWeight = 0;\n    let weightedScore = 0;\n\n    // Evaluate each rule\n    for (const rule of condition.rules) {\n      const ruleResult = this.evaluateRule(rule, indicatorValues, currentPrice);\n      ruleResults.push(ruleResult.met);\n\n      if (ruleResult.met) {\n        const weight = rule.weight || 1;\n        totalWeight += weight;\n        weightedScore += weight;\n        results.reasons.push(ruleResult.reason);\n      }\n    }\n\n    // Determine if condition is met based on logic\n    if (condition.logic === 'AND') {\n      results.met = ruleResults.every((r) => r);\n      results.score = results.met ? 100 : 0;\n    } else {\n      // OR logic\n      results.met = ruleResults.some((r) => r);\n      results.score = totalWeight > 0 ? (weightedScore / totalWeight) * 100 : 0;\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate a single rule\n   */\n  private evaluateRule(\n    rule: ConditionRule,\n    indicatorValues: Record<string, any>,\n    _currentPrice: number\n  ): { met: boolean; reason: string } {\n    const indicatorValue = indicatorValues[rule.indicator];\n\n    if (indicatorValue === undefined) {\n      return { met: false, reason: `Indicator ${rule.indicator} not found` };\n    }\n\n    // Handle complex indicator values (e.g., MACD, Bollinger Bands)\n    let actualValue: number;\n    if (typeof indicatorValue === 'object') {\n      // For complex indicators, use the first numeric property\n      actualValue = Object.values(indicatorValue)[0] as number;\n    } else {\n      actualValue = indicatorValue as number;\n    }\n\n    // Convert rule value to number if it's a string\n    const ruleValue = typeof rule.value === 'string' ? parseFloat(rule.value) : rule.value;\n\n    // Evaluate operator\n    let met = false;\n    let reason = '';\n\n    switch (rule.operator) {\n      case '>':\n        met = actualValue > ruleValue;\n        reason = met\n          ? `${rule.indicator} (${actualValue.toFixed(2)}) > ${ruleValue}`\n          : `${rule.indicator} (${actualValue.toFixed(2)}) not > ${ruleValue}`;\n        break;\n\n      case '<':\n        met = actualValue < ruleValue;\n        reason = met\n          ? `${rule.indicator} (${actualValue.toFixed(2)}) < ${ruleValue}`\n          : `${rule.indicator} (${actualValue.toFixed(2)}) not < ${ruleValue}`;\n        break;\n\n      case '>=':\n        met = actualValue >= ruleValue;\n        reason = met\n          ? `${rule.indicator} (${actualValue.toFixed(2)}) >= ${ruleValue}`\n          : `${rule.indicator} (${actualValue.toFixed(2)}) not >= ${ruleValue}`;\n        break;\n\n      case '<=':\n        met = actualValue <= ruleValue;\n        reason = met\n          ? `${rule.indicator} (${actualValue.toFixed(2)}) <= ${ruleValue}`\n          : `${rule.indicator} (${actualValue.toFixed(2)}) not <= ${ruleValue}`;\n        break;\n\n      case '==':\n        met = Math.abs(actualValue - ruleValue) < 0.0001; // Float comparison tolerance\n        reason = met\n          ? `${rule.indicator} (${actualValue.toFixed(2)}) == ${ruleValue}`\n          : `${rule.indicator} (${actualValue.toFixed(2)}) not == ${ruleValue}`;\n        break;\n\n      case '!=':\n        met = Math.abs(actualValue - ruleValue) >= 0.0001;\n        reason = met\n          ? `${rule.indicator} (${actualValue.toFixed(2)}) != ${ruleValue}`\n          : `${rule.indicator} (${actualValue.toFixed(2)}) not != ${ruleValue}`;\n        break;\n\n      case 'crosses_above':\n      case 'crosses_below':\n        // Would need historical data to implement crosses - simplified for now\n        met = rule.operator === 'crosses_above' ? actualValue > ruleValue : actualValue < ruleValue;\n        reason = `${rule.indicator} ${rule.operator} ${ruleValue} (simplified)`;\n        break;\n\n      default:\n        met = false;\n        reason = `Unknown operator: ${rule.operator}`;\n    }\n\n    return { met, reason };\n  }\n\n  /**\n   * Generate trading signal from evaluation\n   */\n  private generateSignal(\n    strategy: TradingStrategy,\n    evaluation: ConditionEvaluationResult,\n    currentPrice: number\n  ): TradingSignal {\n    // Determine signal type based on condition type and strategy type\n    let signalType: 'BUY' | 'SELL' | 'HOLD' = 'HOLD';\n\n    if (evaluation.conditionType === 'entry') {\n      // For entry conditions, determine if it's a buy or sell based on strategy type\n      if (strategy.type === 'trend_following' || strategy.type === 'breakout') {\n        signalType = 'BUY'; // Assume long bias for these strategies\n      } else if (strategy.type === 'mean_reversion') {\n        // Mean reversion could be buy or sell - use RSI if available\n        const rsi = evaluation.indicatorValues['rsi'];\n        if (rsi && rsi < 30) {\n          signalType = 'BUY'; // Oversold\n        } else if (rsi && rsi > 70) {\n          signalType = 'SELL'; // Overbought\n        }\n      } else {\n        signalType = 'BUY'; // Default to buy for other strategies\n      }\n    } else {\n      // Exit conditions\n      signalType = 'SELL';\n    }\n\n    // Calculate confidence based on score and number of reasons\n    const confidence = Math.min(evaluation.score, 100);\n    const strength = Math.min(evaluation.reasons.length * 20, 100);\n\n    return {\n      type: signalType,\n      strength,\n      confidence,\n      reasons: evaluation.reasons,\n      indicators: evaluation.indicatorValues,\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Fetch market data for strategy\n   */\n  private async fetchMarketData(strategy: TradingStrategy): Promise<MarketDataPoint[]> {\n    try {\n      const ohlcvData = await OHLCVService.fetchOHLCV({\n        exchangeId: strategy.exchangeId,\n        symbol: strategy.symbol,\n        timeframe: strategy.timeframe,\n        limit: this.config.maxDataPoints,\n      });\n\n      return ohlcvData.map((candle) => ({\n        timestamp: candle.timestamp,\n        open: candle.open,\n        high: candle.high,\n        low: candle.low,\n        close: candle.close,\n        volume: candle.volume,\n      }));\n    } catch (error) {\n      logger.error('Failed to fetch market data', {\n        strategyId: strategy.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n\n// Export singleton instance\nexport const strategyRunner = new StrategyRunner();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/engine/strategy-runner.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/routes/strategies.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/schema/strategies.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/services/strategy.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'maxEquity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1144,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":1144,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Strategy Service\n * Manages trading strategies, signals, and backtests\n */\n\nimport { db } from '@/db';\nimport { eq, and, desc, sql } from 'drizzle-orm';\nimport logger from '@/utils/logger';\nimport { BadRequestError, NotFoundError } from '@/utils/errors';\nimport { tradingStrategies, strategySignals, strategyBacktests } from '../schema/strategies.schema';\nimport { OHLCVService } from '../../market-data/services/ohlcv.service';\nimport type {\n  TradingStrategy,\n  CreateStrategyRequest,\n  UpdateStrategyRequest,\n  StrategyQueryOptions,\n  StrategySignal,\n  SignalQueryOptions,\n  StrategyBacktest,\n  RunBacktestRequest,\n  StrategyStatistics,\n  IStrategyService,\n  IndicatorConfig,\n  StrategyCondition,\n  ConditionRule,\n  SignalType,\n  BacktestTrade,\n  EquityCurvePoint,\n} from '../types/strategies.types';\n\nexport class StrategyService implements IStrategyService {\n  // ============================================================================\n  // STRATEGY CRUD\n  // ============================================================================\n\n  /**\n   * Create a new trading strategy\n   */\n  async createStrategy(\n    userId: string,\n    tenantId: string,\n    request: CreateStrategyRequest\n  ): Promise<TradingStrategy> {\n    logger.info('Creating trading strategy', { userId, tenantId, name: request.name });\n\n    // Validate request\n    this.validateStrategyRequest(request);\n\n    // Create strategy\n    const [strategy] = await db\n      .insert(tradingStrategies)\n      .values({\n        userId,\n        tenantId,\n        name: request.name,\n        description: request.description,\n        version: '1.0.0',\n        exchangeId: request.exchangeId,\n        symbol: request.symbol,\n        timeframe: request.timeframe,\n        type: request.type,\n        indicators: request.indicators as any,\n        conditions: request.conditions as any,\n        parameters: request.parameters as any,\n        stopLossPercent: request.stopLossPercent?.toString(),\n        takeProfitPercent: request.takeProfitPercent?.toString(),\n        trailingStopPercent: request.trailingStopPercent?.toString(),\n        maxPositionSize: request.maxPositionSize?.toString(),\n        maxDrawdownPercent: request.maxDrawdownPercent?.toString(),\n        status: 'draft',\n        isPublic: false,\n        tags: request.tags as any,\n        notes: request.notes,\n      })\n      .returning();\n\n    logger.info('Trading strategy created', { strategyId: strategy.id });\n\n    return this.mapStrategyFromDb(strategy);\n  }\n\n  /**\n   * Get strategy by ID\n   */\n  async getStrategy(\n    strategyId: string,\n    userId: string,\n    tenantId: string\n  ): Promise<TradingStrategy | null> {\n    const [strategy] = await db\n      .select()\n      .from(tradingStrategies)\n      .where(\n        and(\n          eq(tradingStrategies.id, strategyId),\n          eq(tradingStrategies.userId, userId),\n          eq(tradingStrategies.tenantId, tenantId)\n        )\n      )\n      .limit(1);\n\n    if (!strategy) {\n      return null;\n    }\n\n    return this.mapStrategyFromDb(strategy);\n  }\n\n  /**\n   * Get all strategies matching criteria\n   */\n  async getStrategies(options: StrategyQueryOptions): Promise<TradingStrategy[]> {\n    const conditions = [];\n\n    if (options.userId) {\n      conditions.push(eq(tradingStrategies.userId, options.userId));\n    }\n\n    if (options.tenantId) {\n      conditions.push(eq(tradingStrategies.tenantId, options.tenantId));\n    }\n\n    if (options.exchangeId) {\n      conditions.push(eq(tradingStrategies.exchangeId, options.exchangeId));\n    }\n\n    if (options.symbol) {\n      conditions.push(eq(tradingStrategies.symbol, options.symbol));\n    }\n\n    if (options.type) {\n      conditions.push(eq(tradingStrategies.type, options.type));\n    }\n\n    if (options.status) {\n      conditions.push(eq(tradingStrategies.status, options.status));\n    }\n\n    let query = db\n      .select()\n      .from(tradingStrategies)\n      .orderBy(desc(tradingStrategies.createdAt));\n\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions)) as any;\n    }\n\n    if (options.limit) {\n      query = query.limit(options.limit) as any;\n    }\n\n    if (options.offset) {\n      query = query.offset(options.offset) as any;\n    }\n\n    const strategies = await query;\n\n    return strategies.map((s) => this.mapStrategyFromDb(s));\n  }\n\n  /**\n   * Update strategy\n   */\n  async updateStrategy(\n    strategyId: string,\n    userId: string,\n    tenantId: string,\n    updates: UpdateStrategyRequest\n  ): Promise<TradingStrategy> {\n    logger.info('Updating trading strategy', { strategyId, updates });\n\n    // Check if strategy exists\n    const existing = await this.getStrategy(strategyId, userId, tenantId);\n    if (!existing) {\n      throw new NotFoundError('Strategy not found');\n    }\n\n    // Cannot update active strategies directly\n    if (existing.status === 'active' && updates.status !== 'paused') {\n      throw new BadRequestError('Cannot update active strategy. Pause it first.');\n    }\n\n    // Build update object\n    const updateData: any = {\n      updatedAt: new Date(),\n    };\n\n    if (updates.name !== undefined) updateData.name = updates.name;\n    if (updates.description !== undefined) updateData.description = updates.description;\n    if (updates.indicators !== undefined) updateData.indicators = updates.indicators;\n    if (updates.conditions !== undefined) updateData.conditions = updates.conditions;\n    if (updates.parameters !== undefined) updateData.parameters = updates.parameters;\n    if (updates.stopLossPercent !== undefined)\n      updateData.stopLossPercent = updates.stopLossPercent.toString();\n    if (updates.takeProfitPercent !== undefined)\n      updateData.takeProfitPercent = updates.takeProfitPercent.toString();\n    if (updates.trailingStopPercent !== undefined)\n      updateData.trailingStopPercent = updates.trailingStopPercent.toString();\n    if (updates.maxPositionSize !== undefined)\n      updateData.maxPositionSize = updates.maxPositionSize.toString();\n    if (updates.maxDrawdownPercent !== undefined)\n      updateData.maxDrawdownPercent = updates.maxDrawdownPercent.toString();\n    if (updates.status !== undefined) updateData.status = updates.status;\n    if (updates.tags !== undefined) updateData.tags = updates.tags;\n    if (updates.notes !== undefined) updateData.notes = updates.notes;\n\n    // Update in database\n    const [updated] = await db\n      .update(tradingStrategies)\n      .set(updateData)\n      .where(\n        and(\n          eq(tradingStrategies.id, strategyId),\n          eq(tradingStrategies.userId, userId),\n          eq(tradingStrategies.tenantId, tenantId)\n        )\n      )\n      .returning();\n\n    logger.info('Trading strategy updated', { strategyId });\n\n    return this.mapStrategyFromDb(updated);\n  }\n\n  /**\n   * Delete strategy\n   */\n  async deleteStrategy(strategyId: string, userId: string, tenantId: string): Promise<void> {\n    logger.info('Deleting trading strategy', { strategyId });\n\n    const strategy = await this.getStrategy(strategyId, userId, tenantId);\n    if (!strategy) {\n      throw new NotFoundError('Strategy not found');\n    }\n\n    if (strategy.status === 'active') {\n      throw new BadRequestError('Cannot delete active strategy. Pause it first.');\n    }\n\n    // Delete strategy (cascade will delete signals and backtests)\n    await db\n      .delete(tradingStrategies)\n      .where(\n        and(\n          eq(tradingStrategies.id, strategyId),\n          eq(tradingStrategies.userId, userId),\n          eq(tradingStrategies.tenantId, tenantId)\n        )\n      );\n\n    logger.info('Trading strategy deleted', { strategyId });\n  }\n\n  // ============================================================================\n  // STRATEGY EXECUTION\n  // ============================================================================\n\n  /**\n   * Activate strategy\n   */\n  async activateStrategy(\n    strategyId: string,\n    userId: string,\n    tenantId: string\n  ): Promise<TradingStrategy> {\n    logger.info('Activating strategy', { strategyId });\n\n    const strategy = await this.getStrategy(strategyId, userId, tenantId);\n    if (!strategy) {\n      throw new NotFoundError('Strategy not found');\n    }\n\n    if (strategy.status === 'active') {\n      throw new BadRequestError('Strategy is already active');\n    }\n\n    // Validate strategy is ready to activate\n    this.validateStrategyForExecution(strategy);\n\n    // Update status\n    const updated = await this.updateStrategy(strategyId, userId, tenantId, {\n      status: 'active',\n    });\n\n    logger.info('Strategy activated', { strategyId });\n\n    return updated;\n  }\n\n  /**\n   * Pause strategy\n   */\n  async pauseStrategy(\n    strategyId: string,\n    userId: string,\n    tenantId: string\n  ): Promise<TradingStrategy> {\n    logger.info('Pausing strategy', { strategyId });\n\n    const strategy = await this.getStrategy(strategyId, userId, tenantId);\n    if (!strategy) {\n      throw new NotFoundError('Strategy not found');\n    }\n\n    if (strategy.status !== 'active') {\n      throw new BadRequestError('Only active strategies can be paused');\n    }\n\n    // Update status\n    const updated = await this.updateStrategy(strategyId, userId, tenantId, {\n      status: 'paused',\n    });\n\n    logger.info('Strategy paused', { strategyId });\n\n    return updated;\n  }\n\n  // ============================================================================\n  // SIGNALS\n  // ============================================================================\n\n  /**\n   * Get signals matching criteria\n   */\n  async getSignals(options: SignalQueryOptions): Promise<StrategySignal[]> {\n    const conditions = [];\n\n    if (options.userId) {\n      conditions.push(eq(strategySignals.userId, options.userId));\n    }\n\n    if (options.tenantId) {\n      conditions.push(eq(strategySignals.tenantId, options.tenantId));\n    }\n\n    if (options.strategyId) {\n      conditions.push(eq(strategySignals.strategyId, options.strategyId));\n    }\n\n    if (options.exchangeId) {\n      conditions.push(eq(strategySignals.exchangeId, options.exchangeId));\n    }\n\n    if (options.symbol) {\n      conditions.push(eq(strategySignals.symbol, options.symbol));\n    }\n\n    if (options.type) {\n      conditions.push(eq(strategySignals.type, options.type));\n    }\n\n    if (options.status) {\n      conditions.push(eq(strategySignals.status, options.status));\n    }\n\n    let query = db\n      .select()\n      .from(strategySignals)\n      .orderBy(desc(strategySignals.timestamp));\n\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions)) as any;\n    }\n\n    if (options.limit) {\n      query = query.limit(options.limit) as any;\n    }\n\n    if (options.offset) {\n      query = query.offset(options.offset) as any;\n    }\n\n    const signals = await query;\n\n    return signals.map((s) => this.mapSignalFromDb(s));\n  }\n\n  /**\n   * Generate signal for strategy\n   * Evaluates indicators and conditions to produce trading signals\n   */\n  async generateSignal(strategyId: string): Promise<StrategySignal | null> {\n    logger.info('Generating signal for strategy', { strategyId });\n\n    // Get strategy\n    const [strategy] = await db\n      .select()\n      .from(tradingStrategies)\n      .where(eq(tradingStrategies.id, strategyId))\n      .limit(1);\n\n    if (!strategy) {\n      throw new NotFoundError('Strategy not found');\n    }\n\n    if (strategy.status !== 'active') {\n      throw new BadRequestError('Strategy must be active to generate signals');\n    }\n\n    // Fetch latest market data\n    const ohlcvData = await OHLCVService.fetchOHLCV({\n      exchangeId: strategy.exchangeId,\n      symbol: strategy.symbol,\n      timeframe: strategy.timeframe as any, // Type assertion - timeframe is validated in schema\n      limit: 100,\n    });\n\n    if (ohlcvData.length === 0) {\n      logger.warn('No market data available for signal generation');\n      return null;\n    }\n\n    // Calculate indicators using real implementation\n    const latestCandle = ohlcvData[ohlcvData.length - 1];\n    const indicatorValues = await this.calculateIndicators(ohlcvData, strategy.indicators as any);\n\n    // Evaluate conditions to generate trading signal\n    const signalType = this.evaluateConditions(\n      indicatorValues,\n      strategy.conditions as any\n    );\n\n    if (!signalType) {\n      logger.debug('No signal generated - conditions not met');\n      return null;\n    }\n\n    // Calculate stop loss and take profit\n    const currentPrice = latestCandle.close;\n    const stopLoss = strategy.stopLossPercent\n      ? currentPrice * (1 - parseFloat(strategy.stopLossPercent) / 100)\n      : undefined;\n    const takeProfit = strategy.takeProfitPercent\n      ? currentPrice * (1 + parseFloat(strategy.takeProfitPercent) / 100)\n      : undefined;\n\n    const signalQuality = this.calculateSignalQuality(\n      indicatorValues as Record<string, any>,\n      strategy.conditions as any,\n      signalType\n    );\n\n    // Create signal\n    const [signal] = await db\n      .insert(strategySignals)\n      .values({\n        strategyId: strategy.id,\n        userId: strategy.userId,\n        tenantId: strategy.tenantId,\n        exchangeId: strategy.exchangeId,\n        symbol: strategy.symbol,\n        timeframe: strategy.timeframe,\n        type: signalType,\n        strength: signalQuality.strength,\n        confidence: signalQuality.confidence,\n        price: currentPrice.toString(),\n        stopLoss: stopLoss?.toString(),\n        takeProfit: takeProfit?.toString(),\n        indicatorValues: indicatorValues as any,\n        status: 'pending',\n        reason: 'Strategy conditions met',\n        timestamp: new Date(),\n        expiresAt: new Date(Date.now() + 3600000), // 1 hour\n      })\n      .returning();\n\n    logger.info('Signal generated', { signalId: signal.id, type: signalType });\n\n    return this.mapSignalFromDb(signal);\n  }\n\n  // ============================================================================\n  // BACKTESTING\n  // ============================================================================\n\n  /**\n   * Run backtest for strategy\n   */\n  async runBacktest(\n    userId: string,\n    tenantId: string,\n    request: RunBacktestRequest\n  ): Promise<StrategyBacktest> {\n    logger.info('Starting backtest', { strategyId: request.strategyId });\n\n    // Get strategy\n    const strategy = await this.getStrategy(request.strategyId, userId, tenantId);\n    if (!strategy) {\n      throw new NotFoundError('Strategy not found');\n    }\n\n    // Create backtest record\n    const [backtest] = await db\n      .insert(strategyBacktests)\n      .values({\n        strategyId: request.strategyId,\n        userId,\n        tenantId,\n        startDate: request.startDate,\n        endDate: request.endDate,\n        initialCapital: request.initialCapital.toString(),\n        status: 'running',\n      })\n      .returning();\n\n    logger.info('Backtest created', { backtestId: backtest.id });\n\n    // Run backtest asynchronously with full simulation\n    this.runBacktestAsync(backtest.id, strategy, request).catch((error) => {\n      logger.error('Backtest failed', { backtestId: backtest.id, error });\n    });\n\n    return this.mapBacktestFromDb(backtest);\n  }\n\n  /**\n   * Get backtest by ID\n   */\n  async getBacktest(\n    backtestId: string,\n    userId: string,\n    tenantId: string\n  ): Promise<StrategyBacktest | null> {\n    const [backtest] = await db\n      .select()\n      .from(strategyBacktests)\n      .where(\n        and(\n          eq(strategyBacktests.id, backtestId),\n          eq(strategyBacktests.userId, userId),\n          eq(strategyBacktests.tenantId, tenantId)\n        )\n      )\n      .limit(1);\n\n    if (!backtest) {\n      return null;\n    }\n\n    return this.mapBacktestFromDb(backtest);\n  }\n\n  /**\n   * Get all backtests for strategy\n   */\n  async getBacktests(\n    strategyId: string,\n    userId: string,\n    tenantId: string\n  ): Promise<StrategyBacktest[]> {\n    const backtests = await db\n      .select()\n      .from(strategyBacktests)\n      .where(\n        and(\n          eq(strategyBacktests.strategyId, strategyId),\n          eq(strategyBacktests.userId, userId),\n          eq(strategyBacktests.tenantId, tenantId)\n        )\n      )\n      .orderBy(desc(strategyBacktests.createdAt));\n\n    return backtests.map((b) => this.mapBacktestFromDb(b));\n  }\n\n  // ============================================================================\n  // STATISTICS\n  // ============================================================================\n\n  /**\n   * Get strategy statistics for user\n   */\n  async getStrategyStatistics(userId: string, tenantId: string): Promise<StrategyStatistics> {\n    // Count strategies\n    const [strategyCounts] = await db\n      .select({\n        total: sql<number>`count(*)::int`,\n        active: sql<number>`count(case when ${tradingStrategies.status} = 'active' then 1 end)::int`,\n      })\n      .from(tradingStrategies)\n      .where(\n        and(eq(tradingStrategies.userId, userId), eq(tradingStrategies.tenantId, tenantId))\n      );\n\n    // Count signals\n    const [signalCounts] = await db\n      .select({\n        total: sql<number>`count(*)::int`,\n        executed: sql<number>`count(case when ${strategySignals.status} = 'executed' then 1 end)::int`,\n      })\n      .from(strategySignals)\n      .where(and(eq(strategySignals.userId, userId), eq(strategySignals.tenantId, tenantId)));\n\n    // Get overall performance\n    const [performance] = await db\n      .select({\n        totalTrades: sql<number>`coalesce(sum(${tradingStrategies.totalTrades}), 0)::int`,\n        winningTrades: sql<number>`coalesce(sum(${tradingStrategies.winningTrades}), 0)::int`,\n        totalPnl: sql<string>`coalesce(sum(${tradingStrategies.totalPnl}), 0)`,\n      })\n      .from(tradingStrategies)\n      .where(and(eq(tradingStrategies.userId, userId), eq(tradingStrategies.tenantId, tenantId)));\n\n    const totalTrades = performance.totalTrades;\n    const winningTrades = performance.winningTrades;\n    const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;\n\n    // Get best strategy\n    const [bestStrategy] = await db\n      .select({\n        id: tradingStrategies.id,\n        name: tradingStrategies.name,\n        winRate: tradingStrategies.winRate,\n        profitFactor: tradingStrategies.profitFactor,\n      })\n      .from(tradingStrategies)\n      .where(and(eq(tradingStrategies.userId, userId), eq(tradingStrategies.tenantId, tenantId)))\n      .orderBy(desc(tradingStrategies.profitFactor))\n      .limit(1);\n\n    return {\n      totalStrategies: strategyCounts.total,\n      activeStrategies: strategyCounts.active,\n      totalSignals: signalCounts.total,\n      executedSignals: signalCounts.executed,\n      totalTrades,\n      winRate,\n      profitFactor: bestStrategy?.profitFactor ? parseFloat(bestStrategy.profitFactor) : 0,\n      totalPnl: parseFloat(performance.totalPnl),\n      bestStrategy: bestStrategy\n        ? {\n            id: bestStrategy.id,\n            name: bestStrategy.name,\n            winRate: bestStrategy.winRate ? parseFloat(bestStrategy.winRate) : 0,\n            profitFactor: bestStrategy.profitFactor ? parseFloat(bestStrategy.profitFactor) : 0,\n          }\n        : undefined,\n    };\n  }\n\n  // ============================================================================\n  // PRIVATE HELPERS\n  // ============================================================================\n\n  /**\n   * Validate strategy request\n   */\n  private validateStrategyRequest(request: CreateStrategyRequest): void {\n    if (!request.name || request.name.trim().length === 0) {\n      throw new BadRequestError('Strategy name is required');\n    }\n\n    if (!request.exchangeId || !request.symbol || !request.timeframe) {\n      throw new BadRequestError('Exchange, symbol, and timeframe are required');\n    }\n\n    if (!request.indicators || request.indicators.length === 0) {\n      throw new BadRequestError('At least one indicator is required');\n    }\n\n    if (!request.conditions || request.conditions.length === 0) {\n      throw new BadRequestError('At least one condition is required');\n    }\n  }\n\n  /**\n   * Validate strategy for execution\n   */\n  private validateStrategyForExecution(strategy: TradingStrategy): void {\n    if (!strategy.indicators || strategy.indicators.length === 0) {\n      throw new BadRequestError('Strategy must have at least one indicator');\n    }\n\n    if (!strategy.conditions || strategy.conditions.length === 0) {\n      throw new BadRequestError('Strategy must have at least one condition');\n    }\n  }\n\n  /**\n   * Calculate indicators based on configuration\n   * Converts OHLCV data and calculates each indicator using indicators module\n   */\n  private async calculateIndicators(\n    ohlcvData: any[],\n    indicators: IndicatorConfig[]\n  ): Promise<Record<string, any>> {\n    if (!ohlcvData || ohlcvData.length === 0) {\n      logger.warn('No OHLCV data provided for indicator calculation');\n      return {};\n    }\n\n    if (!indicators || indicators.length === 0) {\n      return {};\n    }\n\n    // Convert OHLCV data to the format expected by calculator\n    const convertedData = ohlcvData.map((candle) => ({\n      timestamp: candle.timestamp,\n      open: candle.open,\n      high: candle.high,\n      low: candle.low,\n      close: candle.close,\n      volume: candle.volume,\n    }));\n\n    const results: Record<string, any> = {};\n\n    // Import indicator calculator dynamically\n    const {\n      calculateRSI,\n      calculateMACD,\n      calculateEMA,\n      calculateSMA,\n      calculateBBands,\n      calculateATR,\n      calculateStoch,\n      calculateADX,\n      getLatestValue,\n    } = await import('@/modules/indicators/utils/calculator-v2');\n\n    // Calculate each indicator\n    for (const indicator of indicators) {\n      if (!indicator.enabled) continue;\n\n      try {\n        const params = indicator.parameters || {};\n        let indicatorResult: any;\n\n        switch (indicator.type.toLowerCase()) {\n          case 'rsi':\n            indicatorResult = await calculateRSI(convertedData, params.period || 14);\n            results.rsi = getLatestValue(indicatorResult);\n            break;\n\n          case 'macd':\n            indicatorResult = await calculateMACD(\n              convertedData,\n              params.fastPeriod || 12,\n              params.slowPeriod || 26,\n              params.signalPeriod || 9\n            );\n            results.macd = {\n              value: getLatestValue(indicatorResult.macd),\n              signal: getLatestValue(indicatorResult.signal),\n              histogram: getLatestValue(indicatorResult.histogram),\n            };\n            break;\n\n          case 'ema':\n            indicatorResult = await calculateEMA(convertedData, params.period || 20);\n            const key = `ema_${params.period || 20}`;\n            results[key] = getLatestValue(indicatorResult);\n            break;\n\n          case 'sma':\n            indicatorResult = await calculateSMA(convertedData, params.period || 20);\n            const smaKey = `sma_${params.period || 20}`;\n            results[smaKey] = getLatestValue(indicatorResult);\n            break;\n\n          case 'bollinger_bands':\n          case 'bbands':\n            indicatorResult = await calculateBBands(\n              convertedData,\n              params.period || 20,\n              params.stdDev || 2\n            );\n            results.bollinger_bands = {\n              upper: getLatestValue(indicatorResult.upper),\n              middle: getLatestValue(indicatorResult.middle),\n              lower: getLatestValue(indicatorResult.lower),\n            };\n            break;\n\n          case 'atr':\n            indicatorResult = await calculateATR(convertedData, params.period || 14);\n            results.atr = getLatestValue(indicatorResult);\n            break;\n\n          case 'stochastic':\n          case 'stoch':\n            indicatorResult = await calculateStoch(\n              convertedData,\n              params.kPeriod || 14,\n              params.kSlowing || 3,\n              params.dPeriod || 3\n            );\n            results.stochastic = {\n              k: getLatestValue(indicatorResult.k),\n              d: getLatestValue(indicatorResult.d),\n            };\n            break;\n\n          case 'adx':\n            indicatorResult = await calculateADX(convertedData, params.period || 14);\n            results.adx = getLatestValue(indicatorResult);\n            break;\n\n          default:\n            logger.warn(`Unsupported indicator type: ${indicator.type}`);\n        }\n      } catch (error) {\n        logger.error(`Error calculating indicator ${indicator.type}`, { error });\n        // Continue with other indicators instead of failing completely\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Evaluate conditions based on indicator values\n   * Supports multiple condition types and operators\n   */\n  private evaluateConditions(\n    indicatorValues: Record<string, any>,\n    conditions: StrategyCondition[]\n  ): SignalType | null {\n    if (!conditions || conditions.length === 0) {\n      return null;\n    }\n\n    let entrySignal: SignalType | null = null;\n    let exitSignal: SignalType | null = null;\n\n    // Evaluate entry and exit conditions separately\n    for (const condition of conditions) {\n      const conditionMet = this.evaluateConditionRules(indicatorValues, condition);\n\n      if (conditionMet) {\n        if (condition.type === 'entry') {\n          // For entry conditions, we need to determine buy/sell\n          // This is a simplified approach - real strategies might be more complex\n          entrySignal = this.determineEntrySignal(indicatorValues, condition);\n        } else if (condition.type === 'exit') {\n          exitSignal = this.determineExitSignal(indicatorValues, condition);\n        }\n      }\n    }\n\n    // Prioritize exit signals over entry signals\n    if (exitSignal) {\n      return exitSignal;\n    }\n\n    return entrySignal;\n  }\n\n  /**\n   * Evaluate condition rules with AND/OR logic\n   */\n  private evaluateConditionRules(\n    indicatorValues: Record<string, any>,\n    condition: StrategyCondition\n  ): boolean {\n    if (!condition.rules || condition.rules.length === 0) {\n      return false;\n    }\n\n    const ruleResults = condition.rules.map((rule) =>\n      this.evaluateRule(indicatorValues, rule)\n    );\n\n    // Apply logic operator\n    if (condition.logic === 'AND') {\n      return ruleResults.every((result) => result);\n    } else {\n      // OR logic\n      return ruleResults.some((result) => result);\n    }\n  }\n\n  /**\n   * Evaluate a single condition rule\n   */\n  private evaluateRule(indicatorValues: Record<string, any>, rule: ConditionRule): boolean {\n    const indicatorValue = this.getIndicatorValue(indicatorValues, rule.indicator);\n\n    if (indicatorValue === null || indicatorValue === undefined) {\n      return false;\n    }\n\n    const compareValue = typeof rule.value === 'string'\n      ? this.getIndicatorValue(indicatorValues, rule.value)\n      : rule.value;\n\n    if (compareValue === null || compareValue === undefined) {\n      return false;\n    }\n\n    switch (rule.operator) {\n      case '>':\n        return indicatorValue > compareValue;\n      case '<':\n        return indicatorValue < compareValue;\n      case '>=':\n        return indicatorValue >= compareValue;\n      case '<=':\n        return indicatorValue <= compareValue;\n      case '==':\n        return Math.abs(indicatorValue - compareValue) < 0.0001;\n      case '!=':\n        return Math.abs(indicatorValue - compareValue) >= 0.0001;\n      case 'crosses_above':\n        // For crossover detection, we'd need historical data\n        // Simplified: just check if current value is above\n        return indicatorValue > compareValue;\n      case 'crosses_below':\n        // Simplified: just check if current value is below\n        return indicatorValue < compareValue;\n      default:\n        logger.warn(`Unsupported operator: ${rule.operator}`);\n        return false;\n    }\n  }\n\n  /**\n   * Get indicator value from the results object\n   * Supports nested paths like 'macd.histogram' or 'bollinger_bands.upper'\n   */\n  private getIndicatorValue(indicatorValues: Record<string, any>, path: string): number | null {\n    if (!path || !indicatorValues) {\n      return null;\n    }\n\n    const parts = path.split('.');\n    let value: any = indicatorValues;\n\n    for (const part of parts) {\n      if (value === null || value === undefined || typeof value !== 'object') {\n        return null;\n      }\n      value = value[part];\n    }\n\n    return typeof value === 'number' ? value : null;\n  }\n\n  /**\n   * Determine entry signal type based on conditions\n   */\n  private determineEntrySignal(\n    indicatorValues: Record<string, any>,\n    _condition: StrategyCondition\n  ): SignalType | null {\n    // Simplified logic: Check RSI for overbought/oversold\n    const rsi = indicatorValues.rsi;\n\n    if (rsi !== null && rsi !== undefined) {\n      if (rsi < 30) {\n        return 'buy'; // Oversold\n      }\n      if (rsi > 70) {\n        return 'sell'; // Overbought\n      }\n    }\n\n    // Check MACD for bullish/bearish signal\n    const macd = indicatorValues.macd;\n    if (macd && macd.histogram !== null && macd.histogram !== undefined) {\n      if (macd.histogram > 0) {\n        return 'buy'; // Bullish\n      }\n      if (macd.histogram < 0) {\n        return 'sell'; // Bearish\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine exit signal type based on conditions\n   */\n  private determineExitSignal(\n    indicatorValues: Record<string, any>,\n    _condition: StrategyCondition\n  ): SignalType | null {\n    const rsi = this.getIndicatorValue(indicatorValues, 'rsi');\n    if (rsi !== null) {\n      if (rsi >= 70) {\n        return 'close_long';\n      }\n      if (rsi <= 30) {\n        return 'close_short';\n      }\n    }\n\n    const macdHistogram = this.getIndicatorValue(indicatorValues, 'macd.histogram');\n    if (macdHistogram !== null) {\n      if (macdHistogram < 0) {\n        return 'close_long';\n      }\n      if (macdHistogram > 0) {\n        return 'close_short';\n      }\n    }\n\n    const stochasticK = this.getIndicatorValue(indicatorValues, 'stochastic.k');\n    const stochasticD = this.getIndicatorValue(indicatorValues, 'stochastic.d');\n    if (stochasticK !== null && stochasticD !== null) {\n      if (stochasticK < stochasticD) {\n        return 'close_long';\n      }\n      if (stochasticK > stochasticD) {\n        return 'close_short';\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Calculate signal quality metrics\n   */\n  private calculateSignalQuality(\n    indicatorValues: Record<string, any>,\n    conditions: StrategyCondition[] | undefined,\n    signalType: SignalType | null\n  ): { strength: number; confidence: number } {\n    if (!signalType) {\n      return { strength: 0, confidence: 0 };\n    }\n\n    const relevantConditions = (conditions || []).filter((condition) =>\n      signalType === 'buy' || signalType === 'sell'\n        ? condition.type === 'entry'\n        : condition.type === 'exit'\n    );\n\n    let totalRules = 0;\n    let matchedRules = 0;\n\n    for (const condition of relevantConditions) {\n      for (const rule of condition.rules || []) {\n        totalRules += 1;\n        if (this.evaluateRule(indicatorValues, rule)) {\n          matchedRules += 1;\n        }\n      }\n    }\n\n    const baseStrength =\n      totalRules > 0\n        ? matchedRules / totalRules\n        : relevantConditions.length > 0\n          ? 0.5\n          : 0.25;\n\n    const strengthRatio = Math.min(1, Math.max(0, baseStrength));\n\n    const rsi = this.getIndicatorValue(indicatorValues, 'rsi');\n    let rsiScore = 0;\n    if (rsi !== null) {\n      if (signalType === 'buy' || signalType === 'close_short') {\n        rsiScore = Math.max(0, Math.min(1, (70 - rsi) / 40));\n      } else if (signalType === 'sell' || signalType === 'close_long') {\n        rsiScore = Math.max(0, Math.min(1, (rsi - 30) / 40));\n      }\n    }\n\n    const macdHistogram = this.getIndicatorValue(indicatorValues, 'macd.histogram');\n    let macdScore = 0;\n    if (macdHistogram !== null) {\n      const normalized = Math.min(1, Math.abs(macdHistogram) / 2);\n      if (signalType === 'buy' || signalType === 'close_short') {\n        macdScore = macdHistogram > 0 ? normalized : 0;\n      } else if (signalType === 'sell' || signalType === 'close_long') {\n        macdScore = macdHistogram < 0 ? normalized : 0;\n      }\n    }\n\n    const stochasticK = this.getIndicatorValue(indicatorValues, 'stochastic.k');\n    const stochasticD = this.getIndicatorValue(indicatorValues, 'stochastic.d');\n    let stochasticScore = 0;\n    if (stochasticK !== null && stochasticD !== null) {\n      const diff = stochasticK - stochasticD;\n      const normalizedDiff = Math.min(1, Math.abs(diff) / 20);\n      if (signalType === 'buy' || signalType === 'close_short') {\n        stochasticScore = diff > 0 ? normalizedDiff : 0;\n      } else if (signalType === 'sell' || signalType === 'close_long') {\n        stochasticScore = diff < 0 ? normalizedDiff : 0;\n      }\n    }\n\n    const scoreComponents = [strengthRatio];\n    if (rsiScore > 0) scoreComponents.push(rsiScore);\n    if (macdScore > 0) scoreComponents.push(macdScore);\n    if (stochasticScore > 0) scoreComponents.push(stochasticScore);\n\n    const confidence = scoreComponents.length\n      ? scoreComponents.reduce((sum, value) => sum + value, 0) / scoreComponents.length\n      : strengthRatio;\n\n    return {\n      strength: Math.round(strengthRatio * 100),\n      confidence: Number(Math.min(1, Math.max(0, confidence)).toFixed(2)),\n    };\n  }\n\n  /**\n   * Run backtest asynchronously with full simulation\n   */\n  private async runBacktestAsync(\n    backtestId: string,\n    strategy: TradingStrategy,\n    request: RunBacktestRequest\n  ): Promise<void> {\n    try {\n      logger.info('Starting backtest execution', { backtestId, strategyId: strategy.id });\n\n      // 1. Fetch historical OHLCV data\n      const ohlcvData = await OHLCVService.fetchOHLCV({\n        exchangeId: strategy.exchangeId,\n        symbol: strategy.symbol,\n        timeframe: strategy.timeframe as any,\n        since: request.startDate,\n        limit: 10000, // Maximum data points\n      });\n\n      if (ohlcvData.length === 0) {\n        throw new Error('No historical data available for the specified period');\n      }\n\n      logger.info('Historical data fetched', {\n        backtestId,\n        candlesCount: ohlcvData.length,\n        startDate: ohlcvData[0].timestamp,\n        endDate: ohlcvData[ohlcvData.length - 1].timestamp,\n      });\n\n      // 2. Initialize backtest state\n      let capital = request.initialCapital;\n      let position: {\n        side: 'long' | 'short';\n        entryPrice: number;\n        entryTime: Date;\n        quantity: number;\n      } | null = null;\n\n      const trades: BacktestTrade[] = [];\n      const equityCurve: EquityCurvePoint[] = [];\n      const maxEquity = capital;\n      let maxDrawdown = 0;\n      let peakCapital = capital;\n\n      const SLIPPAGE_PERCENT = 0.1; // 0.1%\n      const FEE_PERCENT = 0.1; // 0.1%\n\n      // 3. Simulate strategy execution candle by candle\n      for (let i = 0; i < ohlcvData.length; i++) {\n        const currentCandle = ohlcvData[i];\n        const historicalData = ohlcvData.slice(0, i + 1);\n\n        // Calculate indicators for current state\n        const indicatorValues = await this.calculateIndicators(\n          historicalData,\n          strategy.indicators as any\n        );\n\n        // Evaluate conditions to generate signal\n        const signal = this.evaluateConditions(indicatorValues, strategy.conditions as any);\n\n        // Current equity (capital + unrealized PnL)\n        let currentEquity = capital;\n        if (position) {\n          const unrealizedPnl = this.calculateUnrealizedPnL(position, currentCandle.close);\n          currentEquity += unrealizedPnl;\n        }\n\n        // Update drawdown\n        if (currentEquity > peakCapital) {\n          peakCapital = currentEquity;\n        }\n        const drawdown = peakCapital - currentEquity;\n        const drawdownPercent = (drawdown / peakCapital) * 100;\n        if (drawdown > maxDrawdown) {\n          maxDrawdown = drawdown;\n        }\n\n        // Record equity curve\n        equityCurve.push({\n          timestamp: currentCandle.timestamp,\n          equity: currentEquity,\n          drawdown: drawdownPercent,\n        });\n\n        // Check stop loss and take profit\n        if (position) {\n          const shouldExit = this.shouldExitPosition(\n            position,\n            currentCandle.close,\n            strategy.stopLossPercent,\n            strategy.takeProfitPercent\n          );\n\n          if (shouldExit) {\n            // Close position\n            const exitPrice = this.applySlippage(\n              currentCandle.close,\n              position.side === 'long' ? 'sell' : 'buy',\n              SLIPPAGE_PERCENT\n            );\n            const pnl = this.calculatePnL(position, exitPrice, FEE_PERCENT);\n            capital += pnl;\n\n            trades.push({\n              entryTime: position.entryTime,\n              entryPrice: position.entryPrice,\n              exitTime: currentCandle.timestamp,\n              exitPrice,\n              quantity: position.quantity,\n              side: position.side,\n              pnl,\n              pnlPercent: (pnl / (position.entryPrice * position.quantity)) * 100,\n              fees: (position.entryPrice * position.quantity * FEE_PERCENT) / 100 +\n                    (exitPrice * position.quantity * FEE_PERCENT) / 100,\n              reason: shouldExit.reason,\n            });\n\n            position = null;\n            logger.debug('Position closed', { backtestId, pnl, reason: shouldExit.reason });\n          }\n        }\n\n        // Execute signal if no position\n        if (!position && signal && (signal === 'buy' || signal === 'sell')) {\n          const side = signal === 'buy' ? 'long' : 'short';\n          const entryPrice = this.applySlippage(currentCandle.close, signal, SLIPPAGE_PERCENT);\n\n          // Calculate position size (risk management)\n          const maxPositionSize = strategy.maxPositionSize || capital;\n          const positionCapital = Math.min(capital * 0.95, maxPositionSize); // Use 95% max\n          const quantity = positionCapital / entryPrice;\n\n          position = {\n            side,\n            entryPrice,\n            entryTime: currentCandle.timestamp,\n            quantity,\n          };\n\n          logger.debug('Position opened', { backtestId, side, entryPrice, quantity });\n        }\n      }\n\n      // Close any remaining open position at the end\n      if (position) {\n        const lastCandle = ohlcvData[ohlcvData.length - 1];\n        const exitPrice = this.applySlippage(\n          lastCandle.close,\n          position.side === 'long' ? 'sell' : 'buy',\n          SLIPPAGE_PERCENT\n        );\n        const pnl = this.calculatePnL(position, exitPrice, FEE_PERCENT);\n        capital += pnl;\n\n        trades.push({\n          entryTime: position.entryTime,\n          entryPrice: position.entryPrice,\n          exitTime: lastCandle.timestamp,\n          exitPrice,\n          quantity: position.quantity,\n          side: position.side,\n          pnl,\n          pnlPercent: (pnl / (position.entryPrice * position.quantity)) * 100,\n          fees: (position.entryPrice * position.quantity * FEE_PERCENT) / 100 +\n                (exitPrice * position.quantity * FEE_PERCENT) / 100,\n          reason: 'End of backtest period',\n        });\n      }\n\n      // 4. Calculate performance metrics\n      const finalCapital = capital;\n      const totalReturn = finalCapital - request.initialCapital;\n      const totalReturnPercent = (totalReturn / request.initialCapital) * 100;\n\n      const winningTrades = trades.filter((t) => t.pnl > 0);\n      const losingTrades = trades.filter((t) => t.pnl <= 0);\n      const winRate = trades.length > 0 ? (winningTrades.length / trades.length) * 100 : 0;\n\n      const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnl, 0);\n      const grossLoss = Math.abs(losingTrades.reduce((sum, t) => sum + t.pnl, 0));\n      const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999 : 0;\n\n      const averageWin = winningTrades.length > 0\n        ? winningTrades.reduce((sum, t) => sum + t.pnl, 0) / winningTrades.length\n        : 0;\n      const averageLoss = losingTrades.length > 0\n        ? losingTrades.reduce((sum, t) => sum + t.pnl, 0) / losingTrades.length\n        : 0;\n\n      const largestWin = winningTrades.length > 0\n        ? Math.max(...winningTrades.map((t) => t.pnl))\n        : 0;\n      const largestLoss = losingTrades.length > 0\n        ? Math.min(...losingTrades.map((t) => t.pnl))\n        : 0;\n\n      // Calculate Sharpe Ratio (simplified)\n      const returns = trades.map((t) => t.pnlPercent);\n      const averageReturn = returns.length > 0\n        ? returns.reduce((sum, r) => sum + r, 0) / returns.length\n        : 0;\n      const stdDevReturns = returns.length > 1\n        ? Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - averageReturn, 2), 0) / (returns.length - 1))\n        : 0;\n      const sharpeRatio = stdDevReturns > 0 ? averageReturn / stdDevReturns : 0;\n\n      const maxDrawdownPercent = peakCapital > 0 ? (maxDrawdown / peakCapital) * 100 : 0;\n\n      logger.info('Backtest metrics calculated', {\n        backtestId,\n        totalTrades: trades.length,\n        winRate,\n        profitFactor,\n        sharpeRatio,\n      });\n\n      // 5. Store results in database\n      await db\n        .update(strategyBacktests)\n        .set({\n          status: 'completed',\n          finalCapital: finalCapital.toString(),\n          totalReturn: totalReturn.toString(),\n          totalReturnPercent: totalReturnPercent.toFixed(2),\n          totalTrades: trades.length.toString(),\n          winningTrades: winningTrades.length.toString(),\n          losingTrades: losingTrades.length.toString(),\n          winRate: winRate.toFixed(2),\n          profitFactor: profitFactor.toFixed(2),\n          sharpeRatio: sharpeRatio.toFixed(2),\n          maxDrawdown: maxDrawdown.toString(),\n          maxDrawdownPercent: maxDrawdownPercent.toFixed(2),\n          averageWin: averageWin.toString(),\n          averageLoss: averageLoss.toString(),\n          largestWin: largestWin.toString(),\n          largestLoss: largestLoss.toString(),\n          trades: trades as any,\n          equityCurve: equityCurve as any,\n          completedAt: new Date(),\n        })\n        .where(eq(strategyBacktests.id, backtestId));\n\n      logger.info('Backtest completed successfully', { backtestId, finalCapital, totalReturn });\n    } catch (error) {\n      logger.error('Backtest failed', { backtestId, error });\n\n      await db\n        .update(strategyBacktests)\n        .set({\n          status: 'failed',\n          errorMessage: error instanceof Error ? error.message : 'Unknown error',\n        })\n        .where(eq(strategyBacktests.id, backtestId));\n    }\n  }\n\n  /**\n   * Calculate unrealized PnL for an open position\n   */\n  private calculateUnrealizedPnL(\n    position: { side: 'long' | 'short'; entryPrice: number; quantity: number },\n    currentPrice: number\n  ): number {\n    if (position.side === 'long') {\n      return (currentPrice - position.entryPrice) * position.quantity;\n    } else {\n      return (position.entryPrice - currentPrice) * position.quantity;\n    }\n  }\n\n  /**\n   * Check if position should be exited based on stop loss or take profit\n   */\n  private shouldExitPosition(\n    position: { side: 'long' | 'short'; entryPrice: number },\n    currentPrice: number,\n    stopLossPercent?: number,\n    takeProfitPercent?: number\n  ): { shouldExit: boolean; reason: string } | null {\n    if (position.side === 'long') {\n      // Check stop loss\n      if (stopLossPercent) {\n        const stopLossPrice = position.entryPrice * (1 - stopLossPercent / 100);\n        if (currentPrice <= stopLossPrice) {\n          return { shouldExit: true, reason: 'Stop loss triggered' };\n        }\n      }\n\n      // Check take profit\n      if (takeProfitPercent) {\n        const takeProfitPrice = position.entryPrice * (1 + takeProfitPercent / 100);\n        if (currentPrice >= takeProfitPrice) {\n          return { shouldExit: true, reason: 'Take profit triggered' };\n        }\n      }\n    } else {\n      // Short position\n      // Check stop loss\n      if (stopLossPercent) {\n        const stopLossPrice = position.entryPrice * (1 + stopLossPercent / 100);\n        if (currentPrice >= stopLossPrice) {\n          return { shouldExit: true, reason: 'Stop loss triggered' };\n        }\n      }\n\n      // Check take profit\n      if (takeProfitPercent) {\n        const takeProfitPrice = position.entryPrice * (1 - takeProfitPercent / 100);\n        if (currentPrice <= takeProfitPrice) {\n          return { shouldExit: true, reason: 'Take profit triggered' };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Apply slippage to execution price\n   */\n  private applySlippage(price: number, side: string, slippagePercent: number): number {\n    if (side === 'buy') {\n      return price * (1 + slippagePercent / 100);\n    } else {\n      return price * (1 - slippagePercent / 100);\n    }\n  }\n\n  /**\n   * Calculate realized PnL for a closed position\n   */\n  private calculatePnL(\n    position: { side: 'long' | 'short'; entryPrice: number; quantity: number },\n    exitPrice: number,\n    feePercent: number\n  ): number {\n    let pnl: number;\n\n    if (position.side === 'long') {\n      pnl = (exitPrice - position.entryPrice) * position.quantity;\n    } else {\n      pnl = (position.entryPrice - exitPrice) * position.quantity;\n    }\n\n    // Subtract fees\n    const entryFee = (position.entryPrice * position.quantity * feePercent) / 100;\n    const exitFee = (exitPrice * position.quantity * feePercent) / 100;\n    pnl -= (entryFee + exitFee);\n\n    return pnl;\n  }\n\n  /**\n   * Map strategy from database\n   */\n  private mapStrategyFromDb(strategy: any): TradingStrategy {\n    return {\n      id: strategy.id,\n      userId: strategy.userId,\n      tenantId: strategy.tenantId,\n      name: strategy.name,\n      description: strategy.description,\n      version: strategy.version,\n      exchangeId: strategy.exchangeId,\n      symbol: strategy.symbol,\n      timeframe: strategy.timeframe,\n      type: strategy.type,\n      indicators: strategy.indicators,\n      conditions: strategy.conditions,\n      parameters: strategy.parameters,\n      stopLossPercent: strategy.stopLossPercent ? parseFloat(strategy.stopLossPercent) : undefined,\n      takeProfitPercent: strategy.takeProfitPercent\n        ? parseFloat(strategy.takeProfitPercent)\n        : undefined,\n      trailingStopPercent: strategy.trailingStopPercent\n        ? parseFloat(strategy.trailingStopPercent)\n        : undefined,\n      maxPositionSize: strategy.maxPositionSize ? parseFloat(strategy.maxPositionSize) : undefined,\n      maxDrawdownPercent: strategy.maxDrawdownPercent\n        ? parseFloat(strategy.maxDrawdownPercent)\n        : undefined,\n      status: strategy.status,\n      isPublic: strategy.isPublic,\n      totalTrades: parseFloat(strategy.totalTrades),\n      winningTrades: parseFloat(strategy.winningTrades),\n      losingTrades: parseFloat(strategy.losingTrades),\n      totalPnl: parseFloat(strategy.totalPnl),\n      winRate: strategy.winRate ? parseFloat(strategy.winRate) : undefined,\n      profitFactor: strategy.profitFactor ? parseFloat(strategy.profitFactor) : undefined,\n      sharpeRatio: strategy.sharpeRatio ? parseFloat(strategy.sharpeRatio) : undefined,\n      maxDrawdown: strategy.maxDrawdown ? parseFloat(strategy.maxDrawdown) : undefined,\n      tags: strategy.tags,\n      notes: strategy.notes,\n      createdAt: strategy.createdAt,\n      updatedAt: strategy.updatedAt,\n      lastRunAt: strategy.lastRunAt,\n    };\n  }\n\n  /**\n   * Map signal from database\n   */\n  private mapSignalFromDb(signal: any): StrategySignal {\n    return {\n      id: signal.id,\n      strategyId: signal.strategyId,\n      userId: signal.userId,\n      tenantId: signal.tenantId,\n      exchangeId: signal.exchangeId,\n      symbol: signal.symbol,\n      timeframe: signal.timeframe,\n      type: signal.type,\n      strength: signal.strength ? parseFloat(signal.strength) : undefined,\n      confidence: signal.confidence ? parseFloat(signal.confidence) : undefined,\n      price: parseFloat(signal.price),\n      stopLoss: signal.stopLoss ? parseFloat(signal.stopLoss) : undefined,\n      takeProfit: signal.takeProfit ? parseFloat(signal.takeProfit) : undefined,\n      indicatorValues: signal.indicatorValues,\n      status: signal.status,\n      orderId: signal.orderId,\n      executedPrice: signal.executedPrice ? parseFloat(signal.executedPrice) : undefined,\n      executedAt: signal.executedAt,\n      pnl: signal.pnl ? parseFloat(signal.pnl) : undefined,\n      pnlPercent: signal.pnlPercent ? parseFloat(signal.pnlPercent) : undefined,\n      reason: signal.reason,\n      notes: signal.notes,\n      timestamp: signal.timestamp,\n      expiresAt: signal.expiresAt,\n    };\n  }\n\n  /**\n   * Map backtest from database\n   */\n  private mapBacktestFromDb(backtest: any): StrategyBacktest {\n    return {\n      id: backtest.id,\n      strategyId: backtest.strategyId,\n      userId: backtest.userId,\n      tenantId: backtest.tenantId,\n      startDate: backtest.startDate,\n      endDate: backtest.endDate,\n      initialCapital: parseFloat(backtest.initialCapital),\n      finalCapital: backtest.finalCapital ? parseFloat(backtest.finalCapital) : undefined,\n      totalReturn: backtest.totalReturn ? parseFloat(backtest.totalReturn) : undefined,\n      totalReturnPercent: backtest.totalReturnPercent\n        ? parseFloat(backtest.totalReturnPercent)\n        : undefined,\n      totalTrades: backtest.totalTrades ? parseFloat(backtest.totalTrades) : undefined,\n      winningTrades: backtest.winningTrades ? parseFloat(backtest.winningTrades) : undefined,\n      losingTrades: backtest.losingTrades ? parseFloat(backtest.losingTrades) : undefined,\n      winRate: backtest.winRate ? parseFloat(backtest.winRate) : undefined,\n      profitFactor: backtest.profitFactor ? parseFloat(backtest.profitFactor) : undefined,\n      sharpeRatio: backtest.sharpeRatio ? parseFloat(backtest.sharpeRatio) : undefined,\n      sortinoRatio: backtest.sortinoRatio ? parseFloat(backtest.sortinoRatio) : undefined,\n      maxDrawdown: backtest.maxDrawdown ? parseFloat(backtest.maxDrawdown) : undefined,\n      maxDrawdownPercent: backtest.maxDrawdownPercent\n        ? parseFloat(backtest.maxDrawdownPercent)\n        : undefined,\n      averageWin: backtest.averageWin ? parseFloat(backtest.averageWin) : undefined,\n      averageLoss: backtest.averageLoss ? parseFloat(backtest.averageLoss) : undefined,\n      largestWin: backtest.largestWin ? parseFloat(backtest.largestWin) : undefined,\n      largestLoss: backtest.largestLoss ? parseFloat(backtest.largestLoss) : undefined,\n      trades: backtest.trades,\n      equityCurve: backtest.equityCurve,\n      status: backtest.status,\n      errorMessage: backtest.errorMessage,\n      createdAt: backtest.createdAt,\n      completedAt: backtest.completedAt,\n    };\n  }\n}\n\n// Export singleton instance\nexport const strategyService = new StrategyService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/strategies/types/strategies.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/routes/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/routes/authenticated.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/routes/public.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/routes/usage.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/schema/subscription-history.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/schema/subscription-plans.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/schema/subscription-usage.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/seeds/run-seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/seeds/subscription-plans.seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/services/quota.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/services/subscription-management.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/services/subscription-plans.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/services/usage-tracking.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/tests/create-test-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/tests/test-services.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/types/stripe.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/subscriptions/validators/subscription.validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/__tests__/business-hours.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/__tests__/sla-calculator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/__tests__/ticket-numbering.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/analytics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/automations.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/canned-responses.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/kb.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/sla.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/routes/tickets.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/automations.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/canned-responses.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/knowledge-base.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/sla-policies.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/ticket-messages.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/schema/tickets.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/analytics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/automations.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/canned-responses.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/knowledge-base.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/sla.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/services/tickets.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/types/support.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/utils/business-hours.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/utils/sla-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/support/utils/ticket-numbering.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/__tests__/tenant.routes.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/__tests__/tenant.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/events/membership-event-bus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/routes/tenant.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getTenantById' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getTenantMembers' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCompanyTenant' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tenant Routes\n * Routes for tenant management and membership\n */\n\nimport { Elysia, t } from 'elysia';\nimport { sessionGuard } from '../../auth/middleware/session.middleware';\nimport { ensureTenantMember, ensureTenantAdmin } from '../services/tenant.service';\nimport { TENANT_ROLES } from '../types/tenant.types';\nimport {\n  getTenantById,\n  getUserTenants,\n  getTenantMembers,\n  addTenantMember,\n  removeTenantMember,\n  promoteToCEO,\n  getCompanyTenant,\n} from '../services/tenant.service';\nimport { TenantsCacheService } from '../services/tenant-cache.service';\n\n/**\n * Tenant routes plugin\n */\nexport const tenantRoutes = new Elysia({ prefix: '/api/v1/tenants', name: 'tenant-routes' })\n  .use(sessionGuard)\n\n  // Get all user's tenants\n  .get(\n    '/me',\n    async ({ user }) => {\n      const tenants = await getUserTenants(user.id);\n      return {\n        success: true,\n        data: tenants.map(t => ({\n          tenant: t.tenant,\n          role: t.membership.role,\n          status: t.membership.status,\n          joinedAt: t.membership.joinedAt,\n        })),\n      };\n    },\n    {\n      detail: {\n        tags: ['Tenants'],\n        summary: 'Get my tenants',\n        description: 'Get all tenants the current user is a member of',\n      },\n    }\n  )\n\n  // Get tenant by ID\n  .get(\n    '/:id',\n    async ({ params, user }) => {\n      await ensureTenantMember(params.id, user.id);\n      const tenant = await TenantsCacheService.getTenant(params.id);\n      return { success: true, data: tenant };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      detail: {\n        tags: ['Tenants'],\n        summary: 'Get tenant by ID',\n        description: 'Get tenant details by ID',\n      },\n    }\n  )\n\n  // Get tenant members\n  .get(\n    '/:id/members',\n    async ({ params, user, query }) => {\n      await ensureTenantAdmin(params.id, user.id);\n      const page = query.page ?? 1;\n      const limit = query.limit ?? 50;\n      const result = await getTenantMembersPaginated(params.id, page, limit);\n      return { success: true, data: result.data, pagination: result.pagination };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      query: t.Object({\n        page: t.Optional(t.Number()),\n        limit: t.Optional(t.Number()),\n      }),\n      detail: {\n        tags: ['Tenants'],\n        summary: 'Get tenant members',\n        description: 'Get tenant members with pagination',\n      },\n    }\n  )\n\n  // Add member to tenant\n  .post(\n    '/:id/members',\n    async ({ params, body, user }) => {\n      await ensureTenantAdmin(params.id, user.id);\n      const member = await addTenantMember(\n        params.id,\n        body.userId,\n        body.role,\n        body.permissions\n      );\n      return { success: true, data: member };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n      }),\n      body: (() => {\n        const roleLiterals = (TENANT_ROLES as readonly string[]).map((r) => t.Literal(r));\n        return t.Object({\n          userId: t.String({ minLength: 3 }),\n          role: t.Union(roleLiterals as any),\n          permissions: t.Optional(t.Record(t.String(), t.Any())),\n        });\n      })(),\n      detail: {\n        tags: ['Tenants'],\n        summary: 'Add member to tenant',\n        description: 'Add a user as a member of a tenant',\n      },\n    }\n  )\n\n  // Remove member from tenant\n  .delete(\n    '/:id/members/:userId',\n    async ({ params, user }) => {\n      await ensureTenantAdmin(params.id, user.id);\n      const result = await removeTenantMember(params.id, params.userId);\n      return { success: true, data: result };\n    },\n    {\n      params: t.Object({\n        id: t.String(),\n        userId: t.String(),\n      }),\n      detail: {\n        tags: ['Tenants'],\n        summary: 'Remove member from tenant',\n        description: 'Remove a user from a tenant',\n      },\n    }\n  )\n\n  // **SPECIAL ENDPOINT**: Promote current user to CEO\n  // This endpoint is for initial setup/onboarding\n  .post(\n    '/promote-me-to-ceo',\n    async ({ user }) => {\n      const result = await promoteToCEO(user.id);\n      return {\n        success: true,\n        message: `User ${result.action} as CEO of company tenant`,\n        data: {\n          tenant: result.tenant,\n          role: result.membership.role,\n          action: result.action,\n        },\n      };\n    },\n    {\n      detail: {\n        tags: ['Tenants'],\n        summary: '[SETUP] Promote to CEO',\n        description: 'Promote current user to CEO of the company tenant (for initial setup)',\n      },\n    }\n  )\n\n  // Get company tenant info\n  .get(\n    '/company/info',\n    async ({ user }) => {\n      const tenant = await TenantsCacheService.getCompanyTenant();\n      // Require membership to view company tenant details\n      await ensureTenantMember(tenant.id, user.id);\n      return { success: true, data: tenant };\n    },\n    {\n      detail: {\n        tags: ['Tenants'],\n        summary: 'Get company tenant',\n        description: 'Get the company tenant information',\n      },\n    }\n  );\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/schema/tenants.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/services/membership.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/services/tenant-cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/services/tenant.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/test-helpers/db-access.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/tenants/types/tenant.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/__tests__/profile-type.util.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/__tests__/user.routes.integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":35,"column":59,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeAll, afterAll } from 'bun:test';\nimport { Elysia } from 'elysia';\nimport { userRoutes } from '../routes/user.routes';\nimport { auth } from '../../auth/services/auth.config';\nimport { UsersProfileService } from '../services/user-profile-cache.service';\nimport { UsersTenantsCacheService } from '../services/user-tenants-cache.service';\n\ndescribe('user.routes integration', () => {\n  const originalGetSession = (auth as any).api.getSession;\n  const originalGetProfile = (UsersProfileService as any).getProfile;\n  const originalGetTenants = (UsersTenantsCacheService as any).getTenants;\n\n  beforeAll(() => {\n    // Stub auth session\n    (auth as any).api.getSession = async () => ({\n      user: { id: 'u1', emailVerified: true, name: 'Alice', email: 'alice@mail.com' },\n      session: { id: 's1', activeOrganizationId: 't1' },\n    });\n\n    // Stub profile cache service\n    (UsersProfileService as any).getProfile = async (userId: string, tenantId?: string) => ({\n      userId,\n      role: 'admin',\n      profileType: 'company',\n      isActive: true,\n      name: 'Alice',\n      email: 'alice@mail.com',\n      emailVerified: true,\n      tenantId,\n      tenantName: 'Empresa X',\n      tenantStatus: 'active',\n    });\n\n    // Stub tenants cache service\n    (UsersTenantsCacheService as any).getTenants = async (userId: string) => ([\n      { id: 't1', name: 'Empresa X', slug: 'empresa-x', type: 'empresa', status: 'active', role: 'admin', memberStatus: 'active', joinedAt: new Date(), profileType: 'company' },\n    ]);\n  });\n\n  afterAll(() => {\n    (auth as any).api.getSession = originalGetSession;\n    (UsersProfileService as any).getProfile = originalGetProfile;\n    (UsersTenantsCacheService as any).getTenants = originalGetTenants;\n  });\n\n  it('GET /api/v1/user/profile retorna { success, data }', async () => {\n    const app = new Elysia().use(userRoutes);\n    const res = await app.handle(new Request('http://localhost/api/v1/user/profile'));\n    expect(res.status).toBe(200);\n    const json = await res.json();\n    expect(json.success).toBe(true);\n    expect(json.data.userId).toBe('u1');\n  });\n\n  it('GET /api/v1/user/tenants retorna { success, data, total }', async () => {\n    const app = new Elysia().use(userRoutes);\n    const res = await app.handle(new Request('http://localhost/api/v1/user/tenants'));\n    expect(res.status).toBe(200);\n    const json = await res.json();\n    expect(json.success).toBe(true);\n    expect(Array.isArray(json.data)).toBe(true);\n    expect(json.total).toBe(1);\n  });\n\n  it('GET /api/v1/user/active-tenant retorna { success, data }', async () => {\n    const app = new Elysia().use(userRoutes);\n    const res = await app.handle(new Request('http://localhost/api/v1/user/active-tenant'));\n    expect(res.status).toBe(200);\n    const json = await res.json();\n    expect(json.success).toBe(true);\n    expect(json.data.id).toBe('t1');\n  });\n});\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/__tests__/user.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/routes/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/routes/user.routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getUserProfile' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * User Routes\n * Routes for user profile and management\n */\n\nimport { Elysia, t } from 'elysia';\nimport { sessionGuard } from '../../auth/middleware/session.middleware';\nimport { getUserProfile, getUserTenants } from '../services/user.service';\nimport { setActiveOrganization } from '../../auth/services/session.service';\nimport { UsersProfileService } from '../services/user-profile-cache.service';\nimport { UsersTenantsCacheService } from '../services/user-tenants-cache.service';\nimport { BadRequestError, NotFoundError } from '@/utils/errors';\n\n/**\n * User routes plugin\n */\nexport const userRoutes = new Elysia({ prefix: '/api/v1/user', name: 'user-routes' })\n  .use(sessionGuard)\n  .get(\n    '/profile',\n    async ({ user, session }) => {\n      // sessionGuard ensures user is authenticated\n      // Get activeTenantId from session (stored as activeOrganizationId in Better-Auth)\n      const activeTenantId = (session as any)?.activeOrganizationId || undefined;\n      const profile = await UsersProfileService.getProfile(user.id, activeTenantId);\n      return { success: true, data: profile };\n    },\n    {\n      detail: {\n        tags: ['User'],\n        summary: 'Get user profile',\n        description: 'Get current user profile with role and profile type',\n      },\n      response: {\n        200: t.Object({\n          // Core identity\n          userId: t.String({ description: 'User ID' }),\n          role: t.String({ description: 'User role (ceo, admin, funcionario, trader, influencer, manager, viewer)' }),\n          profileType: t.String({ description: 'Profile type (company, trader, influencer)' }),\n          isActive: t.Boolean({ description: 'Whether user is active' }),\n          // User data\n          name: t.String({ description: 'User full name' }),\n          email: t.String({ description: 'User email address' }),\n          emailVerified: t.Boolean({ description: 'Whether email is verified' }),\n          image: t.Optional(t.String({ description: 'User profile image URL' })),\n          // Tenant info\n          tenantId: t.Optional(t.String({ description: 'Tenant ID' })),\n          tenantName: t.Optional(t.String({ description: 'Tenant name' })),\n          tenantStatus: t.Optional(t.String({ description: 'Tenant status (active, inactive, suspended)' })),\n          // Member-specific\n          permissions: t.Optional(t.Record(t.String(), t.Any(), { description: 'User permissions within tenant' })),\n          joinedAt: t.Optional(t.Date({ description: 'Date when user joined the tenant' })),\n          // Legacy/optional\n          phone: t.Optional(t.String({ description: 'User phone number' })),\n          avatar: t.Optional(t.String({ description: 'User avatar URL' })),\n        }),\n      },\n    }\n  )\n\n  // List all tenants for current user\n  .get(\n    '/tenants',\n    async ({ user }) => {\n      const tenants = await UsersTenantsCacheService.getTenants(user.id);\n      return { success: true, data: tenants, total: tenants.length };\n    },\n    {\n      detail: {\n        tags: ['User'],\n        summary: 'List user tenants',\n        description: 'Get list of all tenants where user is a member',\n      },\n    }\n  )\n\n  // Switch active tenant\n  .post(\n    '/switch-tenant',\n    async ({ user, session, body }) => {\n      // Verify user is member of the tenant\n      const userTenants = await getUserTenants(user.id);\n      const targetTenant = userTenants.find((t) => t.id === body.tenantId);\n\n      if (!targetTenant) {\n        throw new NotFoundError('Tenant not found or user is not a member', {\n          tenantId: body.tenantId,\n        });\n      }\n\n      // Update session with new active tenant\n      if (!session?.id) {\n        throw new BadRequestError('No active session found');\n      }\n\n      await setActiveOrganization(session.id, body.tenantId);\n      await UsersProfileService.invalidateProfile(user.id);\n\n      // Get updated profile with new tenant\n      const profile = await UsersProfileService.getProfile(user.id, body.tenantId);\n\n      return { success: true, data: { activeTenant: { id: targetTenant.id, name: targetTenant.name, type: targetTenant.type, profileType: targetTenant.profileType }, profile } };\n    },\n    {\n      body: t.Object({\n        tenantId: t.String({ description: 'Tenant ID to switch to', minLength: 3, maxLength: 64, pattern: '^[A-Za-z0-9_-]+$' }),\n      }),\n      detail: {\n        tags: ['User'],\n        summary: 'Switch active tenant',\n        description: 'Switch the active tenant context for the current session',\n      },\n    }\n  )\n\n  // Get active tenant\n  .get(\n    '/active-tenant',\n    async ({ user, session }) => {\n      const activeTenantId = (session as any)?.activeOrganizationId;\n\n      if (!activeTenantId) {\n        // No active tenant set, return user's first tenant\n        const tenants = await UsersTenantsCacheService.getTenants(user.id);\n        if (tenants.length === 0) {\n          return {\n            success: false,\n            message: 'User has no tenant memberships',\n            data: null,\n          };\n        }\n\n        return { success: true, data: { id: tenants[0].id, name: tenants[0].name, type: tenants[0].type, profileType: tenants[0].profileType, isDefault: true } };\n      }\n\n      // Get active tenant details\n      const tenants = await UsersTenantsCacheService.getTenants(user.id);\n      const activeTenant = tenants.find((t) => t.id === activeTenantId);\n\n      if (!activeTenant) {\n        throw new NotFoundError('Active tenant not found', {\n          tenantId: activeTenantId,\n        });\n      }\n\n      return { success: true, data: { id: activeTenant.id, name: activeTenant.name, type: activeTenant.type, profileType: activeTenant.profileType, role: activeTenant.role, memberStatus: activeTenant.status } };\n    },\n    {\n      detail: {\n        tags: ['User'],\n        summary: 'Get active tenant',\n        description: 'Get the currently active tenant for the session',\n      },\n    }\n  );\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/schema/user-profile.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/services/membership-events.consumer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/services/profile.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/services/user-profile-cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/services/user-tenants-cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/services/user.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/test-helpers/db-access.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/types/user.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/modules/users/utils/profile-type.util.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/collectors/bots.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/collectors/cache.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/collectors/http.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/collectors/risk.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/collectors/system.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/collectors/trading.metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/metrics/registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/middleware/metrics.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/routes/metrics.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/monitoring/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/routes/error.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/routes/health.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/routes/info.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-all-endpoints.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-binance-debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-binance-single.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-coinbase-debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-coinbase-single.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-exchange-websockets.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env bun\n/**\n * Exchange WebSocket Testing Utility\n *\n * Tests WebSocket connections to real exchanges (testnet/mainnet)\n * Verifies event reception, measures latency, and validates Redis integration\n *\n * Usage:\n *   bun run src/scripts/test-exchange-websockets.ts [options]\n *\n * Options:\n *   --exchange <name>    Test specific exchange (binance, coinbase, kraken)\n *   --all                Test all exchanges\n *   --symbol <symbol>    Symbol to test (default: BTC/USDT)\n *   --duration <seconds> Test duration (default: 30)\n *   --redis              Enable Redis testing\n *   --verbose            Verbose output\n */\n\nimport { MarketDataWebSocketManager } from '@/modules/market-data/websocket';\nimport type { ExchangeId, Ticker, Trade, OrderBook } from '@/modules/market-data/websocket/types';\nimport logger from '@/utils/logger';\n\n// Test configuration\ninterface TestConfig {\n  exchange: ExchangeId;\n  symbol: string;\n  duration: number; // seconds\n  enableRedis: boolean;\n  verbose: boolean;\n}\n\n// Test results\ninterface ExchangeTestResult {\n  exchange: ExchangeId;\n  symbol: string;\n  duration: number;\n  success: boolean;\n  error?: string;\n  metrics: {\n    connected: boolean;\n    tickersReceived: number;\n    tradesReceived: number;\n    orderbooksReceived: number;\n    firstEventTime?: number;\n    lastEventTime?: number;\n    averageLatency?: number;\n    minLatency?: number;\n    maxLatency?: number;\n  };\n  redisMetrics?: {\n    enabled: boolean;\n    publishedEvents: number;\n    receivedEvents: number;\n    errors: number;\n  };\n}\n\n// Exchange configurations\nconst EXCHANGE_CONFIGS = {\n  binance: {\n    mainnet: 'wss://stream.binance.com:9443/ws',\n    testnet: 'wss://testnet.binance.vision/ws',\n    defaultSymbol: 'BTC/USDT',\n  },\n  coinbase: {\n    mainnet: 'wss://ws-feed.exchange.coinbase.com',\n    sandbox: 'wss://ws-feed-public.sandbox.exchange.coinbase.com',\n    defaultSymbol: 'BTC-USD',\n  },\n  kraken: {\n    mainnet: 'wss://ws.kraken.com',\n    beta: 'wss://ws-auth.kraken.com',\n    defaultSymbol: 'XBT/USD',\n  },\n};\n\n/**\n * Test single exchange\n */\nasync function testExchange(config: TestConfig): Promise<ExchangeTestResult> {\n  const startTime = Date.now();\n  const result: ExchangeTestResult = {\n    exchange: config.exchange,\n    symbol: config.symbol,\n    duration: config.duration,\n    success: false,\n    metrics: {\n      connected: false,\n      tickersReceived: 0,\n      tradesReceived: 0,\n      orderbooksReceived: 0,\n    },\n  };\n\n  const latencies: number[] = [];\n\n  try {\n    console.log(`\\n${'='.repeat(60)}`);\n    console.log(`Testing ${config.exchange.toUpperCase()} - ${config.symbol}`);\n    console.log(`Duration: ${config.duration}s | Redis: ${config.enableRedis ? 'Enabled' : 'Disabled'}`);\n    console.log('='.repeat(60));\n\n    // Create manager\n    const manager = new MarketDataWebSocketManager({\n      enableRedis: config.enableRedis,\n      redis: config.enableRedis ? {\n        host: 'localhost',\n        port: 6379,\n        keyPrefix: 'test:ws:',\n        enablePublishing: true,\n        enableSubscription: true,\n      } : undefined,\n    });\n\n    // Set up event listeners\n    manager.on('ticker', (ticker: Ticker) => {\n      result.metrics.tickersReceived++;\n      const latency = Date.now() - ticker.timestamp;\n      latencies.push(latency);\n\n      if (!result.metrics.firstEventTime) {\n        result.metrics.firstEventTime = Date.now();\n        console.log(`✓ First ticker received in ${Date.now() - startTime}ms`);\n      }\n      result.metrics.lastEventTime = Date.now();\n\n      if (config.verbose) {\n        console.log(`  TICKER: ${ticker.symbol} | Price: ${ticker.last} | Latency: ${latency}ms`);\n      }\n    });\n\n    manager.on('trade', (trade: Trade) => {\n      result.metrics.tradesReceived++;\n      const latency = Date.now() - trade.timestamp;\n      latencies.push(latency);\n\n      if (!result.metrics.firstEventTime) {\n        result.metrics.firstEventTime = Date.now();\n        console.log(`✓ First trade received in ${Date.now() - startTime}ms`);\n      }\n      result.metrics.lastEventTime = Date.now();\n\n      if (config.verbose) {\n        console.log(`  TRADE: ${trade.symbol} | ${trade.side} | Price: ${trade.price} | Amount: ${trade.amount}`);\n      }\n    });\n\n    manager.on('orderbook', (orderbook: OrderBook) => {\n      result.metrics.orderbooksReceived++;\n      const latency = Date.now() - orderbook.timestamp;\n      latencies.push(latency);\n\n      if (!result.metrics.firstEventTime) {\n        result.metrics.firstEventTime = Date.now();\n        console.log(`✓ First orderbook received in ${Date.now() - startTime}ms`);\n      }\n      result.metrics.lastEventTime = Date.now();\n\n      if (config.verbose) {\n        console.log(`  ORDERBOOK: ${orderbook.symbol} | Bids: ${orderbook.bids.length} | Asks: ${orderbook.asks.length}`);\n      }\n    });\n\n    manager.on('exchange:connected', (data) => {\n      console.log(`✓ Connected to ${data.exchange}`);\n      result.metrics.connected = true;\n    });\n\n    manager.on('exchange:disconnected', (data) => {\n      console.log(`✗ Disconnected from ${data.exchange}`);\n      result.metrics.connected = false;\n    });\n\n    manager.on('exchange:error', (error) => {\n      console.error(`✗ Exchange error:`, error.message);\n    });\n\n    // Connect to exchange\n    const exchangeConfig = EXCHANGE_CONFIGS[config.exchange as keyof typeof EXCHANGE_CONFIGS];\n    if (!exchangeConfig) {\n      throw new Error(`Exchange ${config.exchange} not configured`);\n    }\n    const wsUrl = exchangeConfig.mainnet; // Use mainnet for real testing\n\n    console.log(`\\nConnecting to ${config.exchange}...`);\n    await manager.connect(config.exchange, {\n      url: wsUrl,\n      timeout: 30000,\n      pingInterval: 30000,\n      pongTimeout: 10000,\n      reconnection: {\n        maxAttempts: 5,\n        initialDelay: 1000,\n        maxDelay: 30000,\n        backoffMultiplier: 2,\n        jitterFactor: 0.1,\n      },\n    });\n\n    // Subscribe to channels\n    console.log(`Subscribing to channels...`);\n\n    // Subscribe to ticker\n    try {\n      await manager.subscribe({\n        channel: 'ticker',\n        symbol: config.symbol,\n      });\n      console.log(`✓ Subscribed to ticker`);\n    } catch (error) {\n      console.log(`⚠ Ticker subscription not available`);\n    }\n\n    // Subscribe to trades\n    try {\n      await manager.subscribe({\n        channel: 'trades',\n        symbol: config.symbol,\n      });\n      console.log(`✓ Subscribed to trades`);\n    } catch (error) {\n      console.log(`⚠ Trades subscription not available`);\n    }\n\n    // Subscribe to orderbook\n    try {\n      await manager.subscribe({\n        channel: 'orderbook',\n        symbol: config.symbol,\n      });\n      console.log(`✓ Subscribed to orderbook`);\n    } catch (error) {\n      console.log(`⚠ Orderbook subscription not available`);\n    }\n\n    // Wait for test duration\n    console.log(`\\nReceiving events for ${config.duration} seconds...`);\n    if (!config.verbose) {\n      console.log(`(Use --verbose to see individual events)`);\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, config.duration * 1000));\n\n    // Calculate latency statistics\n    if (latencies.length > 0) {\n      result.metrics.averageLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;\n      result.metrics.minLatency = Math.min(...latencies);\n      result.metrics.maxLatency = Math.max(...latencies);\n    }\n\n    // Get Redis metrics if enabled\n    if (config.enableRedis) {\n      const redisMetrics = manager.getRedisMetrics();\n      if (redisMetrics) {\n        result.redisMetrics = {\n          enabled: redisMetrics.connected,\n          publishedEvents: redisMetrics.publishedEvents,\n          receivedEvents: redisMetrics.receivedEvents,\n          errors: redisMetrics.errors,\n        };\n      }\n    }\n\n    // Disconnect\n    console.log(`\\nDisconnecting...`);\n    await manager.disconnect(config.exchange);\n\n    // Mark as success if we received any events\n    const totalEvents = result.metrics.tickersReceived + result.metrics.tradesReceived + result.metrics.orderbooksReceived;\n    result.success = totalEvents > 0;\n\n    // Print results\n    printTestResult(result);\n\n    return result;\n\n  } catch (error) {\n    result.error = error instanceof Error ? error.message : String(error);\n    console.error(`\\n✗ Test failed:`, result.error);\n    printTestResult(result);\n    return result;\n  }\n}\n\n/**\n * Print test result\n */\nfunction printTestResult(result: ExchangeTestResult): void {\n  console.log(`\\n${'─'.repeat(60)}`);\n  console.log(`Test Results - ${result.exchange.toUpperCase()}`);\n  console.log('─'.repeat(60));\n  console.log(`Status: ${result.success ? '✓ SUCCESS' : '✗ FAILED'}`);\n\n  if (result.error) {\n    console.log(`Error: ${result.error}`);\n  }\n\n  console.log(`\\nMetrics:`);\n  console.log(`  Connected: ${result.metrics.connected ? 'Yes' : 'No'}`);\n  console.log(`  Tickers Received: ${result.metrics.tickersReceived}`);\n  console.log(`  Trades Received: ${result.metrics.tradesReceived}`);\n  console.log(`  Orderbooks Received: ${result.metrics.orderbooksReceived}`);\n\n  const totalEvents = result.metrics.tickersReceived + result.metrics.tradesReceived + result.metrics.orderbooksReceived;\n  console.log(`  Total Events: ${totalEvents}`);\n\n  if (totalEvents > 0) {\n    const eventsPerSecond = totalEvents / result.duration;\n    console.log(`  Events/Second: ${eventsPerSecond.toFixed(2)}`);\n  }\n\n  if (result.metrics.firstEventTime) {\n    console.log(`  Time to First Event: ${result.metrics.firstEventTime - Date.now() + (result.duration * 1000)}ms`);\n  }\n\n  if (result.metrics.averageLatency !== undefined) {\n    console.log(`\\nLatency:`);\n    console.log(`  Average: ${result.metrics.averageLatency.toFixed(2)}ms`);\n    console.log(`  Min: ${result.metrics.minLatency}ms`);\n    console.log(`  Max: ${result.metrics.maxLatency}ms`);\n  }\n\n  if (result.redisMetrics) {\n    console.log(`\\nRedis Metrics:`);\n    console.log(`  Enabled: ${result.redisMetrics.enabled ? 'Yes' : 'No'}`);\n    console.log(`  Published Events: ${result.redisMetrics.publishedEvents}`);\n    console.log(`  Received Events: ${result.redisMetrics.receivedEvents}`);\n    console.log(`  Errors: ${result.redisMetrics.errors}`);\n  }\n\n  console.log('─'.repeat(60));\n}\n\n/**\n * Print summary of all tests\n */\nfunction printSummary(results: ExchangeTestResult[]): void {\n  console.log(`\\n${'='.repeat(60)}`);\n  console.log(`TEST SUMMARY`);\n  console.log('='.repeat(60));\n\n  const successful = results.filter(r => r.success).length;\n  const failed = results.length - successful;\n\n  console.log(`Total Tests: ${results.length}`);\n  console.log(`Successful: ${successful}`);\n  console.log(`Failed: ${failed}`);\n\n  console.log(`\\nResults by Exchange:`);\n  for (const result of results) {\n    const totalEvents = result.metrics.tickersReceived + result.metrics.tradesReceived + result.metrics.orderbooksReceived;\n    const status = result.success ? '✓' : '✗';\n    console.log(`  ${status} ${result.exchange.padEnd(10)} | ${totalEvents.toString().padStart(4)} events | ${result.metrics.averageLatency?.toFixed(0) || 'N/A'}ms avg latency`);\n  }\n\n  // Overall statistics\n  const totalEvents = results.reduce((sum, r) =>\n    sum + r.metrics.tickersReceived + r.metrics.tradesReceived + r.metrics.orderbooksReceived, 0\n  );\n  const avgLatency = results.reduce((sum, r) => sum + (r.metrics.averageLatency || 0), 0) / results.length;\n\n  console.log(`\\nOverall Statistics:`);\n  console.log(`  Total Events Received: ${totalEvents}`);\n  console.log(`  Average Latency: ${avgLatency.toFixed(2)}ms`);\n\n  console.log('='.repeat(60));\n}\n\n/**\n * Parse command line arguments\n */\nfunction parseArgs(): {\n  exchanges: ExchangeId[];\n  symbol?: string;\n  duration: number;\n  enableRedis: boolean;\n  verbose: boolean;\n} {\n  const args = process.argv.slice(2);\n\n  const exchanges: ExchangeId[] = [];\n  let symbol: string | undefined;\n  let duration = 30;\n  let enableRedis = false;\n  let verbose = false;\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    if (arg === '--exchange' && i + 1 < args.length) {\n      exchanges.push(args[++i] as ExchangeId);\n    } else if (arg === '--all') {\n      exchanges.push('binance', 'coinbase', 'kraken');\n    } else if (arg === '--symbol' && i + 1 < args.length) {\n      symbol = args[++i];\n    } else if (arg === '--duration' && i + 1 < args.length) {\n      duration = parseInt(args[++i]);\n    } else if (arg === '--redis') {\n      enableRedis = true;\n    } else if (arg === '--verbose') {\n      verbose = true;\n    } else if (arg === '--help' || arg === '-h') {\n      console.log(`\nExchange WebSocket Testing Utility\n\nUsage: bun run src/scripts/test-exchange-websockets.ts [options]\n\nOptions:\n  --exchange <name>    Test specific exchange (binance, coinbase, kraken)\n  --all                Test all exchanges\n  --symbol <symbol>    Symbol to test (default: exchange-specific)\n  --duration <seconds> Test duration in seconds (default: 30)\n  --redis              Enable Redis testing\n  --verbose            Show individual events\n  --help, -h           Show this help message\n\nExamples:\n  # Test Binance for 30 seconds\n  bun run src/scripts/test-exchange-websockets.ts --exchange binance\n\n  # Test all exchanges with Redis\n  bun run src/scripts/test-exchange-websockets.ts --all --redis\n\n  # Test Coinbase with custom symbol and duration\n  bun run src/scripts/test-exchange-websockets.ts --exchange coinbase --symbol ETH-USD --duration 60\n\n  # Verbose output\n  bun run src/scripts/test-exchange-websockets.ts --exchange binance --verbose\n      `);\n      process.exit(0);\n    }\n  }\n\n  // Default to Binance if no exchange specified\n  if (exchanges.length === 0) {\n    exchanges.push('binance');\n  }\n\n  return { exchanges, symbol, duration, enableRedis, verbose };\n}\n\n/**\n * Main function\n */\nasync function main(): Promise<void> {\n  const { exchanges, symbol, duration, enableRedis, verbose } = parseArgs();\n\n  console.log(`\n╔════════════════════════════════════════════════════════════╗\n║         Exchange WebSocket Testing Utility                 ║\n╚════════════════════════════════════════════════════════════╝\n  `);\n\n  const results: ExchangeTestResult[] = [];\n\n  for (const exchange of exchanges) {\n    const exchangeConfig = EXCHANGE_CONFIGS[exchange as keyof typeof EXCHANGE_CONFIGS];\n    if (!exchangeConfig) {\n      console.error(`Exchange ${exchange} not configured, skipping...`);\n      continue;\n    }\n    const testSymbol = symbol || exchangeConfig.defaultSymbol;\n\n    const result = await testExchange({\n      exchange,\n      symbol: testSymbol,\n      duration,\n      enableRedis,\n      verbose,\n    });\n\n    results.push(result);\n\n    // Wait between tests\n    if (exchanges.length > 1 && exchange !== exchanges[exchanges.length - 1]) {\n      console.log(`\\nWaiting 3 seconds before next test...`);\n      await new Promise(resolve => setTimeout(resolve, 3000));\n    }\n  }\n\n  // Print summary if testing multiple exchanges\n  if (results.length > 1) {\n    printSummary(results);\n  }\n\n  // Exit with appropriate code\n  const allSuccessful = results.every(r => r.success);\n  process.exit(allSuccessful ? 0 : 1);\n}\n\n// Run main function\nmain().catch((error) => {\n  console.error('Fatal error:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-redis-load.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/scripts/test-redis-multi-instance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/types/ambient.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/types/api.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/types/feedparser.d.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Readable' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Type declarations for feedparser\n * https://www.npmjs.com/package/feedparser\n */\n\ndeclare module 'feedparser' {\n  import { Readable, Transform } from 'stream';\n\n  interface FeedParserOptions {\n    feedurl?: string;\n    normalize?: boolean;\n    addmeta?: boolean;\n    resume_saxerror?: boolean;\n  }\n\n  interface FeedParserItem {\n    title?: string;\n    description?: string;\n    summary?: string;\n    link?: string;\n    author?: string;\n    creator?: string;\n    pubdate?: Date;\n    published?: Date;\n    guid?: string;\n    image?: {\n      url?: string;\n      title?: string;\n    };\n    enclosures?: Array<{\n      url: string;\n      type?: string;\n      length?: number;\n    }>;\n    'media:content'?: {\n      $?: {\n        url?: string;\n      };\n    };\n    categories?: string[];\n    [key: string]: any;\n  }\n\n  class FeedParser extends Transform {\n    constructor(options?: FeedParserOptions);\n\n    on(event: 'error', listener: (error: Error) => void): this;\n    on(event: 'readable', listener: () => void): this;\n    on(event: 'end', listener: () => void): this;\n    on(event: 'data', listener: (item: FeedParserItem) => void): this;\n\n    read(): FeedParserItem | null;\n  }\n\n  export = FeedParser;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/types/sentiment.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/utils/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/utils/health-check.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/myminimac/Desenvolvimento/BotCriptoFy2/backend/src/utils/redis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
