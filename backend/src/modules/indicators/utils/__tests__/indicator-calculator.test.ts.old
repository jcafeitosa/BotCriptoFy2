/**
 * Indicator Calculator Tests
 * Unit tests for technical indicator calculations
 *
 * @module indicators/utils/__tests__
 */

import { describe, test, expect, beforeEach } from 'bun:test';
import type { OHLCVData } from '../../types/indicators.types';
import * as Calculator from '../indicator-calculator';

/**
 * Mock OHLCV data generator
 */
function generateMockOHLCV(length: number, basePrice: number = 100): OHLCVData[] {
  const data: OHLCVData[] = [];
  let price = basePrice;

  for (let i = 0; i < length; i++) {
    const volatility = (Math.random() - 0.5) * 2; // -1 to +1
    const open = price;
    const close = price + volatility;
    const high = Math.max(open, close) + Math.abs(volatility) * 0.5;
    const low = Math.min(open, close) - Math.abs(volatility) * 0.5;
    const volume = 1000 + Math.random() * 500;

    data.push({
      timestamp: new Date(Date.now() + i * 60000),
      open,
      high,
      low,
      close,
      volume,
    });

    price = close;
  }

  return data;
}

/**
 * Generate trending data
 */
function generateTrendingData(length: number, direction: 'up' | 'down' = 'up'): OHLCVData[] {
  const data: OHLCVData[] = [];
  const multiplier = direction === 'up' ? 1 : -1;

  for (let i = 0; i < length; i++) {
    const basePrice = 100 + i * 0.5 * multiplier;
    const volatility = (Math.random() - 0.5) * 0.5;

    data.push({
      timestamp: new Date(Date.now() + i * 60000),
      open: basePrice,
      high: basePrice + Math.abs(volatility),
      low: basePrice - Math.abs(volatility),
      close: basePrice + volatility,
      volume: 1000 + Math.random() * 500,
    });
  }

  return data;
}

// ============================================================================
// DATA CONVERSION HELPERS TESTS
// ============================================================================

describe('Data Conversion Helpers', () => {
  let mockData: OHLCVData[];

  beforeEach(() => {
    mockData = generateMockOHLCV(10);
  });

  test('extractField - should extract close prices', () => {
    const closes = Calculator.extractField(mockData, 'close');
    expect(closes).toHaveLength(10);
    expect(closes.every((p) => typeof p === 'number')).toBe(true);
  });

  test('getClosePrices - should return close prices array', () => {
    const closes = Calculator.getClosePrices(mockData);
    expect(closes).toHaveLength(10);
    expect(closes[0]).toBe(mockData[0].close);
  });

  test('getHighPrices - should return high prices array', () => {
    const highs = Calculator.getHighPrices(mockData);
    expect(highs).toHaveLength(10);
    expect(highs[0]).toBe(mockData[0].high);
  });

  test('getLowPrices - should return low prices array', () => {
    const lows = Calculator.getLowPrices(mockData);
    expect(lows).toHaveLength(10);
    expect(lows[0]).toBe(mockData[0].low);
  });

  test('getOpenPrices - should return open prices array', () => {
    const opens = Calculator.getOpenPrices(mockData);
    expect(opens).toHaveLength(10);
    expect(opens[0]).toBe(mockData[0].open);
  });

  test('getVolumes - should return volumes array', () => {
    const volumes = Calculator.getVolumes(mockData);
    expect(volumes).toHaveLength(10);
    expect(volumes[0]).toBe(mockData[0].volume);
  });
});

// ============================================================================
// VALIDATION HELPERS TESTS
// ============================================================================

describe('Validation Helpers', () => {
  test('validateDataLength - should pass with sufficient data', () => {
    const data = generateMockOHLCV(20);
    expect(() => Calculator.validateDataLength(data, 10, 'Test')).not.toThrow();
  });

  test('validateDataLength - should throw with insufficient data', () => {
    const data = generateMockOHLCV(5);
    expect(() => Calculator.validateDataLength(data, 10, 'Test')).toThrow(/Insufficient data/);
  });

  test('validateDataLength - should throw with empty data', () => {
    expect(() => Calculator.validateDataLength([], 10, 'Test')).toThrow(/No data provided/);
  });

  test('validateParameter - should pass with valid value', () => {
    expect(() => Calculator.validateParameter(10, 'period', 2, 100)).not.toThrow();
  });

  test('validateParameter - should throw with value below minimum', () => {
    expect(() => Calculator.validateParameter(1, 'period', 2, 100)).toThrow(/must be at least/);
  });

  test('validateParameter - should throw with value above maximum', () => {
    expect(() => Calculator.validateParameter(101, 'period', 2, 100)).toThrow(/must be at most/);
  });

  test('validateParameter - should throw with null value', () => {
    expect(() => Calculator.validateParameter(null, 'period', 2, 100)).toThrow(/is required/);
  });
});

// ============================================================================
// MOMENTUM INDICATORS TESTS
// ============================================================================

describe('Momentum Indicators', () => {
  test('calculateRSI - should calculate RSI values', () => {
    const data = generateMockOHLCV(50);
    const rsi = Calculator.calculateRSI(data, 14);

    expect(rsi).toBeDefined();
    expect(rsi.length).toBeGreaterThan(0);
    expect(rsi.every((val) => val >= 0 && val <= 100)).toBe(true);
  });

  test('calculateRSI - should handle overbought condition', () => {
    const data = generateTrendingData(50, 'up');
    const rsi = Calculator.calculateRSI(data, 14);
    const latest = Calculator.getLatestValue(rsi);

    expect(latest).toBeDefined();
    expect(latest).toBeGreaterThan(50); // Strong uptrend should have RSI > 50
  });

  test('calculateMACD - should calculate MACD values', () => {
    const data = generateMockOHLCV(50);
    const macd = Calculator.calculateMACD(data, 12, 26, 9);

    expect(macd).toBeDefined();
    expect(macd.length).toBeGreaterThan(0);
    expect(macd[0]).toHaveProperty('MACD');
    expect(macd[0]).toHaveProperty('signal');
    expect(macd[0]).toHaveProperty('histogram');
  });

  test('calculateMACD - should throw if fastPeriod >= slowPeriod', () => {
    const data = generateMockOHLCV(50);
    expect(() => Calculator.calculateMACD(data, 26, 12, 9)).toThrow(/must be less than/);
  });

  test('calculateStochastic - should calculate stochastic values', () => {
    const data = generateMockOHLCV(50);
    const stoch = Calculator.calculateStochastic(data, 14, 3);

    expect(stoch).toBeDefined();
    expect(stoch.length).toBeGreaterThan(0);
    expect(stoch[0]).toHaveProperty('k');
    expect(stoch[0]).toHaveProperty('d');
    expect(stoch[0].k).toBeGreaterThanOrEqual(0);
    expect(stoch[0].k).toBeLessThanOrEqual(100);
  });

  test('calculateStochasticRSI - should calculate stochastic RSI', () => {
    const data = generateMockOHLCV(100);
    const stochRSI = Calculator.calculateStochasticRSI(data, 14, 14, 3, 3);

    expect(stochRSI).toBeDefined();
    expect(stochRSI.length).toBeGreaterThan(0);
    expect(stochRSI[0]).toHaveProperty('k');
    expect(stochRSI[0]).toHaveProperty('d');
  });

  test('calculateCCI - should calculate CCI values', () => {
    const data = generateMockOHLCV(50);
    const cci = Calculator.calculateCCI(data, 20);

    expect(cci).toBeDefined();
    expect(cci.length).toBeGreaterThan(0);
    expect(cci.every((val) => typeof val === 'number')).toBe(true);
  });

  test('calculateROC - should calculate rate of change', () => {
    const data = generateMockOHLCV(50);
    const roc = Calculator.calculateROC(data, 12);

    expect(roc).toBeDefined();
    expect(roc.length).toBeGreaterThan(0);
  });

  test('calculateMFI - should calculate money flow index', () => {
    const data = generateMockOHLCV(50);
    const mfi = Calculator.calculateMFI(data, 14);

    expect(mfi).toBeDefined();
    expect(mfi.length).toBeGreaterThan(0);
    expect(mfi.every((val) => val >= 0 && val <= 100)).toBe(true);
  });

  test('calculateWilliamsR - should calculate Williams %R', () => {
    const data = generateMockOHLCV(50);
    const williams = Calculator.calculateWilliamsR(data, 14);

    expect(williams).toBeDefined();
    expect(williams.length).toBeGreaterThan(0);
    expect(williams.every((val) => val >= -100 && val <= 0)).toBe(true);
  });
});

// ============================================================================
// TREND INDICATORS TESTS
// ============================================================================

describe('Trend Indicators', () => {
  test('calculateSMA - should calculate simple moving average', () => {
    const data = generateMockOHLCV(50);
    const sma = Calculator.calculateSMA(data, 20);

    expect(sma).toBeDefined();
    expect(sma.length).toBeGreaterThan(0);
  });

  test('calculateEMA - should calculate exponential moving average', () => {
    const data = generateMockOHLCV(50);
    const ema = Calculator.calculateEMA(data, 20);

    expect(ema).toBeDefined();
    expect(ema.length).toBeGreaterThan(0);
  });

  test('calculateWMA - should calculate weighted moving average', () => {
    const data = generateMockOHLCV(50);
    const wma = Calculator.calculateWMA(data, 20);

    expect(wma).toBeDefined();
    expect(wma.length).toBeGreaterThan(0);
  });

  test('calculateDEMA - should calculate double EMA', () => {
    const data = generateMockOHLCV(100);
    const dema = Calculator.calculateDEMA(data, 20);

    expect(dema).toBeDefined();
    expect(dema.length).toBeGreaterThan(0);
  });

  test('calculateTEMA - should calculate triple EMA', () => {
    const data = generateMockOHLCV(150);
    const tema = Calculator.calculateTEMA(data, 20);

    expect(tema).toBeDefined();
    expect(tema.length).toBeGreaterThan(0);
  });

  test('calculateHMA - should calculate Hull moving average', () => {
    const data = generateMockOHLCV(50);
    const hma = Calculator.calculateHMA(data, 9);

    expect(hma).toBeDefined();
    expect(hma.length).toBeGreaterThan(0);
  });

  test('calculateADX - should calculate ADX values', () => {
    const data = generateMockOHLCV(50);
    const adx = Calculator.calculateADX(data, 14);

    expect(adx).toBeDefined();
    expect(adx.length).toBeGreaterThan(0);
    expect(adx[0]).toHaveProperty('adx');
    expect(adx[0]).toHaveProperty('pdi');
    expect(adx[0]).toHaveProperty('mdi');
  });

  test('calculateParabolicSAR - should calculate parabolic SAR', () => {
    const data = generateMockOHLCV(50);
    const psar = Calculator.calculateParabolicSAR(data, 0.02, 0.2);

    expect(psar).toBeDefined();
    expect(psar.length).toBeGreaterThan(0);
  });

  test('calculateAroon - should calculate Aroon indicator', () => {
    const data = generateMockOHLCV(50);
    const aroon = Calculator.calculateAroon(data, 25);

    expect(aroon).toBeDefined();
    expect(aroon.length).toBeGreaterThan(0);
    expect(aroon[0]).toHaveProperty('aroonUp');
    expect(aroon[0]).toHaveProperty('aroonDown');
  });

  test('calculateIchimoku - should calculate Ichimoku Cloud', () => {
    const data = generateMockOHLCV(100);
    const ichimoku = Calculator.calculateIchimoku(data, 9, 26, 52, 26);

    expect(ichimoku).toBeDefined();
    expect(ichimoku.length).toBeGreaterThan(0);
    expect(ichimoku[0]).toHaveProperty('conversion');
    expect(ichimoku[0]).toHaveProperty('base');
    expect(ichimoku[0]).toHaveProperty('spanA');
    expect(ichimoku[0]).toHaveProperty('spanB');
  });
});

// ============================================================================
// VOLATILITY INDICATORS TESTS
// ============================================================================

describe('Volatility Indicators', () => {
  test('calculateBollingerBands - should calculate Bollinger Bands', () => {
    const data = generateMockOHLCV(50);
    const bb = Calculator.calculateBollingerBands(data, 20, 2);

    expect(bb).toBeDefined();
    expect(bb.length).toBeGreaterThan(0);
    expect(bb[0]).toHaveProperty('upper');
    expect(bb[0]).toHaveProperty('middle');
    expect(bb[0]).toHaveProperty('lower');
    expect(bb[0]).toHaveProperty('pb');
    expect(bb[0]).toHaveProperty('bandwidth');
    expect(bb[0].upper).toBeGreaterThan(bb[0].middle);
    expect(bb[0].middle).toBeGreaterThan(bb[0].lower);
  });

  test('calculateATR - should calculate average true range', () => {
    const data = generateMockOHLCV(50);
    const atr = Calculator.calculateATR(data, 14);

    expect(atr).toBeDefined();
    expect(atr.length).toBeGreaterThan(0);
    expect(atr.every((val) => val >= 0)).toBe(true);
  });

  test('calculateStandardDeviation - should calculate standard deviation', () => {
    const data = generateMockOHLCV(50);
    const stdDev = Calculator.calculateStandardDeviation(data, 20);

    expect(stdDev).toBeDefined();
    expect(stdDev.length).toBeGreaterThan(0);
    expect(stdDev.every((val) => val >= 0)).toBe(true);
  });

  test('calculateKeltnerChannels - should calculate Keltner Channels', () => {
    const data = generateMockOHLCV(50);
    const keltner = Calculator.calculateKeltnerChannels(data, 20, 10, 2);

    expect(keltner).toBeDefined();
    expect(keltner.length).toBeGreaterThan(0);
    expect(keltner[0]).toHaveProperty('upper');
    expect(keltner[0]).toHaveProperty('middle');
    expect(keltner[0]).toHaveProperty('lower');
  });

  test('calculateDonchianChannel - should calculate Donchian Channel', () => {
    const data = generateMockOHLCV(50);
    const donchian = Calculator.calculateDonchianChannel(data, 20);

    expect(donchian).toBeDefined();
    expect(donchian.length).toBeGreaterThan(0);
    expect(donchian[0]).toHaveProperty('upper');
    expect(donchian[0]).toHaveProperty('middle');
    expect(donchian[0]).toHaveProperty('lower');
  });
});

// ============================================================================
// VOLUME INDICATORS TESTS
// ============================================================================

describe('Volume Indicators', () => {
  test('calculateOBV - should calculate on balance volume', () => {
    const data = generateMockOHLCV(50);
    const obv = Calculator.calculateOBV(data);

    expect(obv).toBeDefined();
    expect(obv.length).toBeGreaterThan(0);
  });

  test('calculateVWAP - should calculate volume weighted average price', () => {
    const data = generateMockOHLCV(50);
    const vwap = Calculator.calculateVWAP(data);

    expect(vwap).toBeDefined();
    expect(vwap.length).toBeGreaterThan(0);
  });

  test('calculateAD - should calculate accumulation/distribution', () => {
    const data = generateMockOHLCV(50);
    const ad = Calculator.calculateAD(data);

    expect(ad).toBeDefined();
    expect(ad.length).toBeGreaterThan(0);
  });

  test('calculateVWMA - should calculate volume weighted MA', () => {
    const data = generateMockOHLCV(50);
    const vwma = Calculator.calculateVWMA(data, 20);

    expect(vwma).toBeDefined();
    expect(vwma.length).toBeGreaterThan(0);
  });

  test('calculateCMF - should calculate Chaikin Money Flow', () => {
    const data = generateMockOHLCV(50);
    const cmf = Calculator.calculateCMF(data, 20);

    expect(cmf).toBeDefined();
    expect(cmf.length).toBeGreaterThan(0);
    expect(cmf.every((val) => val >= -1 && val <= 1)).toBe(true);
  });

  test('calculateVolumeOscillator - should calculate volume oscillator', () => {
    const data = generateMockOHLCV(50);
    const vo = Calculator.calculateVolumeOscillator(data, 5, 10);

    expect(vo).toBeDefined();
    expect(vo.length).toBeGreaterThan(0);
  });
});

// ============================================================================
// SUPPORT & RESISTANCE TESTS
// ============================================================================

describe('Support & Resistance Indicators', () => {
  test('calculatePivotPoints - classic method', () => {
    const data = generateMockOHLCV(10);
    const pivots = Calculator.calculatePivotPoints(data, 'classic');

    expect(pivots).toHaveProperty('pivot');
    expect(pivots).toHaveProperty('r1');
    expect(pivots).toHaveProperty('r2');
    expect(pivots).toHaveProperty('r3');
    expect(pivots).toHaveProperty('s1');
    expect(pivots).toHaveProperty('s2');
    expect(pivots).toHaveProperty('s3');
    expect(pivots.r1).toBeGreaterThan(pivots.pivot);
    expect(pivots.pivot).toBeGreaterThan(pivots.s1);
  });

  test('calculatePivotPoints - fibonacci method', () => {
    const data = generateMockOHLCV(10);
    const pivots = Calculator.calculatePivotPoints(data, 'fibonacci');

    expect(pivots).toBeDefined();
    expect(pivots.r1).toBeGreaterThan(pivots.pivot);
  });

  test('calculatePivotPoints - woodie method', () => {
    const data = generateMockOHLCV(10);
    const pivots = Calculator.calculatePivotPoints(data, 'woodie');

    expect(pivots).toBeDefined();
  });

  test('calculatePivotPoints - camarilla method', () => {
    const data = generateMockOHLCV(10);
    const pivots = Calculator.calculatePivotPoints(data, 'camarilla');

    expect(pivots).toBeDefined();
  });

  test('calculateFibonacciRetracement - uptrend', () => {
    const fib = Calculator.calculateFibonacciRetracement(120, 100, 'uptrend');

    expect(fib).toHaveProperty('level_0');
    expect(fib).toHaveProperty('level_236');
    expect(fib).toHaveProperty('level_382');
    expect(fib).toHaveProperty('level_500');
    expect(fib).toHaveProperty('level_618');
    expect(fib).toHaveProperty('level_786');
    expect(fib).toHaveProperty('level_100');
    expect(fib).toHaveProperty('level_1272');
    expect(fib).toHaveProperty('level_1618');

    expect(fib.level_0).toBe(120); // Swing high
    expect(fib.level_100).toBe(100); // Swing low
    expect(fib.level_618).toBeGreaterThan(fib.level_100);
    expect(fib.level_618).toBeLessThan(fib.level_0);
  });

  test('calculateFibonacciRetracement - downtrend', () => {
    const fib = Calculator.calculateFibonacciRetracement(120, 100, 'downtrend');

    expect(fib.level_0).toBe(100); // Swing low
    expect(fib.level_100).toBe(120); // Swing high
  });

  test('calculateFibonacciRetracement - should throw if high <= low', () => {
    expect(() => Calculator.calculateFibonacciRetracement(100, 120, 'uptrend')).toThrow(
      /High must be greater than low/
    );
  });
});

// ============================================================================
// UTILITY FUNCTIONS TESTS
// ============================================================================

describe('Utility Functions', () => {
  test('getLatestValue - should return last value from array', () => {
    const values = [1, 2, 3, 4, 5];
    expect(Calculator.getLatestValue(values)).toBe(5);
  });

  test('getLatestValue - should return null for empty array', () => {
    expect(Calculator.getLatestValue([])).toBe(null);
  });

  test('detectCrossover - should detect bullish crossover', () => {
    const crossover = Calculator.detectCrossover(110, 90, 100, 100);
    expect(crossover).toBe('bullish');
  });

  test('detectCrossover - should detect bearish crossover', () => {
    const crossover = Calculator.detectCrossover(90, 110, 100, 100);
    expect(crossover).toBe('bearish');
  });

  test('detectCrossover - should return null for no crossover', () => {
    const crossover = Calculator.detectCrossover(105, 103, 100, 100);
    expect(crossover).toBe(null);
  });

  test('calculatePercentDiff - should calculate percentage difference', () => {
    const diff = Calculator.calculatePercentDiff(110, 100);
    expect(diff).toBe(10);
  });

  test('calculatePercentDiff - should handle zero reference', () => {
    const diff = Calculator.calculatePercentDiff(100, 0);
    expect(diff).toBe(0);
  });

  test('determineTrend - should detect uptrend', () => {
    const values = [100, 101, 102, 103, 104];
    expect(Calculator.determineTrend(values)).toBe('up');
  });

  test('determineTrend - should detect downtrend', () => {
    const values = [104, 103, 102, 101, 100];
    expect(Calculator.determineTrend(values)).toBe('down');
  });

  test('determineTrend - should detect sideways', () => {
    const values = [100, 100.01, 100.02, 100.01, 100];
    expect(Calculator.determineTrend(values)).toBe('sideways');
  });

  test('safeCalculate - should execute calculation successfully', async () => {
    const result = await Calculator.safeCalculate(() => 42, 'Test Indicator');
    expect(result).toBe(42);
  });

  test('safeCalculate - should handle calculation error', async () => {
    await expect(
      Calculator.safeCalculate(() => {
        throw new Error('Calculation failed');
      }, 'Test Indicator')
    ).rejects.toThrow(/Failed to calculate/);
  });
});

// ============================================================================
// CRYPTO-SPECIFIC INDICATORS TESTS
// ============================================================================

describe('Crypto-Specific Indicators', () => {
  test('calculateAO - should calculate Awesome Oscillator', () => {
    const data = generateMockOHLCV(50);
    const ao = Calculator.calculateAO(data, 5, 34);

    expect(ao).toBeDefined();
    expect(ao.length).toBeGreaterThan(0);
  });

  test('calculateTSI - should calculate True Strength Index', () => {
    const data = generateMockOHLCV(100);
    const tsi = Calculator.calculateTSI(data, 25, 13);

    expect(tsi).toBeDefined();
    expect(tsi.length).toBeGreaterThan(0);
  });

  test('calculateKST - should calculate Know Sure Thing', () => {
    const data = generateMockOHLCV(100);
    const kst = Calculator.calculateKST(data, 10, 15, 20, 30, 10, 10, 10, 15, 9);

    expect(kst).toBeDefined();
    expect(kst.length).toBeGreaterThan(0);
    expect(kst[0]).toHaveProperty('kst');
    expect(kst[0]).toHaveProperty('signal');
  });

  test('calculateForceIndex - should calculate Force Index', () => {
    const data = generateMockOHLCV(50);
    const forceIndex = Calculator.calculateForceIndex(data, 13);

    expect(forceIndex).toBeDefined();
    expect(forceIndex.length).toBeGreaterThan(0);
  });
});

// ============================================================================
// EDGE CASES AND ERROR HANDLING TESTS
// ============================================================================

describe('Edge Cases and Error Handling', () => {
  test('should handle minimum data requirements', () => {
    const data = generateMockOHLCV(15);
    expect(() => Calculator.calculateRSI(data, 14)).not.toThrow();
  });

  test('should throw on insufficient data for complex indicators', () => {
    const data = generateMockOHLCV(10);
    expect(() => Calculator.calculateIchimoku(data, 9, 26, 52, 26)).toThrow(/Insufficient data/);
  });

  test('should handle extreme volatility', () => {
    const data: OHLCVData[] = Array.from({ length: 50 }, (_, i) => ({
      timestamp: new Date(Date.now() + i * 60000),
      open: 100,
      high: 200,
      low: 50,
      close: 150,
      volume: 1000,
    }));

    expect(() => Calculator.calculateRSI(data, 14)).not.toThrow();
    expect(() => Calculator.calculateATR(data, 14)).not.toThrow();
  });

  test('should handle zero volume', () => {
    const data = generateMockOHLCV(50);
    data.forEach((candle) => (candle.volume = 0));

    // Should still work but may produce unusual results
    expect(() => Calculator.calculateVWAP(data)).not.toThrow();
  });
});
