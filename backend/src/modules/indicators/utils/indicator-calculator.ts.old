/**
 * Indicator Calculator Utility
 * Wrapper for technicalindicators library with normalization and error handling
 *
 * @module indicators/utils/indicator-calculator
 */

import * as TI from 'technicalindicators';
import type { OHLCVData } from '../types/indicators.types';
import logger from '@/utils/logger';

// ============================================================================
// DATA CONVERSION HELPERS
// ============================================================================

/**
 * Extract specific OHLCV field as number array
 */
export function extractField(data: OHLCVData[], field: keyof Omit<OHLCVData, 'timestamp'>): number[] {
  return data.map((candle) => candle[field]);
}

/**
 * Get close prices from OHLCV data
 */
export function getClosePrices(data: OHLCVData[]): number[] {
  return extractField(data, 'close');
}

/**
 * Get high prices from OHLCV data
 */
export function getHighPrices(data: OHLCVData[]): number[] {
  return extractField(data, 'high');
}

/**
 * Get low prices from OHLCV data
 */
export function getLowPrices(data: OHLCVData[]): number[] {
  return extractField(data, 'low');
}

/**
 * Get open prices from OHLCV data
 */
export function getOpenPrices(data: OHLCVData[]): number[] {
  return extractField(data, 'open');
}

/**
 * Get volumes from OHLCV data
 */
export function getVolumes(data: OHLCVData[]): number[] {
  return extractField(data, 'volume');
}

// ============================================================================
// VALIDATION HELPERS
// ============================================================================

/**
 * Validate if we have enough data for calculation
 */
export function validateDataLength(data: OHLCVData[], minLength: number, indicatorName: string): void {
  if (!data || data.length === 0) {
    throw new Error(`No data provided for ${indicatorName} calculation`);
  }

  if (data.length < minLength) {
    throw new Error(`Insufficient data for ${indicatorName}: need at least ${minLength} candles, got ${data.length}`);
  }
}

/**
 * Validate parameter value
 */
export function validateParameter(value: any, name: string, min: number, max?: number): void {
  if (value === undefined || value === null) {
    throw new Error(`Parameter '${name}' is required`);
  }

  if (typeof value !== 'number') {
    throw new Error(`Parameter '${name}' must be a number`);
  }

  if (value < min) {
    throw new Error(`Parameter '${name}' must be at least ${min}`);
  }

  if (max !== undefined && value > max) {
    throw new Error(`Parameter '${name}' must be at most ${max}`);
  }
}

// ============================================================================
// CALCULATION WRAPPERS
// ============================================================================

/**
 * Calculate RSI (Relative Strength Index)
 */
export function calculateRSI(data: OHLCVData[], period: number = 14): number[] {
  validateDataLength(data, period + 1, 'RSI');
  validateParameter(period, 'period', 2, 100);

  const values = getClosePrices(data);

  const rsi = TI.RSI.calculate({
    values,
    period,
  });

  return rsi;
}

/**
 * Calculate MACD (Moving Average Convergence Divergence)
 */
export function calculateMACD(
  data: OHLCVData[],
  fastPeriod: number = 12,
  slowPeriod: number = 26,
  signalPeriod: number = 9
): Array<{ MACD: number; signal: number; histogram: number }> {
  const minLength = Math.max(fastPeriod, slowPeriod) + signalPeriod;
  validateDataLength(data, minLength, 'MACD');
  validateParameter(fastPeriod, 'fastPeriod', 2, 100);
  validateParameter(slowPeriod, 'slowPeriod', 2, 100);
  validateParameter(signalPeriod, 'signalPeriod', 2, 100);

  if (fastPeriod >= slowPeriod) {
    throw new Error('fastPeriod must be less than slowPeriod');
  }

  const values = getClosePrices(data);

  const macd = TI.MACD.calculate({
    values,
    fastPeriod,
    slowPeriod,
    signalPeriod,
    SimpleMAOscillator: false,
    SimpleMASignal: false,
  });

  return macd;
}

/**
 * Calculate Stochastic Oscillator
 */
export function calculateStochastic(
  data: OHLCVData[],
  period: number = 14,
  signalPeriod: number = 3
): Array<{ k: number; d: number }> {
  validateDataLength(data, period + signalPeriod, 'Stochastic');
  validateParameter(period, 'period', 2, 100);
  validateParameter(signalPeriod, 'signalPeriod', 1, 20);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);

  const stochastic = TI.Stochastic.calculate({
    high,
    low,
    close,
    period,
    signalPeriod,
  });

  return stochastic;
}

/**
 * Calculate CCI (Commodity Channel Index)
 */
export function calculateCCI(data: OHLCVData[], period: number = 20): number[] {
  validateDataLength(data, period, 'CCI');
  validateParameter(period, 'period', 2, 100);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);

  const cci = TI.CCI.calculate({
    high,
    low,
    close,
    period,
  });

  return cci;
}

/**
 * Calculate ROC (Rate of Change)
 */
export function calculateROC(data: OHLCVData[], period: number = 12): number[] {
  validateDataLength(data, period + 1, 'ROC');
  validateParameter(period, 'period', 1, 100);

  const values = getClosePrices(data);

  const roc = TI.ROC.calculate({
    values,
    period,
  });

  return roc;
}

/**
 * Calculate MFI (Money Flow Index)
 */
export function calculateMFI(data: OHLCVData[], period: number = 14): number[] {
  validateDataLength(data, period + 1, 'MFI');
  validateParameter(period, 'period', 2, 100);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);
  const volume = getVolumes(data);

  const mfi = TI.MFI.calculate({
    high,
    low,
    close,
    volume,
    period,
  });

  return mfi;
}

/**
 * Calculate Williams %R
 */
export function calculateWilliamsR(data: OHLCVData[], period: number = 14): number[] {
  validateDataLength(data, period, 'Williams %R');
  validateParameter(period, 'period', 2, 100);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);

  const williamsR = TI.WilliamsR.calculate({
    high,
    low,
    close,
    period,
  });

  return williamsR;
}

// ============================================================================
// TREND INDICATORS
// ============================================================================

/**
 * Calculate SMA (Simple Moving Average)
 */
export function calculateSMA(data: OHLCVData[], period: number = 20): number[] {
  validateDataLength(data, period, 'SMA');
  validateParameter(period, 'period', 2, 500);

  const values = getClosePrices(data);

  const sma = TI.SMA.calculate({
    values,
    period,
  });

  return sma;
}

/**
 * Calculate EMA (Exponential Moving Average)
 */
export function calculateEMA(data: OHLCVData[], period: number = 20): number[] {
  validateDataLength(data, period, 'EMA');
  validateParameter(period, 'period', 2, 500);

  const values = getClosePrices(data);

  const ema = TI.EMA.calculate({
    values,
    period,
  });

  return ema;
}

/**
 * Calculate WMA (Weighted Moving Average)
 */
export function calculateWMA(data: OHLCVData[], period: number = 20): number[] {
  validateDataLength(data, period, 'WMA');
  validateParameter(period, 'period', 2, 500);

  const values = getClosePrices(data);

  const wma = TI.WMA.calculate({
    values,
    period,
  });

  return wma;
}

/**
 * Calculate ADX (Average Directional Index)
 */
export function calculateADX(
  data: OHLCVData[],
  period: number = 14
): Array<{ adx: number; pdi: number; mdi: number }> {
  validateDataLength(data, period * 2, 'ADX');
  validateParameter(period, 'period', 2, 100);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);

  const adx = TI.ADX.calculate({
    high,
    low,
    close,
    period,
  });

  return adx;
}

/**
 * Calculate Parabolic SAR
 */
export function calculateParabolicSAR(
  data: OHLCVData[],
  step: number = 0.02,
  max: number = 0.2
): number[] {
  validateDataLength(data, 2, 'Parabolic SAR');
  validateParameter(step, 'step', 0.001, 0.1);
  validateParameter(max, 'max', 0.1, 1.0);

  const high = getHighPrices(data);
  const low = getLowPrices(data);

  const psar = TI.PSAR.calculate({
    high,
    low,
    step,
    max,
  });

  return psar;
}

// ============================================================================
// VOLATILITY INDICATORS
// ============================================================================

/**
 * Calculate Bollinger Bands
 */
export function calculateBollingerBands(
  data: OHLCVData[],
  period: number = 20,
  stdDev: number = 2
): Array<{ upper: number; middle: number; lower: number; pb: number; bandwidth: number }> {
  validateDataLength(data, period, 'Bollinger Bands');
  validateParameter(period, 'period', 2, 100);
  validateParameter(stdDev, 'stdDev', 0.5, 5);

  const values = getClosePrices(data);

  const bb = TI.BollingerBands.calculate({
    values,
    period,
    stdDev,
  });

  return bb;
}

/**
 * Calculate ATR (Average True Range)
 */
export function calculateATR(data: OHLCVData[], period: number = 14): number[] {
  validateDataLength(data, period + 1, 'ATR');
  validateParameter(period, 'period', 2, 100);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);

  const atr = TI.ATR.calculate({
    high,
    low,
    close,
    period,
  });

  return atr;
}

/**
 * Calculate Standard Deviation
 */
export function calculateStandardDeviation(data: OHLCVData[], period: number = 20): number[] {
  validateDataLength(data, period, 'Standard Deviation');
  validateParameter(period, 'period', 2, 100);

  const values = getClosePrices(data);

  const stdDev = TI.SD.calculate({
    values,
    period,
  });

  return stdDev;
}

// ============================================================================
// VOLUME INDICATORS
// ============================================================================

/**
 * Calculate OBV (On Balance Volume)
 */
export function calculateOBV(data: OHLCVData[]): number[] {
  validateDataLength(data, 2, 'OBV');

  const close = getClosePrices(data);
  const volume = getVolumes(data);

  const obv = TI.OBV.calculate({
    close,
    volume,
  });

  return obv;
}

/**
 * Calculate VWAP (Volume Weighted Average Price)
 */
export function calculateVWAP(data: OHLCVData[]): number[] {
  validateDataLength(data, 1, 'VWAP');

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);
  const volume = getVolumes(data);

  const vwap = TI.VWAP.calculate({
    high,
    low,
    close,
    volume,
  });

  return vwap;
}

/**
 * Calculate ADL (Accumulation/Distribution Line)
 */
export function calculateADL(data: OHLCVData[]): number[] {
  validateDataLength(data, 1, 'ADL');

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);
  const volume = getVolumes(data);

  const adl = TI.ADL.calculate({
    high,
    low,
    close,
    volume,
  });

  return adl;
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Get the last value from an array of results
 */
export function getLatestValue<T>(results: T[]): T | null {
  if (!results || results.length === 0) {
    return null;
  }
  return results[results.length - 1];
}

/**
 * Detect crossover between two series
 * Returns 'bullish' if series1 crosses above series2, 'bearish' if below, null otherwise
 */
export function detectCrossover(
  series1Current: number,
  series1Previous: number,
  series2Current: number,
  series2Previous: number
): 'bullish' | 'bearish' | null {
  // Bullish crossover: series1 was below series2 and now is above
  if (series1Previous < series2Previous && series1Current > series2Current) {
    return 'bullish';
  }

  // Bearish crossover: series1 was above series2 and now is below
  if (series1Previous > series2Previous && series1Current < series2Current) {
    return 'bearish';
  }

  return null;
}

/**
 * Calculate percentage difference between two values
 */
export function calculatePercentDiff(current: number, reference: number): number {
  if (reference === 0) return 0;
  return ((current - reference) / reference) * 100;
}

/**
 * Determine trend direction from series
 */
export function determineTrend(values: number[], lookback: number = 3): 'up' | 'down' | 'sideways' {
  if (!values || values.length < lookback) {
    return 'sideways';
  }

  const recent = values.slice(-lookback);

  // Calculate slope
  let sumUp = 0;
  let sumDown = 0;

  for (let i = 1; i < recent.length; i++) {
    const diff = recent[i] - recent[i - 1];
    if (diff > 0) sumUp += diff;
    if (diff < 0) sumDown += Math.abs(diff);
  }

  // Threshold for sideways: < 0.1% average change
  const avgChange = (sumUp + sumDown) / (recent.length - 1);
  const threshold = recent[recent.length - 1] * 0.001;

  if (avgChange < threshold) return 'sideways';
  if (sumUp > sumDown) return 'up';
  if (sumDown > sumUp) return 'down';

  return 'sideways';
}

/**
 * Safe calculation wrapper with error handling
 */
export async function safeCalculate<T>(
  calculationFn: () => T,
  indicatorName: string
): Promise<T> {
  try {
    const startTime = Date.now();
    const result = calculationFn();
    const calculationTime = Date.now() - startTime;

    logger.debug(`${indicatorName} calculated successfully`, { calculationTime });

    return result;
  } catch (error) {
    logger.error(`Error calculating ${indicatorName}`, { error });
    throw new Error(`Failed to calculate ${indicatorName}: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// ============================================================================
// CRYPTO-SPECIFIC MOMENTUM INDICATORS
// ============================================================================

/**
 * Calculate Stochastic RSI
 * Popular in crypto - applies stochastic oscillator to RSI values
 */
export function calculateStochasticRSI(
  data: OHLCVData[],
  rsiPeriod: number = 14,
  stochPeriod: number = 14,
  kPeriod: number = 3,
  dPeriod: number = 3
): Array<{ k: number; d: number }> {
  const minLength = rsiPeriod + stochPeriod + Math.max(kPeriod, dPeriod);
  validateDataLength(data, minLength, 'Stochastic RSI');
  validateParameter(rsiPeriod, 'rsiPeriod', 2, 100);
  validateParameter(stochPeriod, 'stochPeriod', 2, 100);
  validateParameter(kPeriod, 'kPeriod', 1, 20);
  validateParameter(dPeriod, 'dPeriod', 1, 20);

  const values = getClosePrices(data);

  const stochRSI = TI.StochasticRSI.calculate({
    values,
    rsiPeriod,
    stochasticPeriod: stochPeriod,
    kPeriod,
    dPeriod,
  });

  return stochRSI;
}

/**
 * Calculate Awesome Oscillator (Bill Williams)
 * Difference between 5-period and 34-period simple moving averages of midpoint prices
 */
export function calculateAO(
  data: OHLCVData[],
  fastPeriod: number = 5,
  slowPeriod: number = 34
): number[] {
  validateDataLength(data, slowPeriod, 'Awesome Oscillator');
  validateParameter(fastPeriod, 'fastPeriod', 2, 50);
  validateParameter(slowPeriod, 'slowPeriod', 10, 100);

  if (fastPeriod >= slowPeriod) {
    throw new Error('fastPeriod must be less than slowPeriod');
  }

  const high = getHighPrices(data);
  const low = getLowPrices(data);

  const ao = TI.AwesomeOscillator.calculate({
    high,
    low,
    fastPeriod,
    slowPeriod,
  });

  return ao;
}

// /**
//  * Calculate True Strength Index (TSI)
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateTSI(
//   data: OHLCVData[],
//   longPeriod: number = 25,
//   shortPeriod: number = 13
// ): number[] {
//   throw new Error('TSI (True Strength Index) is not available in technicalindicators library');
// }

/**
 * Calculate Know Sure Thing (KST)
 * Complex momentum oscillator using four ROC timeframes
 */
export function calculateKST(
  data: OHLCVData[],
  roc1: number = 10,
  roc2: number = 15,
  roc3: number = 20,
  roc4: number = 30,
  sma1: number = 10,
  sma2: number = 10,
  sma3: number = 10,
  sma4: number = 15,
  signalPeriod: number = 9
): Array<{ kst: number; signal: number }> {
  const minLength = Math.max(roc4 + sma4, signalPeriod) + 10;
  validateDataLength(data, minLength, 'KST');

  const values = getClosePrices(data);

  const kst = TI.KST.calculate({
    values,
    ROCPer1: roc1,
    ROCPer2: roc2,
    ROCPer3: roc3,
    ROCPer4: roc4,
    SMAROCPer1: sma1,
    SMAROCPer2: sma2,
    SMAROCPer3: sma3,
    SMAROCPer4: sma4,
    signalPeriod,
  });

  return kst;
}

/**
 * Calculate Force Index
 * Combines price movement and volume
 */
export function calculateForceIndex(data: OHLCVData[], period: number = 13): number[] {
  validateDataLength(data, period + 1, 'Force Index');
  validateParameter(period, 'period', 1, 100);

  const close = getClosePrices(data);
  const volume = getVolumes(data);

  const forceIndex = TI.ForceIndex.calculate({
    close,
    volume,
    period,
  });

  return forceIndex;
}

// ============================================================================
// CRYPTO-SPECIFIC TREND INDICATORS
// ============================================================================

/**
 * Calculate WEMA (Weighted Exponential Moving Average)
 * Available in technicalindicators library
 */
export function calculateWEMA(data: OHLCVData[], period: number = 20): number[] {
  validateDataLength(data, period, 'WEMA');
  validateParameter(period, 'period', 2, 500);

  const values = getClosePrices(data);

  const wema = TI.WEMA.calculate({
    values,
    period,
  });

  return wema;
}

// ============================================================================
// NOTE: The following indicators are NOT available in technicalindicators v3.1.0
// They have been commented out but kept for reference/future manual implementation
// ============================================================================

// /**
//  * Calculate DEMA (Double Exponential Moving Average)
//  * NOT AVAILABLE in technicalindicators library
//  * Manual implementation would be needed
//  */
// export function calculateDEMA(data: OHLCVData[], period: number = 20): number[] {
//   // Not available in library
//   throw new Error('DEMA is not available in technicalindicators library');
// }

// /**
//  * Calculate TEMA (Triple Exponential Moving Average)
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateTEMA(data: OHLCVData[], period: number = 20): number[] {
//   throw new Error('TEMA is not available in technicalindicators library');
// }

// /**
//  * Calculate HMA (Hull Moving Average)
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateHMA(data: OHLCVData[], period: number = 9): number[] {
//   throw new Error('HMA is not available in technicalindicators library');
// }

// /**
//  * Calculate VWMA (Volume Weighted Moving Average)
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateVWMA(data: OHLCVData[], period: number = 20): number[] {
//   throw new Error('VWMA is not available in technicalindicators library');
// }

// /**
//  * Calculate Aroon Indicator
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateAroon(
//   data: OHLCVData[],
//   period: number = 25
// ): Array<{ aroonUp: number; aroonDown: number }> {
//   throw new Error('Aroon is not available in technicalindicators library');
// }

/**
 * Calculate Ichimoku Cloud
 * Comprehensive trend indicator - very popular in crypto
 */
export function calculateIchimoku(
  data: OHLCVData[],
  conversionPeriod: number = 9,
  basePeriod: number = 26,
  spanBPeriod: number = 52,
  displacement: number = 26
): Array<{
  conversion: number;
  base: number;
  spanA: number;
  spanB: number;
}> {
  const minLength = Math.max(spanBPeriod, displacement) + 10;
  validateDataLength(data, minLength, 'Ichimoku');
  validateParameter(conversionPeriod, 'conversionPeriod', 2, 50);
  validateParameter(basePeriod, 'basePeriod', 10, 100);
  validateParameter(spanBPeriod, 'spanBPeriod', 20, 200);
  validateParameter(displacement, 'displacement', 1, 100);

  const high = getHighPrices(data);
  const low = getLowPrices(data);

  const ichimoku = TI.IchimokuCloud.calculate({
    high,
    low,
    conversionPeriod,
    basePeriod,
    spanPeriod: spanBPeriod,
    displacement,
  });

  return ichimoku;
}

// ============================================================================
// CRYPTO-SPECIFIC VOLATILITY INDICATORS
// ============================================================================

/**
 * Calculate Keltner Channels
 * EMA-based channels using ATR for bandwidth
 */
export function calculateKeltnerChannels(
  data: OHLCVData[],
  period: number = 20,
  atrPeriod: number = 10,
  atrMultiplier: number = 2
): Array<{ upper: number; middle: number; lower: number }> {
  const minLength = Math.max(period, atrPeriod * 2);
  validateDataLength(data, minLength, 'Keltner Channels');
  validateParameter(period, 'period', 2, 100);
  validateParameter(atrPeriod, 'atrPeriod', 2, 100);
  validateParameter(atrMultiplier, 'atrMultiplier', 0.5, 5);

  const high = getHighPrices(data);
  const low = getLowPrices(data);
  const close = getClosePrices(data);

  const keltner = TI.KeltnerChannels.calculate({
    high,
    low,
    close,
    period,
    atrPeriod,
    atrMultiplier,
  });

  return keltner;
}

// /**
//  * Calculate Donchian Channel
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateDonchianChannel(
//   data: OHLCVData[],
//   period: number = 20
// ): Array<{ upper: number; middle: number; lower: number }> {
//   throw new Error('DonchianChannel is not available in technicalindicators library');
// }

// ============================================================================
// CRYPTO-SPECIFIC VOLUME INDICATORS
// ============================================================================

// /**
//  * Calculate Chaikin Money Flow (CMF)
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateCMF(data: OHLCVData[], period: number = 20): number[] {
//   throw new Error('CMF (Chaikin Money Flow) is not available in technicalindicators library');
// }

// /**
//  * Calculate Volume Oscillator
//  * NOT AVAILABLE in technicalindicators library
//  */
// export function calculateVolumeOscillator(
//   data: OHLCVData[],
//   shortPeriod: number = 5,
//   longPeriod: number = 10
// ): number[] {
//   throw new Error('VolumeOscillator is not available in technicalindicators library');
// }

// ============================================================================
// SUPPORT & RESISTANCE INDICATORS
// ============================================================================

/**
 * Calculate Pivot Points
 * Support and resistance levels based on previous period's high, low, close
 * Methods: classic, fibonacci, woodie, camarilla
 */
export function calculatePivotPoints(
  data: OHLCVData[],
  method: 'classic' | 'fibonacci' | 'woodie' | 'camarilla' = 'classic'
): {
  pivot: number;
  r1: number;
  r2: number;
  r3: number;
  s1: number;
  s2: number;
  s3: number;
} {
  validateDataLength(data, 1, 'Pivot Points');

  // Use previous candle for pivot calculation
  const prevCandle = data[data.length - 1];
  const { high, low, close } = prevCandle;

  let pivot: number;
  let r1: number;
  let r2: number;
  let r3: number;
  let s1: number;
  let s2: number;
  let s3: number;

  switch (method) {
    case 'classic':
      pivot = (high + low + close) / 3;
      r1 = 2 * pivot - low;
      r2 = pivot + (high - low);
      r3 = high + 2 * (pivot - low);
      s1 = 2 * pivot - high;
      s2 = pivot - (high - low);
      s3 = low - 2 * (high - pivot);
      break;

    case 'fibonacci':
      pivot = (high + low + close) / 3;
      r1 = pivot + 0.382 * (high - low);
      r2 = pivot + 0.618 * (high - low);
      r3 = pivot + 1.0 * (high - low);
      s1 = pivot - 0.382 * (high - low);
      s2 = pivot - 0.618 * (high - low);
      s3 = pivot - 1.0 * (high - low);
      break;

    case 'woodie':
      pivot = (high + low + 2 * close) / 4;
      r1 = 2 * pivot - low;
      r2 = pivot + high - low;
      r3 = high + 2 * (pivot - low);
      s1 = 2 * pivot - high;
      s2 = pivot - high + low;
      s3 = low - 2 * (high - pivot);
      break;

    case 'camarilla':
      pivot = (high + low + close) / 3;
      r1 = close + (high - low) * 1.1 / 12;
      r2 = close + (high - low) * 1.1 / 6;
      r3 = close + (high - low) * 1.1 / 4;
      s1 = close - (high - low) * 1.1 / 12;
      s2 = close - (high - low) * 1.1 / 6;
      s3 = close - (high - low) * 1.1 / 4;
      break;

    default:
      throw new Error(`Unknown pivot point method: ${method}`);
  }

  return {
    pivot,
    r1,
    r2,
    r3,
    s1,
    s2,
    s3,
  };
}

/**
 * Calculate Fibonacci Retracement Levels
 * Key support/resistance levels based on Fibonacci ratios
 */
export function calculateFibonacciRetracement(
  high: number,
  low: number,
  trend: 'uptrend' | 'downtrend' = 'uptrend'
): {
  level_0: number;
  level_236: number;
  level_382: number;
  level_500: number;
  level_618: number;
  level_786: number;
  level_100: number;
  level_1272: number;
  level_1618: number;
} {
  validateParameter(high, 'high', 0);
  validateParameter(low, 'low', 0);

  if (high <= low) {
    throw new Error('High must be greater than low');
  }

  const range = high - low;

  if (trend === 'uptrend') {
    // In uptrend: retracement from high down to low
    return {
      level_0: high, // 0% - swing high
      level_236: high - range * 0.236,
      level_382: high - range * 0.382,
      level_500: high - range * 0.5,
      level_618: high - range * 0.618, // Golden ratio
      level_786: high - range * 0.786,
      level_100: low, // 100% - swing low
      level_1272: high - range * 1.272, // Extensions
      level_1618: high - range * 1.618,
    };
  } else {
    // In downtrend: retracement from low up to high
    return {
      level_0: low, // 0% - swing low
      level_236: low + range * 0.236,
      level_382: low + range * 0.382,
      level_500: low + range * 0.5,
      level_618: low + range * 0.618, // Golden ratio
      level_786: low + range * 0.786,
      level_100: high, // 100% - swing high
      level_1272: low + range * 1.272, // Extensions
      level_1618: low + range * 1.618,
    };
  }
}
