/**
 * Indicator Factory Service
 * Factory pattern for creating and calculating indicators with type safety
 *
 * @module indicators/services/indicator-factory
 */

import type {
  BaseIndicatorConfig,
  IndicatorType,
  IndicatorResult,
  OHLCVData,
  RSIConfig,
  RSIResult,
  MACDConfig,
  MACDResult,
  StochasticConfig,
  StochasticResult,
  CCIConfig,
  CCIResult,
  ROCConfig,
  ROCResult,
  MFIConfig,
  MFIResult,
  SMAConfig,
  SMAResult,
  EMAConfig,
  EMAResult,
  WMAConfig,
  WMAResult,
  ADXConfig,
  ADXResult,
  ParabolicSARConfig,
  ParabolicSARResult,
  BollingerBandsConfig,
  BollingerBandsResult,
  ATRConfig,
  ATRResult,
  KeltnerConfig,
  KeltnerResult,
  StandardDevConfig,
  StandardDevResult,
  OBVConfig,
  OBVResult,
  VWAPConfig,
  VWAPResult,
} from '../types/indicators.types';
import type {
  StochasticRSIConfig,
  StochasticRSIResult,
  AOConfig,
  AOResult,
  TSIConfig,
  TSIResult,
  KSTConfig,
  KSTResult,
  ForceIndexConfig,
  ForceIndexResult,
  DEMAConfig,
  DEMAResult,
  TEMAConfig,
  TEMAResult,
  HMAConfig,
  HMAResult,
  AroonConfig,
  AroonResult,
  IchimokuConfig,
  IchimokuResult,
  DonchianChannelConfig,
  DonchianChannelResult,
  CMFConfig,
  CMFResult,
  VolumeOscillatorConfig,
  VolumeOscillatorResult,
  PivotPointsConfig,
  PivotPointsResult,
  FibonacciRetracementConfig,
  FibonacciRetracementResult,
} from '../types/crypto-indicators.types';
// import * as Calculator from '../utils/indicator-calculator'; // OLD - needs refactor to calculator-v2 (async)
// import logger from '../../../utils/logger'; // Path alias not configured

/**
 * Indicator Factory for type-safe indicator creation
 * TODO: Refactor to use calculator-v2 (async) instead of old calculator
 * For now, use calculator-v2 functions directly instead of this factory
 */
export class IndicatorFactory {
  /**
   * Calculate RSI (Relative Strength Index)
   */
  static calculateRSI(data: OHLCVData[], config: RSIConfig): IndicatorResult<RSIResult> {
    const startTime = Date.now();
    const values = Calculator.calculateRSI(data, config.period);
    const latestValue = Calculator.getLatestValue(values);

    const result: RSIResult = {
      rsi: latestValue || 0,
      overbought: latestValue ? latestValue > 70 : false,
      oversold: latestValue ? latestValue < 30 : false,
    };

    return {
      type: 'RSI',
      category: 'momentum',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate MACD (Moving Average Convergence Divergence)
   */
  static calculateMACD(data: OHLCVData[], config: MACDConfig): IndicatorResult<MACDResult> {
    const startTime = Date.now();
    const values = Calculator.calculateMACD(data, config.fastPeriod, config.slowPeriod, config.signalPeriod);
    const latestValue = Calculator.getLatestValue(values);
    const prevValue = values[values.length - 2];

    const crossover =
      latestValue && prevValue
        ? Calculator.detectCrossover(latestValue.MACD, prevValue.MACD, latestValue.signal, prevValue.signal)
        : null;

    const result: MACDResult = {
      macd: latestValue?.MACD || 0,
      signal: latestValue?.signal || 0,
      histogram: latestValue?.histogram || 0,
      crossover,
    };

    return {
      type: 'MACD',
      category: 'momentum',
      timestamp: new Date(),
      value: result,
      metadata: {
        parameters: {
          fastPeriod: config.fastPeriod,
          slowPeriod: config.slowPeriod,
          signalPeriod: config.signalPeriod,
        },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate Stochastic Oscillator
   */
  static calculateStochastic(data: OHLCVData[], config: StochasticConfig): IndicatorResult<StochasticResult> {
    const startTime = Date.now();
    const values = Calculator.calculateStochastic(data, config.period, config.signalPeriod);
    const latestValue = Calculator.getLatestValue(values);

    const result: StochasticResult = {
      k: latestValue?.k || 0,
      d: latestValue?.d || 0,
      overbought: latestValue ? latestValue.k > 80 : false,
      oversold: latestValue ? latestValue.k < 20 : false,
    };

    return {
      type: 'Stochastic',
      category: 'momentum',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        parameters: { signalPeriod: config.signalPeriod, smoothPeriod: config.smoothPeriod },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate Stochastic RSI
   */
  static calculateStochasticRSI(
    data: OHLCVData[],
    config: StochasticRSIConfig
  ): IndicatorResult<StochasticRSIResult> {
    const startTime = Date.now();
    const values = Calculator.calculateStochasticRSI(
      data,
      config.rsiPeriod,
      config.stochPeriod,
      config.kPeriod,
      config.dPeriod
    );
    const latestValue = Calculator.getLatestValue(values);

    const result: StochasticRSIResult = {
      k: latestValue?.k || 0,
      d: latestValue?.d || 0,
      overbought: latestValue ? latestValue.k > 80 : false,
      oversold: latestValue ? latestValue.k < 20 : false,
      extremeOverbought: latestValue ? latestValue.k > 95 : false,
      extremeOversold: latestValue ? latestValue.k < 5 : false,
    };

    return {
      type: 'StochasticRSI',
      category: 'momentum',
      timestamp: new Date(),
      value: result,
      metadata: {
        parameters: {
          rsiPeriod: config.rsiPeriod,
          stochPeriod: config.stochPeriod,
          kPeriod: config.kPeriod,
          dPeriod: config.dPeriod,
        },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate Bollinger Bands
   */
  static calculateBollingerBands(
    data: OHLCVData[],
    config: BollingerBandsConfig
  ): IndicatorResult<BollingerBandsResult> {
    const startTime = Date.now();
    const values = Calculator.calculateBollingerBands(data, config.period, config.stdDevMultiplier);
    const latestValue = Calculator.getLatestValue(values);

    const result: BollingerBandsResult = {
      upper: latestValue?.upper || 0,
      middle: latestValue?.middle || 0,
      lower: latestValue?.lower || 0,
      bandwidth: latestValue?.bandwidth || 0,
      percentB: latestValue?.pb || 0,
      squeeze: latestValue ? latestValue.bandwidth < 0.1 : false,
    };

    return {
      type: 'BollingerBands',
      category: 'volatility',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        parameters: { stdDevMultiplier: config.stdDevMultiplier },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate ATR (Average True Range)
   */
  static calculateATR(data: OHLCVData[], config: ATRConfig): IndicatorResult<ATRResult> {
    const startTime = Date.now();
    const values = Calculator.calculateATR(data, config.period);
    const latestValue = Calculator.getLatestValue(values);
    const currentPrice = data[data.length - 1]?.close || 1;
    const atrPercent = latestValue ? (latestValue / currentPrice) * 100 : 0;

    let volatility: 'low' | 'normal' | 'high' | 'extreme';
    if (atrPercent > 5) volatility = 'extreme';
    else if (atrPercent > 3) volatility = 'high';
    else if (atrPercent > 1) volatility = 'normal';
    else volatility = 'low';

    const result: ATRResult = {
      atr: latestValue || 0,
      atrPercent,
      volatility,
    };

    return {
      type: 'ATR',
      category: 'volatility',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate SMA (Simple Moving Average)
   */
  static calculateSMA(data: OHLCVData[], config: SMAConfig): IndicatorResult<SMAResult> {
    const startTime = Date.now();
    const values = Calculator.calculateSMA(data, config.period);
    const latestValue = Calculator.getLatestValue(values);
    const currentPrice = data[data.length - 1]?.close || 0;

    const result: SMAResult = {
      sma: latestValue || 0,
      trend: Calculator.determineTrend(values),
      distance: currentPrice - (latestValue || 0),
      distancePercent: Calculator.calculatePercentDiff(currentPrice, latestValue || currentPrice),
    };

    return {
      type: 'SMA',
      category: 'trend',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate EMA (Exponential Moving Average)
   */
  static calculateEMA(data: OHLCVData[], config: EMAConfig): IndicatorResult<EMAResult> {
    const startTime = Date.now();
    const values = Calculator.calculateEMA(data, config.period);
    const latestValue = Calculator.getLatestValue(values);
    const currentPrice = data[data.length - 1]?.close || 0;

    const result: EMAResult = {
      ema: latestValue || 0,
      trend: Calculator.determineTrend(values),
      distance: currentPrice - (latestValue || 0),
      distancePercent: Calculator.calculatePercentDiff(currentPrice, latestValue || currentPrice),
    };

    return {
      type: 'EMA',
      category: 'trend',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate VWAP (Volume Weighted Average Price)
   */
  static calculateVWAP(data: OHLCVData[], config: VWAPConfig): IndicatorResult<VWAPResult> {
    const startTime = Date.now();
    const values = Calculator.calculateVWAP(data);
    const latestValue = Calculator.getLatestValue(values);
    const currentPrice = data[data.length - 1]?.close || 0;

    const distance = currentPrice - (latestValue || 0);
    const distancePercent = Calculator.calculatePercentDiff(currentPrice, latestValue || currentPrice);

    let position: 'above' | 'below' | 'at';
    if (Math.abs(distancePercent) < 0.1) position = 'at';
    else if (distance > 0) position = 'above';
    else position = 'below';

    const result: VWAPResult = {
      vwap: latestValue || 0,
      distance,
      distancePercent,
      position,
    };

    return {
      type: 'VWAP',
      category: 'volume',
      timestamp: new Date(),
      value: result,
      metadata: {
        period: config.period,
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate Ichimoku Cloud
   */
  static calculateIchimoku(data: OHLCVData[], config: IchimokuConfig): IndicatorResult<IchimokuResult> {
    const startTime = Date.now();
    const values = Calculator.calculateIchimoku(
      data,
      config.conversionPeriod,
      config.basePeriod,
      config.spanBPeriod,
      config.displacement
    );
    const latestValue = Calculator.getLatestValue(values);
    const currentPrice = data[data.length - 1]?.close || 0;

    // Determine cloud color and signal
    const cloudColor: 'bullish' | 'bearish' =
      latestValue && latestValue.spanA > latestValue.spanB ? 'bullish' : 'bearish';

    let signal: 'strong-buy' | 'buy' | 'neutral' | 'sell' | 'strong-sell' = 'neutral';
    if (latestValue) {
      const aboveCloud = currentPrice > Math.max(latestValue.spanA, latestValue.spanB);
      const belowCloud = currentPrice < Math.min(latestValue.spanA, latestValue.spanB);
      const tkCross = latestValue.conversion > latestValue.base;

      if (aboveCloud && cloudColor === 'bullish' && tkCross) signal = 'strong-buy';
      else if (aboveCloud && cloudColor === 'bullish') signal = 'buy';
      else if (belowCloud && cloudColor === 'bearish' && !tkCross) signal = 'strong-sell';
      else if (belowCloud && cloudColor === 'bearish') signal = 'sell';
    }

    const result: IchimokuResult = {
      tenkanSen: latestValue?.conversion || 0,
      kijunSen: latestValue?.base || 0,
      senkouSpanA: latestValue?.spanA || 0,
      senkouSpanB: latestValue?.spanB || 0,
      chikouSpan: currentPrice, // Simplified - should be displaced
      cloudColor,
      signal,
    };

    return {
      type: 'Ichimoku',
      category: 'trend',
      timestamp: new Date(),
      value: result,
      metadata: {
        parameters: {
          conversionPeriod: config.conversionPeriod,
          basePeriod: config.basePeriod,
          spanBPeriod: config.spanBPeriod,
          displacement: config.displacement,
        },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate Pivot Points
   */
  static calculatePivotPoints(
    data: OHLCVData[],
    config: PivotPointsConfig
  ): IndicatorResult<PivotPointsResult> {
    const startTime = Date.now();
    const pivots = Calculator.calculatePivotPoints(data, config.method);
    const currentPrice = data[data.length - 1]?.close || 0;

    // Determine current position
    let currentPosition:
      | 'above-R3'
      | 'R2-R3'
      | 'R1-R2'
      | 'P-R1'
      | 'S1-P'
      | 'S2-S1'
      | 'S3-S2'
      | 'below-S3';

    if (currentPrice > pivots.r3) currentPosition = 'above-R3';
    else if (currentPrice > pivots.r2) currentPosition = 'R2-R3';
    else if (currentPrice > pivots.r1) currentPosition = 'R1-R2';
    else if (currentPrice > pivots.pivot) currentPosition = 'P-R1';
    else if (currentPrice > pivots.s1) currentPosition = 'S1-P';
    else if (currentPrice > pivots.s2) currentPosition = 'S2-S1';
    else if (currentPrice > pivots.s3) currentPosition = 'S3-S2';
    else currentPosition = 'below-S3';

    const result: PivotPointsResult = {
      pivot: pivots.pivot,
      resistance1: pivots.r1,
      resistance2: pivots.r2,
      resistance3: pivots.r3,
      support1: pivots.s1,
      support2: pivots.s2,
      support3: pivots.s3,
      currentPosition,
    };

    return {
      type: 'PivotPoints',
      category: 'support_resistance',
      timestamp: new Date(),
      value: result,
      metadata: {
        parameters: { method: config.method },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Calculate Fibonacci Retracement
   */
  static calculateFibonacciRetracement(
    config: FibonacciRetracementConfig
  ): IndicatorResult<FibonacciRetracementResult> {
    const startTime = Date.now();
    const levels = Calculator.calculateFibonacciRetracement(config.high, config.low, config.trend);

    // Find nearest level
    const currentPrice = config.trend === 'uptrend' ? config.high : config.low;
    const levelEntries = Object.entries(levels).map(([name, value]) => ({ name, value: value as number }));
    const nearest = levelEntries.reduce((prev, curr) =>
      Math.abs(curr.value - currentPrice) < Math.abs(prev.value - currentPrice) ? curr : prev
    );

    const result: FibonacciRetracementResult = {
      level_0: levels.level_0,
      level_236: levels.level_236,
      level_382: levels.level_382,
      level_500: levels.level_500,
      level_618: levels.level_618,
      level_786: levels.level_786,
      level_100: levels.level_100,
      level_1272: levels.level_1272,
      level_1618: levels.level_1618,
      nearestLevel: nearest.value,
      nearestLevelName: nearest.name,
    };

    return {
      type: 'FibonacciRetracement',
      category: 'support_resistance',
      timestamp: new Date(),
      value: result,
      metadata: {
        parameters: { high: config.high, low: config.low, trend: config.trend },
        calculationTime: Date.now() - startTime,
      },
    };
  }

  /**
   * Generic calculate method that routes to appropriate calculator
   */
  static calculate(data: OHLCVData[], config: BaseIndicatorConfig): IndicatorResult<any> {
    switch (config.type) {
      case 'RSI':
        return this.calculateRSI(data, config as RSIConfig);
      case 'MACD':
        return this.calculateMACD(data, config as MACDConfig);
      case 'Stochastic':
        return this.calculateStochastic(data, config as StochasticConfig);
      case 'StochasticRSI':
        return this.calculateStochasticRSI(data, config as StochasticRSIConfig);
      case 'BollingerBands':
        return this.calculateBollingerBands(data, config as BollingerBandsConfig);
      case 'ATR':
        return this.calculateATR(data, config as ATRConfig);
      case 'SMA':
        return this.calculateSMA(data, config as SMAConfig);
      case 'EMA':
        return this.calculateEMA(data, config as EMAConfig);
      case 'VWAP':
        return this.calculateVWAP(data, config as VWAPConfig);
      case 'Ichimoku':
        return this.calculateIchimoku(data, config as IchimokuConfig);
      case 'PivotPoints':
        return this.calculatePivotPoints(data, config as PivotPointsConfig);
      // Add more cases as needed
      default:
        throw new Error(`Indicator type ${config.type} not implemented in factory`);
    }
  }
}

/**
 * Export convenience functions
 * NOTE: Commented out to avoid duplicate exports with calculator-v2
 * Use IndicatorFactory.calculate() or import directly from calculator-v2
 */
// export const calculateIndicator = IndicatorFactory.calculate.bind(IndicatorFactory);
// export const calculateRSI = IndicatorFactory.calculateRSI.bind(IndicatorFactory);
// export const calculateMACD = IndicatorFactory.calculateMACD.bind(IndicatorFactory);
// export const calculateBollingerBands = IndicatorFactory.calculateBollingerBands.bind(IndicatorFactory);
// export const calculateATR = IndicatorFactory.calculateATR.bind(IndicatorFactory);
// export const calculateVWAP = IndicatorFactory.calculateVWAP.bind(IndicatorFactory);
